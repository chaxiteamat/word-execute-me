<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World.execute(me) Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Black background for contrast */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="animationCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas dimensions to fill window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Set initial canvas background
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Redraw background on resize
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        });

        const lyricsData = [
            {time: 0, lyric: "Switch on the power line"},
            {time: 0, lyric: "Remember to put on protection"},
            {time: 0, lyric: "Lay down your pieces"},
            {time: 0, lyric: "And let's begin object creation"},
            {time: 7.08, lyric: "Fill in my data parameters"},
            {time: 9.76, lyric: "Initialization"},
            {time: 11.06, lyric: "Set up our new world"},
            {time: 12.66, lyric: "And let's begin the simulation"},
            {time: 29.13, lyric: "If I'm a set of point"},
            {time: 30.98, lyric: "Then I will give you my dimension"},
            {time: 33.11, lyric: "If I'm a circle"},
            {time: 34.71, lyric: "Then I will give you my circumference"},
            {time: 36.56, lyric: "If I'm a sine wave"},
            {time: 38.42, lyric: "Then you can sit on all my tangents"},
            {time: 40.28, lyric: "If I approach infinity"},
            {time: 41.88, lyric: "Then you can be my limitations"},
            {time: 44.01, lyric: "Switch my current"},
            {time: 45.86, lyric: "To AC, to DC"},
            {time: 47.46, lyric: "And then blind my vision"},
            {time: 49.32, lyric: "So dizzy, so dizzy"},
            {time: 51.17, lyric: "Oh, we can travel"},
            {time: 53.04, lyric: "To AD, to BC"},
            {time: 54.90, lyric: "And we can unite"},
            {time: 56.75, lyric: "So deeply, so deeply"},
            {time: 58.87, lyric: "If I can, if I can"},
            {time: 60.74, lyric: "Give you all the simulations"},
            {time: 62.60, lyric: "Then I can, then I can"},
            {time: 64.19, lyric: "Be your only satisfaction"},
            {time: 66.31, lyric: "If I can make you happy"},
            {time: 68.18, lyric: "I will run the execution"},
            {time: 70.03, lyric: "Though we are trapped"},
            {time: 71.63, lyric: "In this strange, strange simulation"},
            {time: 73.49, lyric: "If I'm an eggplant"},
            {time: 75.34, lyric: "Then I will give u my nutrients"},
            {time: 77.20, lyric: "If I'm a tomato"},
            {time: 78.80, lyric: "Then I will give you antioxidants"},
            {time: 80.93, lyric: "If I'm a tabby cat"},
            {time: 82.51, lyric: "Then I will purr for your enjoyment"},
            {time: 84.64, lyric: "If I'm the only God"},
            {time: 86.24, lyric: "Then you're the proof of my existence"},
            {time: 88.37, lyric: "Switch my gender"},
            {time: 89.95, lyric: "To F, to M"},
            {time: 91.54, lyric: "And then do whatever"},
            {time: 93.67, lyric: "From AM to PM"},
            {time: 95.27, lyric: "Oh, my switch role"},
            {time: 97.39, lyric: "To S, to M"},
            {time: 98.98, lyric: "So we can enter"},
            {time: 101.12, lyric: "The trance, the trance"},
            {time: 103.24, lyric: "If I can, if I can"},
            {time: 105.09, lyric: "Feel your vibrations"},
            {time: 106.96, lyric: "Then I can, then I can"},
            {time: 108.83, lyric: "Finally be completion"},
            {time: 110.67, lyric: "Though you have left"},
            {time: 111.73, lyric: "You have left"},
            {time: 112.80, lyric: "You have left"},
            {time: 113.86, lyric: "You have left"},
            {time: 114.66, lyric: "You have left"},
            {time: 115.73, lyric: "You have left me in isolation"},
            {time: 117.85, lyric: "If I can, if I can"},
            {time: 119.70, lyric: "Erase all the pointless fragments"},
            {time: 121.56, lyric: "Then maybe, then maybe"},
            {time: 123.42, lyric: "You won't leave me so disheartened"},
            {time: 125.55, lyric: "Challenging your God"},
            {time: 128.47, lyric: "You have made some"},
            {time: 130.87, lyric: "Illegal arguments"},
            {time: 147.51, lyric: "Execution, execution"},
            {time: 149.36, lyric: "Execution, execution"},
            {time: 151.22, lyric: "Execution, execution"},
            {time: 153.35, lyric: "Execution, execution"},
            {time: 154.95, lyric: "Execution, execution"},
            {time: 156.80, lyric: "Execution, execution"},
            {time: 158.52, lyric: "Ein, dos"},
            {time: 159.58, lyric: "Trios, ne"},
            {time: 160.64, lyric: "Fem, liu"},
            {time: 161.17, lyric: "Execution"},
            {time: 162.23, lyric: "If I can, if I can"},
            {time: 164.09, lyric: "Give them all the execution"},
            {time: 165.96, lyric: "Then I can, then I can"},
            {time: 167.81, lyric: "Be your only execution"},
            {time: 169.67, lyric: "If I can have you back"},
            {time: 171.53, lyric: "I will run the execution"},
            {time: 173.12, lyric: "Though we are trapped"},
            {time: 174.47, lyric: "We are trapped, ah"},
            {time: 177.01, lyric: "I've studied, I've studied"},
            {time: 178.85, lyric: "How to properly lo-o-ove"},
            {time: 180.82, lyric: "Question me, question me"},
            {time: 182.42, lyric: "I can answer all lo-o-ove"},
            {time: 184.28, lyric: "I know the algebraic expression of lo-o-ove"},
            {time: 188.00, lyric: "Though you are free"},
            {time: 189.59, lyric: "I am trapped"},
            {time: 190.39, lyric: "Trapped in lo-o-ove"},
            {time: 205.70, lyric: "Execution"}
        ];

        // Scene 1: "Switch on the power line" / "接上电源"
        function scene1() {
            const plug = {
                x: canvas.width / 2,
                y: canvas.height / 2 + 100,
                rotation: 45,
                insertionProgress: 0
            };

            const socket = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: 100,
                height: 50
            };

            const timeline = gsap.timeline();

            // Background transition from dark gray to light gray
            gsap.to({}, {
                duration: 2,
                onUpdate: function() {
                    const progress = this.progress();
                    const r = Math.floor(26 + (58 - 26) * progress); // 1a to 3a
                    const g = Math.floor(26 + (58 - 26) * progress);
                    const b = Math.floor(26 + (58 - 26) * progress);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            });

            timeline.to(plug, {
                y: canvas.height / 2 + 10,
                insertionProgress: 1,
                duration: 1.5,
                ease: "power1.in",
                onUpdate: function() {
                    // Clear the entire canvas and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background with current progress
                    const bgProgress = this.progress();
                    const r = Math.floor(26 + (58 - 26) * bgProgress);
                    const g = Math.floor(26 + (58 - 26) * bgProgress);
                    const b = Math.floor(26 + (58 - 26) * bgProgress);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw socket (darker grey)
                    ctx.fillStyle = '#333';
                    ctx.fillRect(socket.x - socket.width / 2, socket.y - socket.height / 2, socket.width, socket.height);

                    // Draw copper contacts inside socket
                    ctx.fillStyle = '#b87333'; // Copper color
                    ctx.fillRect(socket.x - 30, socket.y - 5, 20, 10);
                    ctx.fillRect(socket.x + 10, socket.y - 5, 20, 10);

                    // Draw plug with metallic texture and current texture
                    ctx.save();
                    ctx.translate(plug.x, plug.y);
                    ctx.rotate(plug.rotation * Math.PI / 180);
                    
                    // Main plug body with metallic gradient
                    const gradient = ctx.createLinearGradient(-30, 0, 30, 0);
                    gradient.addColorStop(0, '#a0a0a0');
                    gradient.addColorStop(0.5, '#c0c0c0');
                    gradient.addColorStop(1, '#a0a0a0');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-30, -15, 60, 30);
                    
                    // Add metallic shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(-25, -10, 50, 3);
                    
                    // Add current texture lines
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 1;
                    for (let i = -20; i <= 20; i += 5) {
                        ctx.beginPath();
                        ctx.moveTo(i, -10);
                        ctx.lineTo(i + 2, 10);
                        ctx.stroke();
                    }
                    
                    ctx.restore();

                    // Draw white spark when plug is almost inserted
                    if (plug.insertionProgress > 0.8) {
                        const sparkOpacity = Math.min(1, (plug.insertionProgress - 0.8) * 5);
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkOpacity})`;
                        ctx.beginPath();
                        ctx.arc(socket.x, socket.y, 5 + Math.random() * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add spark rays
                        ctx.strokeStyle = `rgba(255, 255, 255, ${sparkOpacity})`;
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            ctx.beginPath();
                            ctx.moveTo(socket.x, socket.y);
                            ctx.lineTo(
                                socket.x + Math.cos(angle) * (10 + Math.random() * 5),
                                socket.y + Math.sin(angle) * (10 + Math.random() * 5)
                            );
                            ctx.stroke();
                        }
                    }
                }
            })
            .to({}, {
                duration: 0.5,
                onComplete: () => {
                    // Energy wave after plug fully inserted
                    gsap.to({ radius: 0, opacity: 1 }, {
                        radius: Math.min(canvas.width, canvas.height) / 3,
                        opacity: 0,
                        duration: 0.5,
                        ease: "power1.out",
                        onUpdate: function() {
                            const currentRadius = this.targets()[0].radius;
                            const currentOpacity = this.targets()[0].opacity;

                            // Clear canvas and redraw background
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Redraw background (light gray at this point)
                            ctx.fillStyle = '#3a3a3a';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Redraw socket
                            ctx.fillStyle = '#333';
                            ctx.fillRect(socket.x - socket.width / 2, socket.y - socket.height / 2, socket.width, socket.height);

                            // Draw 3 energy waves with decreasing opacity
                            ctx.strokeStyle = `rgba(255, 255, 255, ${currentOpacity})`;
                            ctx.lineWidth = 3;
                            for (let i = 1; i <= 3; i++) {
                                ctx.beginPath();
                                ctx.arc(socket.x, socket.y, currentRadius / 3 * i, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                    });
                }
            });

            return timeline;
        }

        // Scene 2: "Remember to put on PROTECTION" / "记得装备好绝缘护具"
        function scene2() {
            const helmet = {
                y: -100,
                rotation: 0
            };
            const gloveLeft = {
                x: -100,
                fingerProgress: 0
            };
            const gloveRight = {
                x: canvas.width + 100,
                fingerProgress: 0
            };
            const insulatingRod = {
                x: canvas.width + 100,
                y: canvas.height / 2
            };
            const character = {
                x: canvas.width / 2,
                y: canvas.height / 2 + 50
            };
            const protectionHalo = {
                radius: 0,
                opacity: 0
            };

            const timeline = gsap.timeline({
                onComplete: () => {
                    // Clear the canvas explicitly after scene 2 to prepare for the next scene
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            // Helmet descent with slight rotation
            timeline.to(helmet, {
                y: canvas.height / 2 - 100,
                rotation: 10,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background (light gray)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw helmet with reflective strips
                    ctx.save();
                    ctx.translate(canvas.width / 2, helmet.y);
                    ctx.rotate(helmet.rotation * Math.PI / 180);
                    
                    // Main helmet body (light gray)
                    ctx.fillStyle = '#cccccc';
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI * 2);
                    ctx.ellipse(0, -30, 50, 20, 0, 0, Math.PI, true);
                    ctx.fill();
                    
                    // Reflective strips (white)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-20, -10, 40, 5);
                    
                    // Add shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(-10, -20, 15, 5, -Math.PI / 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }, "start")
            
            // Left glove with finger bending animation
            .to(gloveLeft, {
                x: character.x - 70,
                fingerProgress: 1,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    // Clear canvas and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background (light gray)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw left glove (black rubber)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(gloveLeft.x, character.y);
                    ctx.lineTo(gloveLeft.x - 30, character.y + 20);
                    ctx.lineTo(gloveLeft.x - 20, character.y + 50);
                    ctx.lineTo(gloveLeft.x + 10, character.y + 40);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw fingers bending progressively
                    const fingerBend = gloveLeft.fingerProgress * 30;
                    for (let i = 0; i < 4; i++) {
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(gloveLeft.x + 10, character.y + 40 - i * 8);
                        ctx.quadraticCurveTo(
                            gloveLeft.x + 10 + fingerBend, 
                            character.y + 40 - i * 8 + 5,
                            gloveLeft.x + 10 + fingerBend * 0.7, 
                            character.y + 40 - i * 8 + 15
                        );
                        ctx.stroke();
                    }
                    
                    // Add insulation rating label
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px monospace';
                    ctx.fillText('1000V', gloveLeft.x - 15, character.y + 60);
                }
            }, "start")
            
            // Right glove with finger bending animation
            .to(gloveRight, {
                x: character.x + 70,
                fingerProgress: 1,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    // Clear canvas and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background (light gray)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw right glove (black rubber)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(gloveRight.x, character.y);
                    ctx.lineTo(gloveRight.x + 30, character.y + 20);
                    ctx.lineTo(gloveRight.x + 20, character.y + 50);
                    ctx.lineTo(gloveRight.x - 10, character.y + 40);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw fingers bending progressively
                    const fingerBend = gloveRight.fingerProgress * 30;
                    for (let i = 0; i < 4; i++) {
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(gloveRight.x - 10, character.y + 40 - i * 8);
                        ctx.quadraticCurveTo(
                            gloveRight.x - 10 - fingerBend, 
                            character.y + 40 - i * 8 + 5,
                            gloveRight.x - 10 - fingerBend * 0.7, 
                            character.y + 40 - i * 8 + 15
                        );
                        ctx.stroke();
                    }
                    
                    // Add insulation rating label
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px monospace';
                    ctx.fillText('1000V', gloveRight.x - 15, character.y + 60);
                }
            }, "start+=0.2")
            
            // Insulating rod with warning stripes
            .to(insulatingRod, {
                x: canvas.width - 150,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    // Clear canvas and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background (light gray)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw insulating rod
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(insulatingRod.x, insulatingRod.y - 5, 120, 10);
                    
                    // Draw warning stripes
                    ctx.fillStyle = '#666666';
                    for (let i = 0; i < 6; i += 2) {
                        ctx.fillRect(insulatingRod.x + i * 20, insulatingRod.y - 5, 10, 10);
                    }
                }
            }, "start+=0.4")
            
            // Protection halo expansion
            .to(protectionHalo, {
                radius: character.y * 1.5,
                opacity: 0.7,
                duration: 0.5,
                ease: "power1.out",
                onUpdate: () => {
                    // Clear canvas and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw background (light gray)
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw protection halo
                    ctx.strokeStyle = `rgba(255, 255, 255, ${protectionHalo.opacity})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, protectionHalo.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add inner glow
                    const gradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, protectionHalo.radius * 0.8,
                        canvas.width / 2, canvas.height / 2, protectionHalo.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
                    gradient.addColorStop(1, `rgba(255, 255, 255, ${protectionHalo.opacity * 0.3})`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, protectionHalo.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }, "start+=1.5");

            return timeline;
        }

        // Scene 3: "Lay down your pieces And let's begin OBJECT CREATION" / "摆好棋子 开始吧 对象生成"
        function scene3() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const codeText = "new Object()";
            let displayedCode = "";
            const cube = {
                scale: 0,
                rotation: 0,
                opacity: 0.5
            };
            const properties = {
                name: { visible: false, value: '"world"' },
                type: { visible: false, value: '"simulation"' }
            };
            const memoryBar = {
                filled: 0,
                maxMemory: 100
            };

            // Typewriter effect for code
            timeline.to({ index: 0 }, {
                index: codeText.length,
                duration: 1,
                ease: "none",
                onUpdate: function() {
                    displayedCode = codeText.substring(0, Math.round(this.targets()[0].index));
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw code editor background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
                    
                    // Draw code text
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px monospace';
                    const codeTextWidth = ctx.measureText(displayedCode).width;
                    ctx.fillText(displayedCode, canvas.width/2 - 140, canvas.height/2);
                    
                    // Draw blinking cursor
                    if (Math.floor(this.progress() * 20) % 2 === 0) {
                        const textWidth = ctx.measureText(displayedCode).width;
                        ctx.fillRect(canvas.width/2 - 140 + textWidth + 2, canvas.height/2 - 15, 2, 20);
                    }
                }
            })
            
            // Object generation from code
            .to(cube, {
                scale: 1,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw code
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '18px monospace';
                    ctx.fillText(codeText, canvas.width/2 - 140, canvas.height/2);
                    
                    // Draw growing cube from code
                    ctx.save();
                    ctx.translate(canvas.width/2, canvas.height/2 + 100);
                    ctx.rotate(cube.rotation);
                    ctx.scale(cube.scale, cube.scale);
                    
                    // Semi-transparent gray cube
                    ctx.fillStyle = `rgba(136, 136, 136, ${cube.opacity})`;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    // Front face
                    ctx.fillRect(-40, -40, 80, 80);
                    ctx.strokeRect(-40, -40, 80, 80);
                    
                    // Top face (3D effect)
                    ctx.beginPath();
                    ctx.moveTo(-40, -40);
                    ctx.lineTo(-20, -60);
                    ctx.lineTo(60, -60);
                    ctx.lineTo(40, -40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Right face (3D effect)
                    ctx.beginPath();
                    ctx.moveTo(40, -40);
                    ctx.lineTo(60, -60);
                    ctx.lineTo(60, 20);
                    ctx.lineTo(40, 40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Rotate cube
                    cube.rotation += 0.02;
                }
            })
            
            // Show properties
            .to(properties.name, {
                visible: true,
                duration: 0.5,
                onStart: () => {
                    // Animate name property appearing
                    const animateProperty = () => {
                        if (!properties.name.visible) return;
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Redraw cube
                        ctx.save();
                        ctx.translate(canvas.width/2, canvas.height/2 + 100);
                        ctx.rotate(cube.rotation);
                        ctx.scale(cube.scale, cube.scale);
                        
                        ctx.fillStyle = `rgba(136, 136, 136, ${cube.opacity})`;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        
                        ctx.fillRect(-40, -40, 80, 80);
                        ctx.strokeRect(-40, -40, 80, 80);
                        
                        ctx.beginPath();
                        ctx.moveTo(-40, -40);
                        ctx.lineTo(-20, -60);
                        ctx.lineTo(60, -60);
                        ctx.lineTo(40, -40);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(40, -40);
                        ctx.lineTo(60, -60);
                        ctx.lineTo(60, 20);
                        ctx.lineTo(40, 40);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.restore();
                        
                        // Draw name property
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '14px monospace';
                        ctx.fillText(`name: ${properties.name.value}`, canvas.width/2 - 60, canvas.height/2 + 180);
                        
                        cube.rotation += 0.02;
                        
                        if (properties.name.visible) {
                            requestAnimationFrame(animateProperty);
                        }
                    };
                    animateProperty();
                }
            })
            .to(properties.type, {
                visible: true,
                duration: 0.5,
                onStart: () => {
                    // Animate type property appearing
                    const animateProperty = () => {
                        if (!properties.type.visible) return;
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Redraw cube
                        ctx.save();
                        ctx.translate(canvas.width/2, canvas.height/2 + 100);
                        ctx.rotate(cube.rotation);
                        ctx.scale(cube.scale, cube.scale);
                        
                        ctx.fillStyle = `rgba(136, 136, 136, ${cube.opacity})`;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        
                        ctx.fillRect(-40, -40, 80, 80);
                        ctx.strokeRect(-40, -40, 80, 80);
                        
                        ctx.beginPath();
                        ctx.moveTo(-40, -40);
                        ctx.lineTo(-20, -60);
                        ctx.lineTo(60, -60);
                        ctx.lineTo(40, -40);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(40, -40);
                        ctx.lineTo(60, -60);
                        ctx.lineTo(60, 20);
                        ctx.lineTo(40, 40);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.restore();
                        
                        // Draw properties
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '14px monospace';
                        ctx.fillText(`name: ${properties.name.value}`, canvas.width/2 - 60, canvas.height/2 + 180);
                        ctx.fillText(`type: ${properties.type.value}`, canvas.width/2 - 60, canvas.height/2 + 200);
                        
                        cube.rotation += 0.02;
                        
                        if (properties.type.visible) {
                            requestAnimationFrame(animateProperty);
                        }
                    };
                    animateProperty();
                }
            })
            
            // Memory allocation visualization
            .to(memoryBar, {
                filled: 40,
                duration: 1,
                onUpdate: function() {
                    // Continue drawing the scene
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw cube
                    ctx.save();
                    ctx.translate(canvas.width/2, canvas.height/2 + 100);
                    ctx.rotate(cube.rotation);
                    ctx.scale(cube.scale, cube.scale);
                    
                    ctx.fillStyle = `rgba(136, 136, 136, ${cube.opacity})`;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    
                    ctx.fillRect(-40, -40, 80, 80);
                    ctx.strokeRect(-40, -40, 80, 80);
                    
                    ctx.beginPath();
                    ctx.moveTo(-40, -40);
                    ctx.lineTo(-20, -60);
                    ctx.lineTo(60, -60);
                    ctx.lineTo(40, -40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(40, -40);
                    ctx.lineTo(60, -60);
                    ctx.lineTo(60, 20);
                    ctx.lineTo(40, 40);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Draw properties
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px monospace';
                    ctx.fillText(`name: ${properties.name.value}`, canvas.width/2 - 60, canvas.height/2 + 180);
                    ctx.fillText(`type: ${properties.type.value}`, canvas.width/2 - 60, canvas.height/2 + 200);
                    
                    // Draw memory bar
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 + 100, canvas.height/2 - 50, 40, 200);
                    
                    // Memory fill
                    const fillHeight = (memoryBar.filled / memoryBar.maxMemory) * 200;
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(canvas.width/2 + 102, canvas.height/2 + 50 - fillHeight, 36, fillHeight);
                    
                    // Memory label
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px monospace';
                    ctx.fillText('Memory', canvas.width/2 + 95, canvas.height/2 - 60);
                    ctx.fillText(`${memoryBar.filled}%`, canvas.width/2 + 105, canvas.height/2 + 60);
                    
                    cube.rotation += 0.02;
                }
            });

            return timeline;
        }

        // Scene 4: "Fill in my data parameters INITIALIZATION" / "输入我的参数 数据初始化"
        function scene4() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const functionCode = "function initialize(data) {}";
            let displayedFunctionCode = "";
            const dataFlow = {
                progress: 0
            };
            const nameVar = {
                opacity: 0
            };
            const typeIcons = {
                opacity: 0,
                stringIcon: { x: 0 },
                numberIcon: { x: 0 },
                booleanIcon: { x: 0 }
            };
            const dataParticles = [];
            
            // Initialize data particles
            for (let i = 0; i < 20; i++) {
                dataParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    radius: Math.random() * 3 + 1,
                    opacity: 0
                });
            }

            timeline.to({ index: 0 }, {
                index: functionCode.length,
                duration: 1,
                ease: "none",
                onUpdate: function() {
                    displayedFunctionCode = functionCode.substring(0, Math.round(this.targets()[0].index));
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw code editor background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 50, 400, 100);
                    
                    // Draw code text
                    ctx.font = '18px monospace';
                    ctx.fillStyle = '#cccccc';
                    const funcCodeWidth = ctx.measureText(displayedFunctionCode).width;
                    ctx.fillText(displayedFunctionCode, canvas.width/2 - 190, canvas.height/2);
                    
                    // Draw blinking cursor
                    if (Math.floor(this.progress() * 20) % 2 === 0) {
                        const textWidth = ctx.measureText(displayedFunctionCode).width;
                        ctx.fillRect(canvas.width/2 - 190 + textWidth + 2, canvas.height/2 - 15, 2, 20);
                    }
                }
            })
            .to(dataFlow, {
                progress: 1,
                duration: 1,
                ease: "power1.inOut",
                onUpdate: function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw code editor
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 50, 400, 100);
                    ctx.font = '18px monospace';
                    ctx.fillStyle = '#cccccc';
                    ctx.fillText(functionCode, canvas.width/2 - 190, canvas.height/2);
                    
                    // Draw data flow visualization
                    const flowX = canvas.width/2 - 190 + dataFlow.progress * 300;
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 190, canvas.height/2 + 20);
                    ctx.lineTo(flowX, canvas.height/2 + 20);
                    ctx.stroke();
                    
                    // Draw data particles
                    dataParticles.forEach(particle => {
                        if (particle.opacity > 0) {
                            ctx.fillStyle = `rgba(170, 170, 170, ${particle.opacity})`;
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                },
                onStart: () => {
                    // Animate data particles
                    const animateParticles = () => {
                        if (dataFlow.progress < 1) return;
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw code editor
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 50, 400, 100);
                        ctx.font = '18px monospace';
                        ctx.fillStyle = '#cccccc';
                        ctx.fillText(functionCode, canvas.width/2 - 190, canvas.height/2);
                        
                        // Draw data flow visualization
                        ctx.strokeStyle = '#888888';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(canvas.width/2 - 190, canvas.height/2 + 20);
                        ctx.lineTo(canvas.width/2 + 110, canvas.height/2 + 20);
                        ctx.stroke();
                        
                        // Update and draw particles
                        dataParticles.forEach(particle => {
                            particle.x += particle.vx;
                            particle.y += particle.vy;
                            
                            // Boundary check
                            if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
                            if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;
                            
                            // Attract to data flow
                            const dx = canvas.width/2 + 110 - particle.x;
                            const dy = canvas.height/2 + 20 - particle.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < 100) {
                                particle.vx += dx / dist * 0.5;
                                particle.vy += dy / dist * 0.5;
                                particle.opacity = Math.min(1, particle.opacity + 0.05);
                            }
                            
                            ctx.fillStyle = `rgba(170, 170, 170, ${particle.opacity})`;
                            ctx.beginPath();
                            ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        if (dataFlow.progress >= 1) {
                            requestAnimationFrame(animateParticles);
                        }
                    };
                    animateParticles();
                }
            })
            .to(nameVar, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Continue drawing the scene
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw code editor
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 50, 400, 100);
                    ctx.font = '18px monospace';
                    ctx.fillStyle = '#cccccc';
                    ctx.fillText(functionCode, canvas.width/2 - 190, canvas.height/2);
                    
                    // Draw data flow
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 190, canvas.height/2 + 20);
                    ctx.lineTo(canvas.width/2 + 110, canvas.height/2 + 20);
                    ctx.stroke();
                    
                    // Draw data particles
                    dataParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(170, 170, 170, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw variable declaration
                    ctx.font = '16px monospace';
                    ctx.fillStyle = `rgba(255, 255, 255, ${nameVar.opacity})`;
                    const nameVarText = 'let name = "world"';
                    const nameVarWidth = ctx.measureText(nameVarText).width;
                    ctx.fillText(nameVarText, canvas.width/2 - nameVarWidth/2, canvas.height/2 + 60);
                }
            }, "-=0.5")
            .to(typeIcons.stringIcon, {
                x: 1,
                duration: 0.2,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    // Draw string icon
                    const iconX = canvas.width/2 - 60;
                    const iconY = canvas.height/2 + 90;
                    
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px monospace';
                    ctx.fillText('"string"', iconX, iconY);
                    
                    // Draw string icon visual
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(iconX - 5, iconY - 20, 80, 25);
                    
                    // Draw string content
                    ctx.fillStyle = '#cccccc';
                    ctx.font = '14px monospace';
                    ctx.fillText('"world"', iconX + 5, iconY - 5);
                }
            }, "-=0.2")
            .to(typeIcons.numberIcon, {
                x: 1,
                duration: 0.2,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    // Draw number icon
                    const iconX = canvas.width/2 + 40;
                    const iconY = canvas.height/2 + 90;
                    
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px monospace';
                    ctx.fillText('number', iconX, iconY);
                    
                    // Draw number icon visual
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(iconX + 35, iconY - 10, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw number content
                    ctx.fillStyle = '#cccccc';
                    ctx.font = '14px monospace';
                    ctx.fillText('42', iconX + 28, iconY - 5);
                }
            }, "-=0.1")
            .to(typeIcons.booleanIcon, {
                x: 1,
                duration: 0.2,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    // Draw boolean icon
                    const iconX = canvas.width/2 + 120;
                    const iconY = canvas.height/2 + 90;
                    
                    ctx.fillStyle = '#888888';
                    ctx.font = '16px monospace';
                    ctx.fillText('boolean', iconX, iconY);
                    
                    // Draw boolean icon visual
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(iconX + 5, iconY - 20, 50, 25);
                    
                    // Draw boolean content
                    ctx.fillStyle = '#cccccc';
                    ctx.font = '14px monospace';
                    ctx.fillText('true', iconX + 15, iconY - 5);
                }
            }, "-=0.1");

            return timeline;
        }

        // Scene 5: "Set up our new world And let's begin the SIMULATION" / "设定好我们的新世界 开始吧 模拟程序"
        function scene5() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const worldGrid = {
                scale: 0
            };
            const paramsOpacity = {
                opacity: 0
            };
            const simulationText = {
                opacity: 0
            };
            
            // 3D particles for physics simulation
            const particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: Math.random() * 200 - 100,
                    y: Math.random() * 200 - 100,
                    z: Math.random() * 200 - 100,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    vz: (Math.random() - 0.5) * 2,
                    size: Math.random() * 3 + 1
                });
            }
            const particleOpacity = {
                opacity: 0
            };

            timeline.to(worldGrid, {
                scale: 1,
                duration: 1.5,
                ease: "power1.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // Black background

                    // Draw 3D grid with perspective
                    ctx.strokeStyle = `rgba(136, 136, 136, ${worldGrid.scale})`; // #888
                    ctx.lineWidth = 1;
                    
                    const gridSize = 200;
                    const numLines = 10;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const perspective = 0.7;
                    
                    // Horizontal lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const y = centerY - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor * worldGrid.scale, y);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor * worldGrid.scale, y);
                        ctx.stroke();
                    }
                    
                    // Vertical lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const x = centerX - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, centerY - gridSize / 2 * perspectiveFactor * worldGrid.scale);
                        ctx.lineTo(x, centerY + gridSize / 2 * perspectiveFactor * worldGrid.scale);
                        ctx.stroke();
                    }
                    
                    // Diagonal lines for depth
                    ctx.strokeStyle = `rgba(102, 102, 102, ${worldGrid.scale * 0.5})`; // #666
                    for (let i = 1; i < numLines; i++) {
                        const offset = (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - i / numLines * 0.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor * worldGrid.scale, centerY - gridSize / 2 * perspectiveFactor * worldGrid.scale);
                        ctx.lineTo(centerX - gridSize / 2 * perspectiveFactor * worldGrid.scale + offset * worldGrid.scale, centerY - gridSize / 2 * perspectiveFactor * worldGrid.scale + offset * worldGrid.scale);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX + gridSize / 2 * perspectiveFactor * worldGrid.scale, centerY - gridSize / 2 * perspectiveFactor * worldGrid.scale);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor * worldGrid.scale - offset * worldGrid.scale, centerY - gridSize / 2 * perspectiveFactor * worldGrid.scale + offset * worldGrid.scale);
                        ctx.stroke();
                    }
                }
            })
            .to(paramsOpacity, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Redraw grid (static)
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw grid with full opacity
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    
                    const gridSize = 200;
                    const numLines = 10;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const perspective = 0.7;
                    
                    // Horizontal lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const y = centerY - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, y);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor, y);
                        ctx.stroke();
                    }
                    
                    // Vertical lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const x = centerX - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(x, centerY + gridSize / 2 * perspectiveFactor);
                        ctx.stroke();
                    }
                    
                    // Diagonal lines for depth
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.5)'; // #666
                    for (let i = 1; i < numLines; i++) {
                        const offset = (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - i / numLines * 0.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX - gridSize / 2 * perspectiveFactor + offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX + gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor - offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                    }

                    // Display physical parameters with enhanced styling
                    ctx.font = 'bold 20px monospace';
                    ctx.fillStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity})`; // #cccccc
                    const gText = 'g = 9.8';
                    const dtText = 'dt = 0.01';
                    const gWidth = ctx.measureText(gText).width;
                    const dtWidth = ctx.measureText(dtText).width;
                    
                    // Draw parameter boxes
                    ctx.strokeStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(centerX - gWidth/2 - 10, centerY - 80, gWidth + 20, 30);
                    ctx.strokeRect(centerX - dtWidth/2 - 10, centerY - 40, dtWidth + 20, 30);
                    
                    ctx.fillText(gText, centerX - gWidth / 2, centerY - 60);
                    ctx.fillText(dtText, centerX - dtWidth / 2, centerY - 20);

                    // Enhanced 3D coordinate system with arrows and labels
                    const axisLength = 100;
                    
                    // X-axis (deep grey)
                    ctx.strokeStyle = '#666'; // #666
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength, centerY);
                    ctx.lineTo(centerX + axisLength, centerY);
                    ctx.stroke();
                    
                    // X-axis arrow
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY - 5);
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY + 5);
                    ctx.stroke();
                    
                    // X-axis label
                    ctx.fillStyle = '#cccccc';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('X', centerX + axisLength + 15, centerY + 5);
                    
                    // Y-axis (medium grey)
                    ctx.strokeStyle = '#999'; // #999
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX, centerY + axisLength);
                    ctx.stroke();
                    
                    // Y-axis arrow
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX - 5, centerY - axisLength + 10);
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX + 5, centerY - axisLength + 10);
                    ctx.stroke();
                    
                    // Y-axis label
                    ctx.fillStyle = '#cccccc';
                    ctx.fillText('Y', centerX + 10, centerY - axisLength - 5);
                    
                    // Z-axis (light grey, diagonal for 3D effect)
                    ctx.strokeStyle = '#CCC'; // #CCC
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength * 0.7, centerY + axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Z-axis arrow
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 7, centerY - axisLength * 0.7 + 7);
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 3, centerY - axisLength * 0.7 - 3);
                    ctx.stroke();
                    
                    // Z-axis label
                    ctx.fillStyle = '#cccccc';
                    ctx.fillText('Z', centerX + axisLength * 0.7 + 10, centerY - axisLength * 0.7);
                }
            }, "-=0.5")
            .to(particleOpacity, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Redraw previous elements
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw grid
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    
                    const gridSize = 200;
                    const numLines = 10;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const perspective = 0.7;
                    
                    // Horizontal lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const y = centerY - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, y);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor, y);
                        ctx.stroke();
                    }
                    
                    // Vertical lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const x = centerX - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(x, centerY + gridSize / 2 * perspectiveFactor);
                        ctx.stroke();
                    }
                    
                    // Diagonal lines for depth
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.5)'; // #666
                    for (let i = 1; i < numLines; i++) {
                        const offset = (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - i / numLines * 0.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX - gridSize / 2 * perspectiveFactor + offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX + gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor - offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                    }
                    
                    // Redraw parameters
                    ctx.font = 'bold 20px monospace';
                    ctx.fillStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity})`;
                    const gText = 'g = 9.8';
                    const dtText = 'dt = 0.01';
                    const gWidth = ctx.measureText(gText).width;
                    const dtWidth = ctx.measureText(dtText).width;
                    
                    ctx.strokeStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity * 0.5})`;
                    ctx.strokeRect(centerX - gWidth/2 - 10, centerY - 80, gWidth + 20, 30);
                    ctx.strokeRect(centerX - dtWidth/2 - 10, centerY - 40, dtWidth + 20, 30);
                    
                    ctx.fillText(gText, centerX - gWidth / 2, centerY - 60);
                    ctx.fillText(dtText, centerX - dtWidth / 2, centerY - 20);
                    
                    // Redraw axes
                    const axisLength = 100;
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength, centerY);
                    ctx.lineTo(centerX + axisLength, centerY);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY - 5);
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY + 5);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#cccccc';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('X', centerX + axisLength + 15, centerY + 5);
                    
                    ctx.strokeStyle = '#999';
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX, centerY + axisLength);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX - 5, centerY - axisLength + 10);
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX + 5, centerY - axisLength + 10);
                    ctx.stroke();
                    
                    ctx.fillText('Y', centerX + 10, centerY - axisLength - 5);
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength * 0.7, centerY + axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 7, centerY - axisLength * 0.7 + 7);
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 3, centerY - axisLength * 0.7 - 3);
                    ctx.stroke();
                    
                    ctx.fillText('Z', centerX + axisLength * 0.7 + 10, centerY - axisLength * 0.7);
                    
                    // Draw 3D particles with physics simulation
                    ctx.fillStyle = `rgba(255, 255, 255, ${particleOpacity.opacity})`;
                    
                    particles.forEach(particle => {
                        // Update particle position
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.z += particle.vz;
                        
                        // Apply gravity
                        particle.vy -= 0.1;
                        
                        // Bounce off boundaries
                        if (Math.abs(particle.x) > 100) particle.vx *= -0.8;
                        if (Math.abs(particle.y) > 100) particle.vy *= -0.8;
                        if (Math.abs(particle.z) > 100) particle.vz *= -0.8;
                        
                        // 3D to 2D projection with perspective
                        const perspective = 300 / (300 + particle.z);
                        const projectedX = centerX + particle.x * perspective;
                        const projectedY = centerY - particle.y * perspective;
                        const projectedSize = particle.size * perspective;
                        
                        // Draw particle with depth-based opacity
                        const depthOpacity = 0.3 + 0.7 * perspective;
                        ctx.fillStyle = `rgba(255, 255, 255, ${particleOpacity.opacity * depthOpacity})`;
                        ctx.beginPath();
                        ctx.arc(projectedX, projectedY, projectedSize, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }, "-=0.5")
            .to(simulationText, {
                opacity: 1,
                duration: 0.5,
                onUpdate: function() {
                    // Redraw previous elements
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw grid
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    
                    const gridSize = 200;
                    const numLines = 10;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const perspective = 0.7;
                    
                    // Horizontal lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const y = centerY - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, y);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor, y);
                        ctx.stroke();
                    }
                    
                    // Vertical lines with perspective
                    for (let i = 0; i <= numLines; i++) {
                        const x = centerX - gridSize / 2 + (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - Math.abs(i - numLines/2) / numLines * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(x, centerY + gridSize / 2 * perspectiveFactor);
                        ctx.stroke();
                    }
                    
                    // Diagonal lines for depth
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.5)'; // #666
                    for (let i = 1; i < numLines; i++) {
                        const offset = (gridSize / numLines) * i;
                        const perspectiveFactor = 1 - i / numLines * 0.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX - gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX - gridSize / 2 * perspectiveFactor + offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX + gridSize / 2 * perspectiveFactor, centerY - gridSize / 2 * perspectiveFactor);
                        ctx.lineTo(centerX + gridSize / 2 * perspectiveFactor - offset, centerY - gridSize / 2 * perspectiveFactor + offset);
                        ctx.stroke();
                    }
                    
                    // Redraw parameters
                    ctx.font = 'bold 20px monospace';
                    ctx.fillStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity})`;
                    const gText = 'g = 9.8';
                    const dtText = 'dt = 0.01';
                    const gWidth = ctx.measureText(gText).width;
                    const dtWidth = ctx.measureText(dtText).width;
                    
                    ctx.strokeStyle = `rgba(204, 204, 204, ${paramsOpacity.opacity * 0.5})`;
                    ctx.strokeRect(centerX - gWidth/2 - 10, centerY - 80, gWidth + 20, 30);
                    ctx.strokeRect(centerX - dtWidth/2 - 10, centerY - 40, dtWidth + 20, 30);
                    
                    ctx.fillText(gText, centerX - gWidth / 2, centerY - 60);
                    ctx.fillText(dtText, centerX - dtWidth / 2, centerY - 20);
                    
                    // Redraw axes
                    const axisLength = 100;
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength, centerY);
                    ctx.lineTo(centerX + axisLength, centerY);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY - 5);
                    ctx.moveTo(centerX + axisLength, centerY);
                    ctx.lineTo(centerX + axisLength - 10, centerY + 5);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#cccccc';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('X', centerX + axisLength + 15, centerY + 5);
                    
                    ctx.strokeStyle = '#999';
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX, centerY + axisLength);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX - 5, centerY - axisLength + 10);
                    ctx.moveTo(centerX, centerY - axisLength);
                    ctx.lineTo(centerX + 5, centerY - axisLength + 10);
                    ctx.stroke();
                    
                    ctx.fillText('Y', centerX + 10, centerY - axisLength - 5);
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(centerX - axisLength * 0.7, centerY + axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 7, centerY - axisLength * 0.7 + 7);
                    ctx.moveTo(centerX + axisLength * 0.7, centerY - axisLength * 0.7);
                    ctx.lineTo(centerX + axisLength * 0.7 - 3, centerY - axisLength * 0.7 - 3);
                    ctx.stroke();
                    
                    ctx.fillText('Z', centerX + axisLength * 0.7 + 10, centerY - axisLength * 0.7);
                    
                    // Update and draw particles
                    particles.forEach(particle => {
                        // Update particle position
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.z += particle.vz;
                        
                        // Apply gravity
                        particle.vy -= 0.1;
                        
                        // Bounce off boundaries
                        if (Math.abs(particle.x) > 100) particle.vx *= -0.8;
                        if (Math.abs(particle.y) > 100) particle.vy *= -0.8;
                        if (Math.abs(particle.z) > 100) particle.vz *= -0.8;
                        
                        // 3D to 2D projection with perspective
                        const perspective = 300 / (300 + particle.z);
                        const projectedX = centerX + particle.x * perspective;
                        const projectedY = centerY - particle.y * perspective;
                        const projectedSize = particle.size * perspective;
                        
                        // Draw particle with depth-based opacity
                        const depthOpacity = 0.3 + 0.7 * perspective;
                        ctx.fillStyle = `rgba(255, 255, 255, ${particleOpacity.opacity * depthOpacity})`;
                        ctx.beginPath();
                        ctx.arc(projectedX, projectedY, projectedSize, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Enhanced "SIMULATION START" text with styling
                    if (Math.floor(this.progress() * 10) % 2 === 0) {
                        ctx.font = 'bold 36px monospace';
                        ctx.fillStyle = `rgba(255, 255, 255, ${simulationText.opacity})`;
                        const simText = 'SIMULATION START';
                        const simTextWidth = ctx.measureText(simText).width;
                        
                        // Draw text background box
                        ctx.strokeStyle = `rgba(204, 204, 204, ${simulationText.opacity * 0.5})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(centerX - simTextWidth/2 - 15, centerY + 100 - 25, simTextWidth + 30, 50);
                        
                        // Draw text
                        ctx.fillText(simText, centerX - simTextWidth / 2, centerY + 100);
                    }
                }
            });

            return timeline;
        }

        // Scene 6: "world.execute(me);" / "世界执行我"
        function scene6() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const codeLine = "world.execute(me);";
            const executePointer = {
                x: 0,
                glow: 0
            };
            const callStack = {
                height: 0,
                functions: []
            };
            const returnValue = {
                progress: 0,
                value: "undefined"
            };
            const errorWarning = {
                opacity: 0,
                message: "Access Denied"
            };
            const memoryLeak = {
                size: 0,
                opacity: 0
            };
            
            // Initialize call stack functions
            for (let i = 0; i < 5; i++) {
                callStack.functions.push({
                    name: `func${String.fromCharCode(65 + i)}`,
                    active: false,
                    params: Math.floor(Math.random() * 10)
                });
            }

            timeline.to(executePointer, {
                x: 1,
                glow: 1,
                duration: 0.8,
                ease: "power2.inOut",
                onUpdate: function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // Black background

                    // Draw terminal window
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    
                    // Draw terminal header
                    ctx.fillStyle = '#333';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 30);
                    
                    // Terminal buttons
                    ctx.fillStyle = '#ff5f56';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 280, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffbd2e';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 260, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#27c93f';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 240, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw code with syntax highlighting
                    ctx.font = '24px monospace';
                    
                    // "world" in blue
                    ctx.fillStyle = '#6495ED';
                    const worldText = "world";
                    const worldWidth = ctx.measureText(worldText).width;
                    ctx.fillText(worldText, canvas.width / 2 - worldWidth / 2 - 50, canvas.height / 2);
                    
                    // "." in white
                    ctx.fillStyle = '#FFF';
                    const dotText = ".";
                    const dotWidth = ctx.measureText(dotText).width;
                    ctx.fillText(dotText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth, canvas.height / 2);
                    
                    // "execute" in green
                    ctx.fillStyle = '#50FA7B';
                    const executeText = "execute";
                    const executeWidth = ctx.measureText(executeText).width;
                    ctx.fillText(executeText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth, canvas.height / 2);
                    
                    // "(me);" in yellow
                    ctx.fillStyle = '#F1FA8C';
                    const paramsText = "(me);";
                    ctx.fillText(paramsText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth + executeWidth, canvas.height / 2);

                    // Draw execution pointer with glow effect
                    if (executePointer.x > 0) {
                        const totalWidth = ctx.measureText(codeLine).width;
                        const worldDotWidth = ctx.measureText("world.").width;
                        
                        // Glow effect
                        const gradient = ctx.createRadialGradient(
                            canvas.width / 2 - totalWidth / 2 + worldDotWidth + 5, 
                            canvas.height / 2 - 5, 
                            0,
                            canvas.width / 2 - totalWidth / 2 + worldDotWidth + 5, 
                            canvas.height / 2 - 5, 
                            20 * executePointer.glow
                        );
                        gradient.addColorStop(0, `rgba(255, 255, 255, ${executePointer.glow})`);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(
                            canvas.width / 2 - totalWidth / 2 + worldDotWidth - 10, 
                            canvas.height / 2 - 30, 
                            30, 
                            40
                        );
                        
                        // Pointer
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(
                            canvas.width / 2 - totalWidth / 2 + worldDotWidth, 
                            canvas.height / 2 - 20, 
                            10, 
                            30
                        );
                    }
                }
            })
            .to(callStack, {
                height: 1,
                duration: 1.5,
                ease: "power2.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw terminal window
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    
                    // Draw terminal header
                    ctx.fillStyle = '#333';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 30);
                    
                    // Terminal buttons
                    ctx.fillStyle = '#ff5f56';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 280, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffbd2e';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 260, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#27c93f';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 240, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Redraw code with syntax highlighting
                    ctx.font = '24px monospace';
                    
                    // "world" in blue
                    ctx.fillStyle = '#6495ED';
                    const worldText = "world";
                    const worldWidth = ctx.measureText(worldText).width;
                    ctx.fillText(worldText, canvas.width / 2 - worldWidth / 2 - 50, canvas.height / 2);
                    
                    // "." in white
                    ctx.fillStyle = '#FFF';
                    const dotText = ".";
                    const dotWidth = ctx.measureText(dotText).width;
                    ctx.fillText(dotText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth, canvas.height / 2);
                    
                    // "execute" in green
                    ctx.fillStyle = '#50FA7B';
                    const executeText = "execute";
                    const executeWidth = ctx.measureText(executeText).width;
                    ctx.fillText(executeText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth, canvas.height / 2);
                    
                    // "(me);" in yellow
                    ctx.fillStyle = '#F1FA8C';
                    const paramsText = "(me);";
                    ctx.fillText(paramsText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth + executeWidth, canvas.height / 2);

                    // Draw execution pointer
                    const totalWidth = ctx.measureText(codeLine).width;
                    const worldDotWidth = ctx.measureText("world.").width;
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(
                        canvas.width / 2 - totalWidth / 2 + worldDotWidth, 
                        canvas.height / 2 - 20, 
                        10, 
                        30
                    );

                    // Draw call stack with enhanced visualization
                    const stackWidth = 200;
                    const stackHeight = callStack.height * 150;
                    const stackX = canvas.width / 2 - stackWidth / 2;
                    const stackY = canvas.height / 2 + 80 - stackHeight;
                    
                    // Stack background
                    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
                    ctx.fillRect(stackX, stackY, stackWidth, stackHeight);
                    
                    // Stack border
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(stackX, stackY, stackWidth, stackHeight);
                    
                    // Stack header
                    ctx.fillStyle = '#444';
                    ctx.fillRect(stackX, stackY, stackWidth, 25);
                    
                    ctx.fillStyle = '#AAA';
                    ctx.font = '14px monospace';
                    ctx.fillText('CALL STACK', stackX + 10, stackY + 17);
                    
                    // Draw functions in stack
                    const visibleFunctions = Math.floor(callStack.height * 5);
                    for (let i = 0; i < visibleFunctions; i++) {
                        const funcY = stackY + 30 + i * 25;
                        const func = callStack.functions[i];
                        
                        // Function background
                        if (i === visibleFunctions - 1) {
                            // Active function
                            ctx.fillStyle = 'rgba(100, 149, 237, 0.2)';
                            ctx.fillRect(stackX + 5, funcY - 2, stackWidth - 10, 22);
                        }
                        
                        // Function text
                        ctx.fillStyle = i === visibleFunctions - 1 ? '#6495ED' : '#CCC';
                        ctx.font = '12px monospace';
                        ctx.fillText(
                            `${func.name}(${func.params})`, 
                            stackX + 10, 
                            funcY + 10
                        );
                        
                        // Memory address
                        ctx.fillStyle = '#666';
                        ctx.font = '10px monospace';
                        ctx.fillText(
                            `0x${(1000 + i * 100).toString(16)}`, 
                            stackX + stackWidth - 50, 
                            funcY + 10
                        );
                    }
                }
            })
            .to(returnValue, {
                progress: 1,
                value: "null",
                duration: 0.8,
                ease: "power2.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw terminal window
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    
                    // Draw terminal header
                    ctx.fillStyle = '#333';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 30);
                    
                    // Terminal buttons
                    ctx.fillStyle = '#ff5f56';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 280, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffbd2e';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 260, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#27c93f';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2 - 240, canvas.height/2 - 135, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Redraw code with syntax highlighting
                    ctx.font = '24px monospace';
                    
                    // "world" in blue
                    ctx.fillStyle = '#6495ED';
                    const worldText = "world";
                    const worldWidth = ctx.measureText(worldText).width;
                    ctx.fillText(worldText, canvas.width / 2 - worldWidth / 2 - 50, canvas.height / 2);
                    
                    // "." in white
                    ctx.fillStyle = '#FFF';
                    const dotText = ".";
                    const dotWidth = ctx.measureText(dotText).width;
                    ctx.fillText(dotText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth, canvas.height / 2);
                    
                    // "execute" in green
                    ctx.fillStyle = '#50FA7B';
                    const executeText = "execute";
                    const executeWidth = ctx.measureText(executeText).width;
                    ctx.fillText(executeText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth, canvas.height / 2);
                    
                    // "(me);" in yellow
                    ctx.fillStyle = '#F1FA8C';
                    const paramsText = "(me);";
                    ctx.fillText(paramsText, canvas.width / 2 - worldWidth / 2 - 50 + worldWidth + dotWidth + executeWidth, canvas.height / 2);

                    // Draw execution pointer
                    const totalWidth = ctx.measureText(codeLine).width;
                    const worldDotWidth = ctx.measureText("world.").width;
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(
                        canvas.width / 2 - totalWidth / 2 + worldDotWidth, 
                        canvas.height / 2 - 20, 
                        10, 
                        30
                    );

                    // Draw call stack
                    const stackWidth = 200;
                    const stackHeight = 150;
                    const stackX = canvas.width / 2 - stackWidth / 2;
                    const stackY = canvas.height / 2 + 80 - stackHeight;
                    
                    // Stack background
                    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
                    ctx.fillRect(stackX, stackY, stackWidth, stackHeight);
                    
                    // Stack border
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(stackX, stackY, stackWidth, stackHeight);
                    
                    // Stack header
                    ctx.fillStyle = '#444';
                    ctx.fillRect(stackX, stackY, stackWidth, 25);
                    
                    ctx.fillStyle = '#AAA';
                    ctx.font = '14px monospace';
                    ctx.fillText('CALL STACK', stackX + 10, stackY + 17);
                    
                    // Draw functions in stack
                    for (let i = 0; i < 5; i++) {
                        const funcY = stackY + 30 + i * 25;
                        const func = callStack.functions[i];
                        
                        // Function text
                        ctx.fillStyle = '#CCC';
                        ctx.font = '12px monospace';
                        ctx.fillText(
                            `${func.name}(${func.params})`, 
                            stackX + 10, 
                            funcY + 10
                        );
                        
                        // Memory address
                        ctx.fillStyle = '#666';
                        ctx.font = '10px monospace';
                        ctx.fillText(
                            `0x${(1000 + i * 100).toString(16)}`, 
                            stackX + stackWidth - 50, 
                            funcY + 10
                        );
                    }

                    // Draw return arrow with enhanced styling
                    ctx.strokeStyle = '#50FA7B';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const arrowStartX = canvas.width / 2;
                    const arrowStartY = canvas.height / 2 + 80;
                    const arrowEndX = arrowStartX - 150 * returnValue.progress;
                    const arrowEndY = arrowStartY;
                    
                    ctx.moveTo(arrowStartX, arrowStartY);
                    ctx.lineTo(arrowEndX, arrowEndY);
                    
                    // Arrow head
                    if (returnValue.progress > 0.2) {
                        ctx.lineTo(arrowEndX + 10, arrowEndY - 5);
                        ctx.moveTo(arrowEndX, arrowEndY);
                        ctx.lineTo(arrowEndX + 10, arrowEndY + 5);
                    }
                    ctx.stroke();
                    
                    // Return value box
                    if (returnValue.progress > 0.5) {
                        const boxOpacity = (returnValue.progress - 0.5) * 2;
                        ctx.fillStyle = `rgba(40, 40, 40, ${boxOpacity})`;
                        ctx.fillRect(arrowEndX - 40, arrowEndY - 40, 80, 30);
                        
                        ctx.strokeStyle = `rgba(80, 250, 123, ${boxOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(arrowEndX - 40, arrowEndY - 40, 80, 30);
                        
                        ctx.fillStyle = `rgba(241, 250, 140, ${boxOpacity})`;
                        ctx.font = '12px monospace';
                        ctx.fillText(returnValue.value, arrowEndX - 20, arrowEndY - 20);
                    }
                }
            }, "-=0.5")
            .to(memoryLeak, {
                size: 1,
                opacity: 0.7,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw all previous elements (simplified)
                    // Terminal window
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    
                    // Code
                    ctx.font = '24px monospace';
                    ctx.fillStyle = '#FFF';
                    const codeLineWidth = ctx.measureText(codeLine).width;
                    ctx.fillText(codeLine, canvas.width / 2 - codeLineWidth / 2, canvas.height / 2);
                    
                    // Memory leak visualization
                    const leakX = canvas.width / 2 + 200;
                    const leakY = canvas.height / 2;
                    const leakSize = 50 * memoryLeak.size;
                    
                    // Memory blocks
                    for (let i = 0; i < 5; i++) {
                        const blockX = leakX + (Math.random() - 0.5) * leakSize;
                        const blockY = leakY + (Math.random() - 0.5) * leakSize;
                        const blockSize = 10 + Math.random() * 20;
                        
                        ctx.fillStyle = `rgba(255, 95, 86, ${memoryLeak.opacity * (0.5 + Math.random() * 0.5)})`;
                        ctx.fillRect(blockX, blockY, blockSize, blockSize);
                    }
                    
                    // Memory usage graph
                    ctx.strokeStyle = `rgba(255, 95, 86, ${memoryLeak.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(leakX - 50, leakY + 50);
                    
                    for (let i = 0; i < 10; i++) {
                        const x = leakX - 50 + i * 10;
                        const y = leakY + 50 - (Math.random() * 30 * memoryLeak.size);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Memory usage text
                    ctx.fillStyle = `rgba(255, 255, 255, ${memoryLeak.opacity})`;
                    ctx.font = '14px monospace';
                    ctx.fillText('Memory Leak', leakX - 40, leakY - 60);
                    ctx.fillText(`${Math.floor(memoryLeak.size * 100)}%`, leakX - 20, leakY + 70);
                }
            })
            .to(errorWarning, {
                opacity: 1,
                duration: 0.5,
                repeat: 3,
                yoyo: true,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw all previous elements (simplified)
                    // Terminal window
                    ctx.fillStyle = '#111';
                    ctx.fillRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width/2 - 300, canvas.height/2 - 150, 600, 300);
                    
                    // Code
                    ctx.font = '24px monospace';
                    ctx.fillStyle = '#FFF';
                    const codeLineWidth = ctx.measureText(codeLine).width;
                    ctx.fillText(codeLine, canvas.width / 2 - codeLineWidth / 2, canvas.height / 2);
                    
                    // Draw warning box with enhanced styling
                    if (errorWarning.opacity > 0) {
                        const warningX = canvas.width / 2;
                        const warningY = canvas.height / 2 - 150;
                        const warningWidth = 200;
                        const warningHeight = 60;
                        
                        // Warning box background
                        ctx.fillStyle = `rgba(255, 95, 86, ${errorWarning.opacity * 0.2})`;
                        ctx.fillRect(warningX - warningWidth/2, warningY - warningHeight/2, warningWidth, warningHeight);
                        
                        // Warning box border
                        ctx.strokeStyle = `rgba(255, 95, 86, ${errorWarning.opacity})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(warningX - warningWidth/2, warningY - warningHeight/2, warningWidth, warningHeight);
                        
                        // Warning icon
                        ctx.fillStyle = `rgba(255, 95, 86, ${errorWarning.opacity})`;
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText('⚠', warningX - warningWidth/2 + 15, warningY + 5);
                        
                        // Warning text
                        ctx.fillStyle = `rgba(255, 255, 255, ${errorWarning.opacity})`;
                        ctx.font = 'bold 16px Arial';
                        const warningText = errorWarning.message;
                        const warningTextWidth = ctx.measureText(warningText).width;
                        ctx.fillText(warningText, warningX - warningTextWidth / 2, warningY + 5);
                        
                        // Error code
                        ctx.font = '12px monospace';
                        ctx.fillStyle = `rgba(204, 204, 204, ${errorWarning.opacity * 0.7})`;
                        ctx.fillText('ERR_ACCESS_DENIED: 0x80070005', warningX - 80, warningY + 25);
                    }
                }
            }, "-=0.5");

            return timeline;
        }

        // Scene 7: "If I'm a set of points Then I will give you my DIMENSION" / "如果我是一组点 那么我将献给你 我的次元"
        function scene7() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            // Add glow effect properties
            const glow = {
                intensity: 0,
                pulseSize: 0
            };

            const points = [];
            for (let i = 0; i < 150; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    z: Math.random() * 100 - 50, // Add z-axis for 3D effect
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    vz: (Math.random() - 0.5) * 0.5,
                    connections: []
                });
            }
            
            // Pre-calculate some connections for better visual effect
            for (let i = 0; i < points.length; i++) {
                const numConnections = Math.floor(Math.random() * 3) + 1;
                for (let j = 0; j < numConnections; j++) {
                    const targetIndex = Math.floor(Math.random() * points.length);
                    if (targetIndex !== i) {
                        points[i].connections.push(targetIndex);
                    }
                }
            }
            
            const connectionProgress = {
                value: 0
            };
            const dimensionProgress = {
                value: 0
            };
            const rotation = {
                x: 0,
                y: 0,
                z: 0
            };
            const formulaDisplay = {
                opacity: 0,
                text: ""
            };

            // Create radial gradient background
            function drawBackground() {
                const bgGradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                bgGradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            timeline.to({}, {
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBackground();
                    
                    // Draw scattered points with depth effect and glow
                    points.forEach(p => {
                        // Simple 3D to 2D projection
                        const scale = 100 / (100 + p.z);
                        const projX = canvas.width / 2 + (p.x - canvas.width / 2) * scale;
                        const projY = canvas.height / 2 + (p.y - canvas.height / 2) * scale;
                        
                        // Size based on depth
                        const size = 1 + scale * 2;
                        
                        // Opacity based on depth
                        const opacity = 0.3 + scale * 0.7;
                        
                        // Create gradient for points
                        const pointGradient = ctx.createRadialGradient(
                            projX, projY, 0,
                            projX, projY, size * 2
                        );
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        ctx.fillStyle = pointGradient;
                        ctx.beginPath();
                        ctx.arc(projX, projY, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    });
                }
            })
            .to(connectionProgress, {
                value: 1,
                duration: 2.5,
                ease: "power2.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBackground();

                    // Draw points with movement and glow
                    points.forEach(p => {
                        // Update position
                        p.x += p.vx;
                        p.y += p.vy;
                        p.z += p.vz;
                        
                        // Boundary check
                        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                        if (p.z < -50 || p.z > 50) p.vz *= -1;
                        
                        // Simple 3D to 2D projection
                        const scale = 100 / (100 + p.z);
                        const projX = canvas.width / 2 + (p.x - canvas.width / 2) * scale;
                        const projY = canvas.height / 2 + (p.y - canvas.height / 2) * scale;
                        
                        // Size based on depth
                        const size = 1 + scale * 2;
                        
                        // Opacity based on depth
                        const opacity = 0.3 + scale * 0.7;
                        
                        // Create gradient for points
                        const pointGradient = ctx.createRadialGradient(
                            projX, projY, 0,
                            projX, projY, size * 2
                        );
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        ctx.fillStyle = pointGradient;
                        ctx.beginPath();
                        ctx.arc(projX, projY, size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    });

                    // Draw connecting lines with distance-based opacity and gradient
                    ctx.lineWidth = 1;
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const scale1 = 100 / (100 + p1.z);
                        const projX1 = canvas.width / 2 + (p1.x - canvas.width / 2) * scale1;
                        const projY1 = canvas.height / 2 + (p1.y - canvas.height / 2) * scale1;
                        
                        // Connect to pre-calculated connections
                        const connectionsToShow = Math.floor(p1.connections.length * connectionProgress.value);
                        for (let j = 0; j < connectionsToShow; j++) {
                            const targetIndex = p1.connections[j];
                            const p2 = points[targetIndex];
                            const scale2 = 100 / (100 + p2.z);
                            const projX2 = canvas.width / 2 + (p2.x - canvas.width / 2) * scale2;
                            const projY2 = canvas.height / 2 + (p2.y - canvas.height / 2) * scale2;
                            
                            // Calculate distance for opacity
                            const distance = Math.sqrt(
                                Math.pow(projX2 - projX1, 2) + 
                                Math.pow(projY2 - projY1, 2)
                            );
                            const maxDistance = 200;
                            const lineOpacity = Math.max(0, 1 - distance / maxDistance) * 0.5 * connectionProgress.value;
                            
                            // Create gradient for connection lines
                            const lineGradient = ctx.createLinearGradient(projX1, projY1, projX2, projY2);
                            lineGradient.addColorStop(0, `rgba(200, 200, 255, ${lineOpacity})`);
                            lineGradient.addColorStop(0.5, `rgba(255, 255, 255, ${lineOpacity * 1.2})`);
                            lineGradient.addColorStop(1, `rgba(200, 200, 255, ${lineOpacity})`);
                            
                            // Add glow effect to lines
                            ctx.shadowBlur = 3 + glow.intensity * 5;
                            ctx.shadowColor = 'rgba(200, 200, 255, 0.6)';
                            
                            // Draw connection line
                            ctx.strokeStyle = lineGradient;
                            ctx.beginPath();
                            ctx.moveTo(projX1, projY1);
                            ctx.lineTo(projX2, projY2);
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // Display formula text with glow
                    if (connectionProgress.value > 0.5) {
                        const textOpacity = (connectionProgress.value - 0.5) * 2;
                        
                        // Add glow effect to text
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
                        ctx.font = '16px monospace';
                        ctx.fillText('P = {p₁, p₂, ..., pₙ}', 20, 30);
                        ctx.fillText('E = {(pᵢ, pⱼ) | i, j ∈ [1, n]}', 20, 50);
                        
                        ctx.shadowBlur = 0;
                    }
                }
            })
            .to(glow, {
                intensity: 1,
                pulseSize: 2,
                duration: 1,
                ease: "power1.inOut"
            })
            .to(rotation, {
                x: Math.PI * 2,
                y: Math.PI * 2,
                duration: 3,
                ease: "power1.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBackground();

                    // Apply rotation transformation
                    const cosX = Math.cos(rotation.x);
                    const sinX = Math.sin(rotation.x);
                    const cosY = Math.cos(rotation.y);
                    const sinY = Math.sin(rotation.y);
                    
                    // Draw rotated points with glow
                    points.forEach(p => {
                        // 3D rotation
                        let x = p.x - canvas.width / 2;
                        let y = p.y - canvas.height / 2;
                        let z = p.z;
                        
                        // Rotate around X axis
                        let tempY = y * cosX - z * sinX;
                        z = y * sinX + z * cosX;
                        y = tempY;
                        
                        // Rotate around Y axis
                        let tempX = x * cosY + z * sinY;
                        z = -x * sinY + z * cosY;
                        x = tempX;
                        
                        // Simple 3D to 2D projection
                        const scale = 100 / (100 + z);
                        const projX = canvas.width / 2 + x * scale;
                        const projY = canvas.height / 2 + y * scale;
                        
                        // Size based on depth
                        const size = 1 + scale * 2;
                        
                        // Opacity based on depth
                        const opacity = 0.3 + scale * 0.7;
                        
                        // Create gradient for points
                        const radius = Math.max(0.1, size * 2 + glow.pulseSize);
                        const pointGradient = ctx.createRadialGradient(
                            projX, projY, 0,
                            projX, projY, radius
                        );
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        // Add glow effect
                        ctx.shadowBlur = 10 + glow.intensity * 20;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                        
                        ctx.fillStyle = pointGradient;
                        ctx.beginPath();
                        ctx.arc(projX, projY, size + glow.pulseSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    });

                    // Draw connecting lines with gradient and glow
                    ctx.lineWidth = 1;
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        
                        // Apply same rotation to p1
                        let x1 = p1.x - canvas.width / 2;
                        let y1 = p1.y - canvas.height / 2;
                        let z1 = p1.z;
                        
                        let tempY1 = y1 * cosX - z1 * sinX;
                        z1 = y1 * sinX + z1 * cosX;
                        y1 = tempY1;
                        
                        let tempX1 = x1 * cosY + z1 * sinY;
                        z1 = -x1 * sinY + z1 * cosY;
                        x1 = tempX1;
                        
                        const scale1 = 100 / (100 + z1);
                        const projX1 = canvas.width / 2 + x1 * scale1;
                        const projY1 = canvas.height / 2 + y1 * scale1;
                        
                        // Connect to pre-calculated connections
                        p1.connections.forEach(targetIndex => {
                            const p2 = points[targetIndex];
                            
                            // Apply same rotation to p2
                            let x2 = p2.x - canvas.width / 2;
                            let y2 = p2.y - canvas.height / 2;
                            let z2 = p2.z;
                            
                            let tempY2 = y2 * cosX - z2 * sinX;
                            z2 = y2 * sinX + z2 * cosX;
                            y2 = tempY2;
                            
                            let tempX2 = x2 * cosY + z2 * sinY;
                            z2 = -x2 * sinY + z2 * cosY;
                            x2 = tempX2;
                            
                            const scale2 = 100 / (100 + z2);
                            const projX2 = canvas.width / 2 + x2 * scale2;
                            const projY2 = canvas.height / 2 + y2 * scale2;
                            
                            // Calculate distance for opacity
                            const distance = Math.sqrt(
                                Math.pow(projX2 - projX1, 2) + 
                                Math.pow(projY2 - projY1, 2)
                            );
                            const maxDistance = 200;
                            const lineOpacity = Math.max(0, 1 - distance / maxDistance) * 0.5;
                            
                            // Create gradient for connection lines
                            const lineGradient = ctx.createLinearGradient(projX1, projY1, projX2, projY2);
                            lineGradient.addColorStop(0, `rgba(200, 200, 255, ${lineOpacity})`);
                            lineGradient.addColorStop(0.5, `rgba(255, 255, 255, ${lineOpacity * 1.2})`);
                            lineGradient.addColorStop(1, `rgba(200, 200, 255, ${lineOpacity})`);
                            
                            // Add glow effect to lines
                            ctx.shadowBlur = 5 + glow.intensity * 10;
                            ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                            
                            // Draw connection line
                            ctx.strokeStyle = lineGradient;
                            ctx.beginPath();
                            ctx.moveTo(projX1, projY1);
                            ctx.lineTo(projX2, projY2);
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                        });
                    }
                    
                    // Display formula text with glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = '16px monospace';
                    ctx.fillText('P = {p₁, p₂, ..., pₙ}', 20, 30);
                    ctx.fillText('E = {(pᵢ, pⱼ) | i, j ∈ [1, n]}', 20, 50);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(dimensionProgress, {
                value: 1,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBackground();

                    // Draw dimension progression with enhanced visuals
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // 0D - Point with glow
                    if (dimensionProgress.value > 0) {
                        const opacity = Math.min(1, dimensionProgress.value * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        // Create gradient for point
                        const pointRadius = Math.max(0.1, 5 + glow.pulseSize);
                        const pointGradient = ctx.createRadialGradient(
                            centerX - 150, centerY - 100, 0,
                            centerX - 150, centerY - 100, pointRadius
                        );
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        ctx.fillStyle = pointGradient;
                        ctx.beginPath();
                        ctx.arc(centerX - 150, centerY - 100, 5 + glow.pulseSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.font = '14px monospace';
                        ctx.fillText('0D: Point', centerX - 180, centerY - 70);
                    }
                    
                    // 1D - Line with gradient and glow
                    if (dimensionProgress.value > 0.2) {
                        const opacity = Math.min(1, (dimensionProgress.value - 0.2) * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        // Create gradient for line
                        const lineGradient = ctx.createLinearGradient(
                            centerX - 100, centerY - 100,
                            centerX - 20, centerY - 100
                        );
                        lineGradient.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        lineGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        lineGradient.addColorStop(1, `rgba(200, 200, 255, ${opacity})`);
                        
                        ctx.strokeStyle = lineGradient;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - 100, centerY - 100);
                        ctx.lineTo(centerX - 20, centerY - 100);
                        ctx.stroke();
                        
                        // Draw points on line with gradient
                        const pointRadius1 = Math.max(0.1, 3 + glow.pulseSize);
                        const pointGradient = ctx.createRadialGradient(
                            centerX - 100, centerY - 100, 0,
                            centerX - 100, centerY - 100, pointRadius1
                        );
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        ctx.fillStyle = pointGradient;
                        ctx.beginPath();
                        ctx.arc(centerX - 100, centerY - 100, 3 + glow.pulseSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const pointRadius2 = Math.max(0.1, 3 + glow.pulseSize);
                        const pointGradient2 = ctx.createRadialGradient(
                            centerX - 20, centerY - 100, 0,
                            centerX - 20, centerY - 100, pointRadius2
                        );
                        pointGradient2.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                        pointGradient2.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        pointGradient2.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                        
                        ctx.fillStyle = pointGradient2;
                        ctx.beginPath();
                        ctx.arc(centerX - 20, centerY - 100, 3 + glow.pulseSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.font = '14px monospace';
                        ctx.fillText('1D: Line', centerX - 100, centerY - 70);
                    }
                    
                    // 2D - Square with gradient and glow
                    if (dimensionProgress.value > 0.4) {
                        const opacity = Math.min(1, (dimensionProgress.value - 0.4) * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        // Create gradient for square
                        const squareGradient = ctx.createLinearGradient(
                            centerX + 20, centerY - 120,
                            centerX + 100, centerY - 40
                        );
                        squareGradient.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        squareGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        squareGradient.addColorStop(1, `rgba(200, 200, 255, ${opacity})`);
                        
                        ctx.strokeStyle = squareGradient;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(centerX + 20, centerY - 120, 80, 80);
                        
                        // Draw points at vertices with gradient
                        const vertices = [
                            [centerX + 20, centerY - 120],
                            [centerX + 100, centerY - 120],
                            [centerX + 100, centerY - 40],
                            [centerX + 20, centerY - 40]
                        ];
                        vertices.forEach(v => {
                            const vertexRadius = Math.max(0.1, 3 + glow.pulseSize);
                            const vertexGradient = ctx.createRadialGradient(
                                v[0], v[1], 0,
                                v[0], v[1], vertexRadius
                            );
                            vertexGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                            vertexGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                            vertexGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.3})`);
                            
                            ctx.fillStyle = vertexGradient;
                            ctx.beginPath();
                            ctx.arc(v[0], v[1], vertexRadius, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        // Draw grid inside square with gradient
                        const gridGradient = ctx.createLinearGradient(
                            centerX + 20, centerY - 120,
                            centerX + 100, centerY - 40
                        );
                        gridGradient.addColorStop(0, `rgba(150, 150, 200, ${opacity * 0.5})`);
                        gridGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.5})`);
                        gridGradient.addColorStop(1, `rgba(150, 150, 200, ${opacity * 0.5})`);
                        
                        ctx.strokeStyle = gridGradient;
                        ctx.lineWidth = 1;
                        for (let i = 1; i < 4; i++) {
                            // Vertical lines
                            ctx.beginPath();
                            ctx.moveTo(centerX + 20 + i * 20, centerY - 120);
                            ctx.lineTo(centerX + 20 + i * 20, centerY - 40);
                            ctx.stroke();
                            
                            // Horizontal lines
                            ctx.beginPath();
                            ctx.moveTo(centerX + 20, centerY - 120 + i * 20);
                            ctx.lineTo(centerX + 100, centerY - 120 + i * 20);
                            ctx.stroke();
                        }
                        
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.font = '14px monospace';
                        ctx.fillText('2D: Square', centerX + 30, centerY - 10);
                    }
                    
                    // 3D - Cube with gradient and glow
                    if (dimensionProgress.value > 0.6) {
                        const opacity = Math.min(1, (dimensionProgress.value - 0.6) * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        // Calculate cube vertices
                        const cubeSize = 60;
                        const cubeX = centerX - 120;
                        const cubeY = centerY + 20;
                        const depth = 30;
                        
                        // Create gradient for front face
                        const frontGradient = ctx.createLinearGradient(
                            cubeX, cubeY,
                            cubeX + cubeSize, cubeY + cubeSize
                        );
                        frontGradient.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        frontGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        frontGradient.addColorStop(1, `rgba(200, 200, 255, ${opacity})`);
                        
                        // Front face with gradient
                        ctx.strokeStyle = frontGradient;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(cubeX, cubeY, cubeSize, cubeSize);
                        
                        // Create gradient for back face
                        const backGradient = ctx.createLinearGradient(
                            cubeX + depth, cubeY - depth,
                            cubeX + cubeSize + depth, cubeY + cubeSize - depth
                        );
                        backGradient.addColorStop(0, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        backGradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        backGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        
                        // Back face with gradient
                        ctx.strokeStyle = backGradient;
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(cubeX + depth, cubeY - depth, cubeSize, cubeSize);
                        
                        // Create gradient for connecting lines
                        const connectGradient = ctx.createLinearGradient(
                            cubeX, cubeY,
                            cubeX + depth, cubeY - depth
                        );
                        connectGradient.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        connectGradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        connectGradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        
                        // Connecting lines with gradient
                        ctx.strokeStyle = connectGradient;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(cubeX, cubeY);
                        ctx.lineTo(cubeX + depth, cubeY - depth);
                        ctx.moveTo(cubeX + cubeSize, cubeY);
                        ctx.lineTo(cubeX + cubeSize + depth, cubeY - depth);
                        ctx.moveTo(cubeX, cubeY + cubeSize);
                        ctx.lineTo(cubeX + depth, cubeY + cubeSize - depth);
                        ctx.moveTo(cubeX + cubeSize, cubeY + cubeSize);
                        ctx.lineTo(cubeX + cubeSize + depth, cubeY + cubeSize - depth);
                        ctx.stroke();
                        
                        // Draw vertices with gradient
                        const cubeVertices = [
                            [cubeX, cubeY],
                            [cubeX + cubeSize, cubeY],
                            [cubeX + cubeSize, cubeY + cubeSize],
                            [cubeX, cubeY + cubeSize],
                            [cubeX + depth, cubeY - depth],
                            [cubeX + cubeSize + depth, cubeY - depth],
                            [cubeX + cubeSize + depth, cubeY + cubeSize - depth],
                            [cubeX + depth, cubeY + cubeSize - depth]
                        ];
                        
                        cubeVertices.forEach((v, i) => {
                            // Different opacity for front vs back vertices
                            const vertexOpacity = i < 4 ? opacity : opacity * 0.8;
                            
                            const cubeVertexRadius = Math.max(0.1, 3 + glow.pulseSize);
                            const vertexGradient = ctx.createRadialGradient(
                                v[0], v[1], 0,
                                v[0], v[1], cubeVertexRadius
                            );
                            vertexGradient.addColorStop(0, `rgba(255, 255, 255, ${vertexOpacity})`);
                            vertexGradient.addColorStop(0.5, `rgba(200, 200, 255, ${vertexOpacity * 0.8})`);
                            vertexGradient.addColorStop(1, `rgba(150, 150, 255, ${vertexOpacity * 0.3})`);
                            
                            ctx.fillStyle = vertexGradient;
                            ctx.beginPath();
                            ctx.arc(v[0], v[1], cubeVertexRadius, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.font = '14px monospace';
                        ctx.fillText('3D: Cube', cubeX, cubeY + cubeSize + 30);
                    }
                    
                    // 4D - Tesseract (hypercube) representation with gradient and glow
                    if (dimensionProgress.value > 0.8) {
                        const opacity = Math.min(1, (dimensionProgress.value - 0.8) * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        // Calculate tesseract vertices (simplified 2D projection)
                        const tesseractSize = 50;
                        const tesseractX = centerX + 60;
                        const tesseractY = centerY + 40;
                        const depth = 25;
                        const hyperDepth = 15;
                        
                        // Create gradient for first cube
                        const cube1Gradient = ctx.createLinearGradient(
                            tesseractX, tesseractY,
                            tesseractX + tesseractSize, tesseractY + tesseractSize
                        );
                        cube1Gradient.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        cube1Gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        cube1Gradient.addColorStop(1, `rgba(200, 200, 255, ${opacity})`);
                        
                        // First cube with gradient
                        ctx.strokeStyle = cube1Gradient;
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(tesseractX, tesseractY, tesseractSize, tesseractSize);
                        
                        // Create gradient for second cube
                        const cube2Gradient = ctx.createLinearGradient(
                            tesseractX + depth, tesseractY - depth,
                            tesseractX + tesseractSize + depth, tesseractY + tesseractSize - depth
                        );
                        cube2Gradient.addColorStop(0, `rgba(150, 150, 255, ${opacity * 0.9})`);
                        cube2Gradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.9})`);
                        cube2Gradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.9})`);
                        
                        // Second cube (shifted) with gradient
                        ctx.strokeStyle = cube2Gradient;
                        ctx.lineWidth = 1.2;
                        ctx.strokeRect(tesseractX + depth, tesseractY - depth, tesseractSize, tesseractSize);
                        
                        // Create gradient for third cube
                        const cube3Gradient = ctx.createLinearGradient(
                            tesseractX + hyperDepth, tesseractY + hyperDepth,
                            tesseractX + tesseractSize + hyperDepth, tesseractY + tesseractSize + hyperDepth
                        );
                        cube3Gradient.addColorStop(0, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        cube3Gradient.addColorStop(0.5, `rgba(200, 200, 255, ${opacity * 0.8})`);
                        cube3Gradient.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        
                        // Third cube (hyper shift) with gradient
                        ctx.strokeStyle = cube3Gradient;
                        ctx.lineWidth = 1.2;
                        ctx.strokeRect(tesseractX + hyperDepth, tesseractY + hyperDepth, tesseractSize, tesseractSize);
                        
                        // Create gradient for fourth cube
                        const cube4Gradient = ctx.createLinearGradient(
                            tesseractX + depth + hyperDepth, tesseractY - depth + hyperDepth,
                            tesseractX + tesseractSize + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth
                        );
                        cube4Gradient.addColorStop(0, `rgba(100, 100, 255, ${opacity * 0.7})`);
                        cube4Gradient.addColorStop(0.5, `rgba(150, 150, 255, ${opacity * 0.7})`);
                        cube4Gradient.addColorStop(1, `rgba(100, 100, 255, ${opacity * 0.7})`);
                        
                        // Fourth cube (combined shift) with gradient
                        ctx.strokeStyle = cube4Gradient;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(tesseractX + depth + hyperDepth, tesseractY - depth + hyperDepth, tesseractSize, tesseractSize);
                        
                        // Create gradient for connecting lines
                        const connectGradient1 = ctx.createLinearGradient(
                            tesseractX, tesseractY,
                            tesseractX + depth, tesseractY - depth
                        );
                        connectGradient1.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        connectGradient1.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        connectGradient1.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.9})`);
                        
                        // Create gradient for hyper connecting lines
                        const connectGradient2 = ctx.createLinearGradient(
                            tesseractX, tesseractY,
                            tesseractX + hyperDepth, tesseractY + hyperDepth
                        );
                        connectGradient2.addColorStop(0, `rgba(200, 200, 255, ${opacity})`);
                        connectGradient2.addColorStop(0.5, `rgba(255, 255, 255, ${opacity})`);
                        connectGradient2.addColorStop(1, `rgba(150, 150, 255, ${opacity * 0.8})`);
                        
                        // Connecting lines between cubes with gradients
                        ctx.beginPath();
                        
                        // Connect first to second
                        ctx.strokeStyle = connectGradient1;
                        ctx.moveTo(tesseractX, tesseractY);
                        ctx.lineTo(tesseractX + depth, tesseractY - depth);
                        ctx.moveTo(tesseractX + tesseractSize, tesseractY);
                        ctx.lineTo(tesseractX + tesseractSize + depth, tesseractY - depth);
                        ctx.moveTo(tesseractX, tesseractY + tesseractSize);
                        ctx.lineTo(tesseractX + depth, tesseractY + tesseractSize - depth);
                        ctx.moveTo(tesseractX + tesseractSize, tesseractY + tesseractSize);
                        ctx.lineTo(tesseractX + tesseractSize + depth, tesseractY + tesseractSize - depth);
                        
                        // Connect first to third
                        ctx.strokeStyle = connectGradient2;
                        ctx.moveTo(tesseractX, tesseractY);
                        ctx.lineTo(tesseractX + hyperDepth, tesseractY + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize, tesseractY);
                        ctx.lineTo(tesseractX + tesseractSize + hyperDepth, tesseractY + hyperDepth);
                        ctx.moveTo(tesseractX, tesseractY + tesseractSize);
                        ctx.lineTo(tesseractX + hyperDepth, tesseractY + tesseractSize + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize, tesseractY + tesseractSize);
                        ctx.lineTo(tesseractX + tesseractSize + hyperDepth, tesseractY + tesseractSize + hyperDepth);
                        
                        // Connect second to fourth
                        ctx.strokeStyle = connectGradient2;
                        ctx.moveTo(tesseractX + depth, tesseractY - depth);
                        ctx.lineTo(tesseractX + depth + hyperDepth, tesseractY - depth + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize + depth, tesseractY - depth);
                        ctx.lineTo(tesseractX + tesseractSize + depth + hyperDepth, tesseractY - depth + hyperDepth);
                        ctx.moveTo(tesseractX + depth, tesseractY + tesseractSize - depth);
                        ctx.lineTo(tesseractX + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize + depth, tesseractY + tesseractSize - depth);
                        ctx.lineTo(tesseractX + tesseractSize + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth);
                        
                        // Connect third to fourth
                        ctx.strokeStyle = connectGradient1;
                        ctx.moveTo(tesseractX + hyperDepth, tesseractY + hyperDepth);
                        ctx.lineTo(tesseractX + depth + hyperDepth, tesseractY - depth + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize + hyperDepth, tesseractY + hyperDepth);
                        ctx.lineTo(tesseractX + tesseractSize + depth + hyperDepth, tesseractY - depth + hyperDepth);
                        ctx.moveTo(tesseractX + hyperDepth, tesseractY + tesseractSize + hyperDepth);
                        ctx.lineTo(tesseractX + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth);
                        ctx.moveTo(tesseractX + tesseractSize + hyperDepth, tesseractY + tesseractSize + hyperDepth);
                        ctx.lineTo(tesseractX + tesseractSize + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth);
                        ctx.stroke();
                        
                        // Draw vertices with gradient
                        const tesseractVertices = [
                            // First cube vertices
                            [tesseractX, tesseractY],
                            [tesseractX + tesseractSize, tesseractY],
                            [tesseractX + tesseractSize, tesseractY + tesseractSize],
                            [tesseractX, tesseractY + tesseractSize],
                            // Second cube vertices
                            [tesseractX + depth, tesseractY - depth],
                            [tesseractX + tesseractSize + depth, tesseractY - depth],
                            [tesseractX + tesseractSize + depth, tesseractY + tesseractSize - depth],
                            [tesseractX + depth, tesseractY + tesseractSize - depth],
                            // Third cube vertices
                            [tesseractX + hyperDepth, tesseractY + hyperDepth],
                            [tesseractX + tesseractSize + hyperDepth, tesseractY + hyperDepth],
                            [tesseractX + tesseractSize + hyperDepth, tesseractY + tesseractSize + hyperDepth],
                            [tesseractX + hyperDepth, tesseractY + tesseractSize + hyperDepth],
                            // Fourth cube vertices
                            [tesseractX + depth + hyperDepth, tesseractY - depth + hyperDepth],
                            [tesseractX + tesseractSize + depth + hyperDepth, tesseractY - depth + hyperDepth],
                            [tesseractX + tesseractSize + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth],
                            [tesseractX + depth + hyperDepth, tesseractY + tesseractSize - depth + hyperDepth]
                        ];
                        
                        tesseractVertices.forEach((v, i) => {
                            // Different opacity for different cubes
                            let vertexOpacity = opacity;
                            if (i >= 4 && i < 8) vertexOpacity = opacity * 0.9; // Second cube
                            else if (i >= 8 && i < 12) vertexOpacity = opacity * 0.8; // Third cube
                            else if (i >= 12) vertexOpacity = opacity * 0.7; // Fourth cube
                            
                            const tesseractVertexRadius = Math.max(0.1, 2 + glow.pulseSize);
                            const vertexGradient = ctx.createRadialGradient(
                                v[0], v[1], 0,
                                v[0], v[1], tesseractVertexRadius
                            );
                            vertexGradient.addColorStop(0, `rgba(255, 255, 255, ${vertexOpacity})`);
                            vertexGradient.addColorStop(0.5, `rgba(200, 200, 255, ${vertexOpacity * 0.8})`);
                            vertexGradient.addColorStop(1, `rgba(150, 150, 255, ${vertexOpacity * 0.3})`);
                            
                            ctx.fillStyle = vertexGradient;
                            ctx.beginPath();
                            ctx.arc(v[0], v[1], tesseractVertexRadius, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                        ctx.font = '14px monospace';
                        ctx.fillText('4D: Tesseract', tesseractX, tesseractY + tesseractSize + 40);
                    }
                    
                    // Display dimension formula with glow
                    if (dimensionProgress.value > 0.5) {
                        const opacity = Math.min(1, (dimensionProgress.value - 0.5) * 2);
                        
                        // Add glow effect
                        ctx.shadowBlur = 5 + glow.intensity * 10;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.font = '16px monospace';
                        ctx.fillText('Dimension: D = {x ∈ ℝⁿ | n ∈ ℕ}', 20, canvas.height - 50);
                        
                        // Display current dimension
                        const currentDim = Math.min(4, Math.floor(dimensionProgress.value * 5));
                        ctx.fillText(`Current Dimension: ${currentDim}D`, 20, canvas.height - 30);
                        
                        ctx.shadowBlur = 0;
                    }
                }
            });

            return timeline;
        }

        // Scene 8: "If I'm a circle Then I will give you my CIRCUMFERENCE" / "如果我是一个圆 那么我将献给你 我的圆周"
        function scene8() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            // Add glow effect properties
            const glow = {
                intensity: 0,
                pulseSize: 0
            };

            // Function to draw gradient background
            function drawBackground() {
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const circle = {
                radius: 0,
                segments: 0
            };
            const circumferenceText = {
                opacity: 0
            };
            const radiusScan = {
                angle: 0
            };
            const unrolledCircle = {
                progress: 0,
                length: 0
            };
            const piDigits = {
                display: ""
            };
            const highlightSegment = {
                start: 0,
                end: 0
            };

            // Generate Pi digits
            const piDigitsString = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679";
            let digitIndex = 0;

            // Animate glow properties
            timeline.to(glow, {
                intensity: 1,
                pulseSize: 2,
                duration: 1
            }, 0);

            timeline.to(circle, {
                radius: 120,
                duration: 1.5,
                ease: "power1.out",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw circle with segments and glow
                    const numSegments = Math.floor(circle.segments);
                    
                    // Add glow effect to circle
                    ctx.shadowBlur = 5 + glow.intensity * 10;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    
                    // Create gradient for circle
                    const circleGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, circle.radius
                    );
                    circleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    circleGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    circleGradient.addColorStop(1, 'rgba(100, 100, 200, 0.5)');
                    
                    ctx.strokeStyle = circleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, circle.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw segment lines with gradient
                    if (numSegments > 0) {
                        ctx.shadowBlur = 3 + glow.intensity * 5;
                        
                        for (let i = 0; i < numSegments; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            
                            // Create gradient for segment lines
                            const segmentGradient = ctx.createLinearGradient(
                                canvas.width / 2, canvas.height / 2,
                                canvas.width / 2 + circle.radius * Math.cos(angle),
                                canvas.height / 2 + circle.radius * Math.sin(angle)
                            );
                            segmentGradient.addColorStop(0, 'rgba(100, 100, 200, 0.3)');
                            segmentGradient.addColorStop(1, 'rgba(170, 170, 255, 0.8)');
                            
                            ctx.strokeStyle = segmentGradient;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(canvas.width / 2, canvas.height / 2);
                            ctx.lineTo(
                                canvas.width / 2 + circle.radius * Math.cos(angle),
                                canvas.height / 2 + circle.radius * Math.sin(angle)
                            );
                            ctx.stroke();
                        }
                    }
                    
                    // Highlight a segment with glow
                    if (highlightSegment.start > 0 && highlightSegment.end > 0) {
                        ctx.shadowBlur = 8 + glow.intensity * 15;
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                        
                        const segmentGradient = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, 0,
                            canvas.width / 2, canvas.height / 2, circle.radius
                        );
                        segmentGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                        segmentGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.3)');
                        segmentGradient.addColorStop(1, 'rgba(150, 150, 255, 0.2)');
                        
                        ctx.fillStyle = segmentGradient;
                        ctx.beginPath();
                        ctx.arc(
                            canvas.width / 2, 
                            canvas.height / 2, 
                            circle.radius, 
                            highlightSegment.start, 
                            highlightSegment.end
                        );
                        ctx.lineTo(canvas.width / 2, canvas.height / 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(circle.segments, {
                value: 12,
                duration: 1,
                ease: "power1.out",
                onUpdate: function() {
                    // This will be called in the previous onUpdate
                }
            }, "-=1")
            .to(highlightSegment, {
                start: 0,
                end: Math.PI / 6, // 30 degrees = 1/12 of circle
                duration: 0.5,
                ease: "power1.inOut",
                onUpdate: function() {
                    // This will be called in the previous onUpdate
                }
            }, "-=0.5")
            .to(circumferenceText, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw circle with segments and glow
                    ctx.shadowBlur = 5 + glow.intensity * 10;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    
                    // Create gradient for circle
                    const circleGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, circle.radius
                    );
                    circleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    circleGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    circleGradient.addColorStop(1, 'rgba(100, 100, 200, 0.5)');
                    
                    ctx.strokeStyle = circleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, circle.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw segment lines with gradient
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        
                        // Create gradient for segment lines
                        const segmentGradient = ctx.createLinearGradient(
                            canvas.width / 2, canvas.height / 2,
                            canvas.width / 2 + circle.radius * Math.cos(angle),
                            canvas.height / 2 + circle.radius * Math.sin(angle)
                        );
                        segmentGradient.addColorStop(0, 'rgba(100, 100, 200, 0.3)');
                        segmentGradient.addColorStop(1, 'rgba(170, 170, 255, 0.8)');
                        
                        ctx.strokeStyle = segmentGradient;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(canvas.width / 2, canvas.height / 2);
                        ctx.lineTo(
                            canvas.width / 2 + circle.radius * Math.cos(angle),
                            canvas.height / 2 + circle.radius * Math.sin(angle)
                        );
                        ctx.stroke();
                    }
                    
                    // Highlight a segment with glow
                    ctx.shadowBlur = 8 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    
                    const segmentGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, circle.radius
                    );
                    segmentGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    segmentGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.3)');
                    segmentGradient.addColorStop(1, 'rgba(150, 150, 255, 0.2)');
                    
                    ctx.fillStyle = segmentGradient;
                    ctx.beginPath();
                    ctx.arc(
                        canvas.width / 2, 
                        canvas.height / 2, 
                        circle.radius, 
                        0, 
                        Math.PI / 6
                    );
                    ctx.lineTo(canvas.width / 2, canvas.height / 2);
                    ctx.fill();

                    // Display Pi symbol and formula with glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    ctx.font = '36px Arial';
                    ctx.fillStyle = `rgba(102, 102, 102, ${circumferenceText.opacity})`; // #666
                    const piText = 'π';
                    const piTextWidth = ctx.measureText(piText).width;
                    ctx.fillText(piText, canvas.width / 2 - piTextWidth / 2, canvas.height / 2 - 60); // Centered
                    
                    ctx.font = '20px Arial';
                    ctx.fillStyle = `rgba(170, 170, 170, ${circumferenceText.opacity})`; // #AAA
                    const piValueText = '3.1415926535...';
                    const piValueWidth = ctx.measureText(piValueText).width;
                    ctx.fillText(piValueText, canvas.width / 2 - piValueWidth / 2, canvas.height / 2 - 30); // Centered

                    // Display formula (white text) with glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${circumferenceText.opacity})`;
                    ctx.font = '24px monospace';
                    const formulaText = 'C = 2πr';
                    const formulaWidth = ctx.measureText(formulaText).width;
                    ctx.fillText(formulaText, canvas.width / 2 - formulaWidth / 2, canvas.height / 2 + circle.radius + 40); // Centered
                    
                    // Display segment angle with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    ctx.font = '16px monospace';
                    ctx.fillStyle = `rgba(255, 255, 255, ${circumferenceText.opacity})`;
                    const angleText = 'θ = 30° = π/6 rad';
                    const angleWidth = ctx.measureText(angleText).width;
                    ctx.fillText(angleText, canvas.width / 2 - angleWidth / 2, canvas.height / 2 + 20); // Centered
                    
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(radiusScan, {
                angle: Math.PI * 2,
                duration: 2,
                ease: "power1.inOut",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw circle with segments and glow
                    ctx.shadowBlur = 5 + glow.intensity * 10;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    
                    // Create gradient for circle
                    const circleGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, circle.radius
                    );
                    circleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    circleGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    circleGradient.addColorStop(1, 'rgba(100, 100, 200, 0.5)');
                    
                    ctx.strokeStyle = circleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, circle.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw segment lines with gradient
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        
                        // Create gradient for segment lines
                        const segmentGradient = ctx.createLinearGradient(
                            canvas.width / 2, canvas.height / 2,
                            canvas.width / 2 + circle.radius * Math.cos(angle),
                            canvas.height / 2 + circle.radius * Math.sin(angle)
                        );
                        segmentGradient.addColorStop(0, 'rgba(100, 100, 200, 0.3)');
                        segmentGradient.addColorStop(1, 'rgba(170, 170, 255, 0.8)');
                        
                        ctx.strokeStyle = segmentGradient;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(canvas.width / 2, canvas.height / 2);
                        ctx.lineTo(
                            canvas.width / 2 + circle.radius * Math.cos(angle),
                            canvas.height / 2 + circle.radius * Math.sin(angle)
                        );
                        ctx.stroke();
                    }

                    // Draw scanning radius with enhanced gradient and glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    
                    const gradient = ctx.createLinearGradient(
                        canvas.width / 2, canvas.height / 2,
                        canvas.width / 2 + circle.radius * Math.cos(radiusScan.angle),
                        canvas.height / 2 + circle.radius * Math.sin(radiusScan.angle)
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(150, 150, 255, 0.6)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2);
                    ctx.lineTo(
                        canvas.width / 2 + circle.radius * Math.cos(radiusScan.angle),
                        canvas.height / 2 + circle.radius * Math.sin(radiusScan.angle)
                    );
                    ctx.stroke();
                    
                    // Draw point at end of radius with glow
                    ctx.shadowBlur = 15 + glow.intensity * 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    
                    const pointGradient = ctx.createRadialGradient(
                        canvas.width / 2 + circle.radius * Math.cos(radiusScan.angle),
                        canvas.height / 2 + circle.radius * Math.sin(radiusScan.angle),
                        0,
                        canvas.width / 2 + circle.radius * Math.cos(radiusScan.angle),
                        canvas.height / 2 + circle.radius * Math.sin(radiusScan.angle),
                        8
                    );
                    pointGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    pointGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    pointGradient.addColorStop(1, 'rgba(150, 150, 255, 0.4)');
                    
                    ctx.fillStyle = pointGradient;
                    ctx.beginPath();
                    ctx.arc(
                        canvas.width / 2 + circle.radius * Math.cos(radiusScan.angle),
                        canvas.height / 2 + circle.radius * Math.sin(radiusScan.angle),
                        4 + glow.pulseSize, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Display current angle with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const currentAngle = (radiusScan.angle * 180 / Math.PI) % 360;
                    ctx.font = '16px monospace';
                    ctx.fillStyle = '#FFF';
                    ctx.fillText(`Angle: ${currentAngle.toFixed(1)}°`, 20, 30);
                    ctx.fillText(`Radians: ${radiusScan.angle.toFixed(2)}`, 20, 50);
                    
                    // Display Pi symbol and formula with glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    ctx.font = '36px Arial';
                    ctx.fillStyle = '#666';
                    const piText = 'π';
                    const piTextWidth = ctx.measureText(piText).width;
                    ctx.fillText(piText, canvas.width / 2 - piTextWidth / 2, canvas.height / 2 - 60);
                    
                    ctx.font = '20px Arial';
                    ctx.fillStyle = '#AAA';
                    const piValueText = '3.1415926535...';
                    const piValueWidth = ctx.measureText(piValueText).width;
                    ctx.fillText(piValueText, canvas.width / 2 - piValueWidth / 2, canvas.height / 2 - 30);

                    // Display formula with glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px monospace';
                    const formulaText = 'C = 2πr';
                    const formulaWidth = ctx.measureText(formulaText).width;
                    ctx.fillText(formulaText, canvas.width / 2 - formulaWidth / 2, canvas.height / 2 + circle.radius + 40);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(unrolledCircle, {
                progress: 1,
                duration: 2,
                ease: "power1.inOut",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw original circle (smaller) with glow
                    const smallRadius = 60;
                    
                    ctx.shadowBlur = 5 + glow.intensity * 10;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    
                    const circleGradient = ctx.createRadialGradient(
                        canvas.width / 4, canvas.height / 2, 0,
                        canvas.width / 4, canvas.height / 2, smallRadius
                    );
                    circleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    circleGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    circleGradient.addColorStop(1, 'rgba(100, 100, 200, 0.5)');
                    
                    ctx.strokeStyle = circleGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 4, canvas.height / 2, smallRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw unrolled line with enhanced gradient and glow
                    const lineY = canvas.height / 2;
                    const lineStartX = canvas.width / 2 - 50;
                    const lineLength = 2 * Math.PI * smallRadius * unrolledCircle.progress;
                    const lineEndX = lineStartX + lineLength;
                    
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    
                    // Draw line with enhanced gradient
                    const gradient = ctx.createLinearGradient(lineStartX, lineY, lineEndX, lineY);
                    gradient.addColorStop(0, 'rgba(100, 100, 200, 0.3)');
                    gradient.addColorStop(0.25, 'rgba(170, 170, 255, 0.7)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.75, 'rgba(170, 170, 255, 0.7)');
                    gradient.addColorStop(1, 'rgba(100, 100, 200, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(lineStartX, lineY);
                    ctx.lineTo(lineEndX, lineY);
                    ctx.stroke();
                    
                    // Draw measurement markers with glow
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    ctx.strokeStyle = 'rgba(170, 170, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    
                    // Start marker
                    ctx.beginPath();
                    ctx.moveTo(lineStartX, lineY - 10);
                    ctx.lineTo(lineStartX, lineY + 10);
                    ctx.stroke();
                    
                    // End marker
                    ctx.beginPath();
                    ctx.moveTo(lineEndX, lineY - 10);
                    ctx.lineTo(lineEndX, lineY + 10);
                    ctx.stroke();
                    
                    // Pi marker (half circumference) with enhanced glow
                    const piMarkerX = lineStartX + lineLength / 2;
                    ctx.shadowBlur = 8 + glow.intensity * 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(piMarkerX, lineY - 15);
                    ctx.lineTo(piMarkerX, lineY + 15);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    
                    // Draw connecting arc from circle to line with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const arcGradient = ctx.createLinearGradient(
                        canvas.width / 4 - smallRadius - 10, canvas.height / 2,
                        canvas.width / 4 + smallRadius + 10, canvas.height / 2
                    );
                    arcGradient.addColorStop(0, 'rgba(100, 100, 200, 0.3)');
                    arcGradient.addColorStop(0.5, 'rgba(170, 170, 255, 0.7)');
                    arcGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.strokeStyle = arcGradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 4, canvas.height / 2, smallRadius + 10, -Math.PI/2, -Math.PI/2 + unrolledCircle.progress * Math.PI * 2);
                    ctx.stroke();
                    
                    // Display measurements with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    ctx.font = '16px monospace';
                    ctx.fillStyle = '#FFF';
                    ctx.fillText('Circumference = 2πr', lineStartX, lineY - 30);
                    
                    // Display Pi at half point with enhanced glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
                    
                    ctx.font = '20px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.fillText('π', piMarkerX - 10, lineY - 20);
                    
                    // Display actual length with glow
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    ctx.font = '14px monospace';
                    ctx.fillStyle = 'rgba(170, 170, 255, 0.9)';
                    ctx.fillText(`Length: ${(2 * Math.PI * smallRadius * unrolledCircle.progress).toFixed(1)}px`, lineStartX, lineY + 30);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(piDigits, {
                display: piDigitsString,
                duration: 1.5,
                ease: "power1.out",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw final visualization with glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const radius = 100;
                    
                    // Draw circle with enhanced glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const circleGradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, radius
                    );
                    circleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    circleGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    circleGradient.addColorStop(1, 'rgba(100, 100, 200, 0.5)');
                    
                    ctx.strokeStyle = circleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw Pi digits around the circle with enhanced glow
                    const numDigitsToShow = Math.floor(piDigits.display.length * (timeline.progress() - 0.7) / 0.3);
                    if (numDigitsToShow > 0) {
                        ctx.font = '14px monospace';
                        
                        for (let i = 0; i < numDigitsToShow; i++) {
                            const angle = (i / numDigitsToShow) * Math.PI * 2 - Math.PI / 2;
                            const x = centerX + (radius + 20) * Math.cos(angle);
                            const y = centerY + (radius + 20) * Math.sin(angle);
                            
                            // Fade in effect for new digits
                            const opacity = i >= numDigitsToShow - 5 ? (i - (numDigitsToShow - 5)) / 5 : 1;
                            
                            // Enhanced glow for new digits
                            if (i >= numDigitsToShow - 3) {
                                ctx.shadowBlur = 15 + glow.intensity * 20;
                                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                            } else {
                                ctx.shadowBlur = 5 + glow.intensity * 8;
                                ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                            }
                            
                            // Highlight the decimal point with enhanced glow
                            if (piDigits.display[i] === '.') {
                                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                                ctx.font = '18px monospace';
                            } else {
                                // Vary color for visual interest with enhanced gradient
                                const colorValue = 100 + Math.floor(155 * (i / numDigitsToShow));
                                const blueValue = 200 + Math.floor(55 * (i / numDigitsToShow));
                                ctx.fillStyle = `rgba(${colorValue}, ${colorValue}, ${blueValue}, ${opacity})`;
                                ctx.font = '14px monospace';
                            }
                            
                            ctx.fillText(piDigits.display[i], x - 5, y + 5);
                        }
                    }
                    
                    // Display Pi symbol in center with enhanced glow
                    ctx.shadowBlur = 15 + glow.intensity * 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    
                    const piGradient = ctx.createRadialGradient(
                        centerX, centerY - 15, 0,
                        centerX, centerY - 15, 40
                    );
                    piGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    piGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.9)');
                    piGradient.addColorStop(1, 'rgba(150, 150, 255, 0.7)');
                    
                    ctx.fillStyle = piGradient;
                    ctx.font = '48px Arial';
                    const piText = 'π';
                    const piTextWidth = ctx.measureText(piText).width;
                    ctx.fillText(piText, centerX - piTextWidth / 2, centerY + 15);
                    
                    // Display formula with enhanced glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    ctx.font = '20px monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    const formulaText = 'C = 2πr = 2 × 3.1415926535... × r';
                    const formulaWidth = ctx.measureText(formulaText).width;
                    ctx.fillText(formulaText, centerX - formulaWidth / 2, centerY + radius + 50);
                    
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 9: "If I'm a sine wave Then you can sit on all my TANGENTS" / "如果我是一条正弦波 那么请你坐上 我的切线"
        function scene9() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const waveOffset = {
                x: 0
            };
            const tangentPoint = {
                x: 0
            };
            const carPosition = {
                x: -50
            };
            const derivativeText = {
                opacity: 0
            };
            const derivativeGraph = {
                opacity: 0,
                progress: 0
            };
            const tangentPoints = [];
            const gridLines = {
                opacity: 0
            };
            
            // Add glow effect properties
            const glow = {
                intensity: 0,
                pulseSize: 0
            };

            // Generate tangent points for visualization
            for (let i = 0; i <= 20; i++) {
                const x = (i / 20) * Math.PI * 2;
                const y = Math.sin(x);
                const derivative = Math.cos(x);
                tangentPoints.push({
                    x: x,
                    y: y,
                    derivative: derivative,
                    visible: false
                });
            }

            // Create gradient background function
            function drawBackground() {
                const bgGradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                bgGradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            timeline.to(glow, {
                intensity: 1,
                pulseSize: 2,
                duration: 1
            })
            .to(waveOffset, {
                x: -canvas.width / 4,
                duration: 1.5,
                ease: "linear",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw grid with enhanced glow
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    
                    ctx.strokeStyle = `rgba(102, 102, 153, ${gridLines.opacity * 0.3})`;
                    ctx.lineWidth = 0.5;
                    
                    // Vertical grid lines
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    // Horizontal grid lines
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with enhanced glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.7)';
                    
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw sine wave with enhanced gradient and glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2 - 100, 0, canvas.height / 2 + 100);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + Math.sin((x + waveOffset.x) * 0.02) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Draw axis labels with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const labelGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                    labelGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.fillText('π', canvas.width / 2 + 100, canvas.height / 2 + 20);
                    ctx.fillText('-π', canvas.width / 2 - 100 - 15, canvas.height / 2 + 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    ctx.fillText('1', canvas.width / 2 - 20, canvas.height / 2 - 100 - 10);
                    ctx.fillText('-1', canvas.width / 2 - 25, canvas.height / 2 + 100 + 20);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(gridLines, {
                opacity: 1,
                duration: 0.5
            }, "-=1.5")
            .to(tangentPoint, {
                x: canvas.width / 2,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw grid with enhanced glow
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    
                    ctx.strokeStyle = 'rgba(102, 102, 153, 0.3)';
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with enhanced glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.7)';
                    
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw sine wave with enhanced gradient and glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2 - 100, 0, canvas.height / 2 + 100);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + Math.sin((x + waveOffset.x) * 0.02) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Calculate tangent at tangentPoint.x
                    const slope = Math.cos((tangentPoint.x + waveOffset.x) * 0.02) * 100 * 0.02;
                    const yTangent = canvas.height / 2 + Math.sin((tangentPoint.x + waveOffset.x) * 0.02) * 100;

                    // Draw tangent line with enhanced gradient and glow
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    
                    const tangentGradient = ctx.createLinearGradient(
                        tangentPoint.x - 150, yTangent - slope * 150,
                        tangentPoint.x + 150, yTangent + slope * 150
                    );
                    tangentGradient.addColorStop(0, 'rgba(100, 100, 200, 0.2)');
                    tangentGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    tangentGradient.addColorStop(1, 'rgba(100, 100, 200, 0.2)');
                    
                    ctx.strokeStyle = tangentGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(tangentPoint.x - 150, yTangent - slope * 150);
                    ctx.lineTo(tangentPoint.x + 150, yTangent + slope * 150);
                    ctx.stroke();
                    
                    // Draw tangent points with glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const pointGradient = ctx.createRadialGradient(
                        tangentPoint.x - 150, yTangent - slope * 150, 0,
                        tangentPoint.x - 150, yTangent - slope * 150, 5
                    );
                    pointGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    pointGradient.addColorStop(1, 'rgba(200, 200, 255, 0.7)');
                    
                    ctx.fillStyle = pointGradient;
                    ctx.beginPath();
                    ctx.arc(tangentPoint.x - 150, yTangent - slope * 150, 3 + glow.pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const pointGradient2 = ctx.createRadialGradient(
                        tangentPoint.x + 150, yTangent + slope * 150, 0,
                        tangentPoint.x + 150, yTangent + slope * 150, 5
                    );
                    pointGradient2.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    pointGradient2.addColorStop(1, 'rgba(200, 200, 255, 0.7)');
                    
                    ctx.fillStyle = pointGradient2;
                    ctx.beginPath();
                    ctx.arc(tangentPoint.x + 150, yTangent + slope * 150, 3 + glow.pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw tangent point with enhanced glow
                    ctx.shadowBlur = 15 + glow.intensity * 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    
                    const centerPointGradient = ctx.createRadialGradient(
                        tangentPoint.x, yTangent, 0,
                        tangentPoint.x, yTangent, 8
                    );
                    centerPointGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    centerPointGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.9)');
                    centerPointGradient.addColorStop(1, 'rgba(150, 150, 255, 0.7)');
                    
                    ctx.fillStyle = centerPointGradient;
                    ctx.beginPath();
                    ctx.arc(tangentPoint.x, yTangent, 5 + glow.pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Display slope value with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const textGradient = ctx.createLinearGradient(
                        tangentPoint.x + 20, yTangent - 10,
                        tangentPoint.x + 120, yTangent + 20
                    );
                    textGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                    textGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = '14px monospace';
                    ctx.fillText(`Slope: ${slope.toFixed(2)}`, tangentPoint.x + 20, yTangent - 10);
                    
                    // Display angle with glow
                    const angle = Math.atan(slope) * 180 / Math.PI;
                    ctx.fillText(`Angle: ${angle.toFixed(1)}°`, tangentPoint.x + 20, yTangent + 10);

                    // Draw axis labels with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const labelGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                    labelGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.fillText('π', canvas.width / 2 + 100, canvas.height / 2 + 20);
                    ctx.fillText('-π', canvas.width / 2 - 100 - 15, canvas.height / 2 + 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    ctx.fillText('1', canvas.width / 2 - 20, canvas.height / 2 - 100 - 10);
                    ctx.fillText('-1', canvas.width / 2 - 25, canvas.height / 2 + 100 + 20);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(carPosition, {
                x: canvas.width + 50,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();
                    
                    // Draw grid with enhanced glow
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    
                    ctx.strokeStyle = 'rgba(102, 102, 153, 0.3)';
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with enhanced glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.7)';
                    
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw sine wave with enhanced gradient and glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2 - 100, 0, canvas.height / 2 + 100);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + Math.sin((x + waveOffset.x) * 0.02) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Draw car with enhanced gradient and glow
                    const carY = canvas.height / 2 + Math.sin((carPosition.x + waveOffset.x) * 0.02) * 100;
                    const carSlope = Math.cos((carPosition.x + waveOffset.x) * 0.02) * 100 * 0.02;
                    const carRotation = Math.atan(carSlope);

                    ctx.save();
                    ctx.translate(carPosition.x, carY);
                    ctx.rotate(carRotation);
                    
                    // Car body with gradient
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                    
                    const bodyGradient = ctx.createLinearGradient(-20, -10, 20, 10);
                    bodyGradient.addColorStop(0, 'rgba(102, 102, 153, 1)');
                    bodyGradient.addColorStop(0.5, 'rgba(153, 153, 204, 1)');
                    bodyGradient.addColorStop(1, 'rgba(102, 102, 153, 1)');
                    
                    ctx.fillStyle = bodyGradient;
                    ctx.fillRect(-20, -10, 40, 20);
                    
                    // Car windows with gradient
                    const windowGradient = ctx.createLinearGradient(-15, -8, 15, 8);
                    windowGradient.addColorStop(0, 'rgba(170, 170, 204, 1)');
                    windowGradient.addColorStop(0.5, 'rgba(204, 204, 230, 1)');
                    windowGradient.addColorStop(1, 'rgba(170, 170, 204, 1)');
                    
                    ctx.fillStyle = windowGradient;
                    ctx.fillRect(-15, -8, 10, 16);
                    ctx.fillRect(5, -8, 10, 16);
                    
                    // Car direction indicator with enhanced glow
                    ctx.shadowBlur = 15 + glow.intensity * 20;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    
                    const indicatorGradient = ctx.createLinearGradient(15, -5, 25, 5);
                    indicatorGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    indicatorGradient.addColorStop(1, 'rgba(200, 200, 255, 1)');
                    
                    ctx.fillStyle = indicatorGradient;
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(15, -5);
                    ctx.lineTo(15, 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Draw car's tangent line with enhanced gradient and glow
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const tangentGradient = ctx.createLinearGradient(
                        carPosition.x - 100, carY - carSlope * 100,
                        carPosition.x + 100, carY + carSlope * 100
                    );
                    tangentGradient.addColorStop(0, 'rgba(100, 100, 200, 0.2)');
                    tangentGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                    tangentGradient.addColorStop(1, 'rgba(100, 100, 200, 0.2)');
                    
                    ctx.strokeStyle = tangentGradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(carPosition.x - 100, carY - carSlope * 100);
                    ctx.lineTo(carPosition.x + 100, carY + carSlope * 100);
                    ctx.stroke();

                    // Draw axis labels with glow
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    
                    const labelGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                    labelGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.fillText('π', canvas.width / 2 + 100, canvas.height / 2 + 20);
                    ctx.fillText('-π', canvas.width / 2 - 100 - 15, canvas.height / 2 + 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    ctx.fillText('1', canvas.width / 2 - 20, canvas.height / 2 - 100 - 10);
                    ctx.fillText('-1', canvas.width / 2 - 25, canvas.height / 2 + 100 + 20);
                    
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(derivativeText, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw grid
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.3)';
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.width);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw sine wave
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2 - 100, 0, canvas.height / 2 + 100);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + Math.sin((x + waveOffset.x) * 0.02) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Draw car
                    const carY = canvas.height / 2 + Math.sin((carPosition.x + waveOffset.x) * 0.02) * 100;
                    const carSlope = Math.cos((carPosition.x + waveOffset.x) * 0.02) * 100 * 0.02;
                    const carRotation = Math.atan(carSlope);

                    ctx.save();
                    ctx.translate(carPosition.x, carY);
                    ctx.rotate(carRotation);
                    
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-20, -10, 40, 20);
                    
                    ctx.fillStyle = '#AAA';
                    ctx.fillRect(-15, -8, 10, 16);
                    ctx.fillRect(5, -8, 10, 16);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(20, 0);
                    ctx.lineTo(15, -5);
                    ctx.lineTo(15, 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();

                    // Display derivative formula with enhanced styling
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(canvas.width / 2 - 120, canvas.height / 2 + 120, 240, 40);
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '20px monospace';
                    const derivative = 'dy/dx = cos(x)';
                    const derivativeWidth = ctx.measureText(derivative).width;
                    ctx.fillText(derivative, canvas.width / 2 - derivativeWidth / 2, canvas.height / 2 + 145);
                    
                    // Display current derivative value
                    ctx.fillStyle = '#FFF';
                    ctx.font = '16px monospace';
                    const currentDerivative = `Current: ${carSlope.toFixed(2)}`;
                    ctx.fillText(currentDerivative, canvas.width / 2 - 50, canvas.height / 2 + 170);
                    
                    // Draw axis labels
                    ctx.fillStyle = '#FFF';
                    ctx.font = '14px monospace';
                    ctx.fillText('π', canvas.width / 2 + 100, canvas.height / 2 + 20);
                    ctx.fillText('-π', canvas.width / 2 - 100 - 15, canvas.height / 2 + 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    ctx.fillText('1', canvas.width / 2 - 20, canvas.height / 2 - 100 - 10);
                    ctx.fillText('-1', canvas.width / 2 - 25, canvas.height / 2 + 100 + 20);
                }
            })
            .to(derivativeGraph, {
                opacity: 1,
                progress: 1,
                duration: 2,
                ease: "power1.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw grid
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.3)';
                    ctx.lineWidth = 0.5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.width);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw sine wave
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2 - 100, 0, canvas.height / 2 + 100);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    for (let x = 0; x < canvas.width; x += 5) {
                        const y = canvas.height / 2 + Math.sin((x + waveOffset.x) * 0.02) * 100;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Draw derivative graph (cosine)
                    ctx.strokeStyle = `rgba(255, 255, 255, ${derivativeGraph.opacity * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const progress = derivativeGraph.progress;
                    const endX = canvas.width * progress;
                    
                    for (let x = 0; x <= endX; x += 5) {
                        const y = canvas.height / 2 - Math.cos((x + waveOffset.x) * 0.02) * 50; // Scaled down for visibility
                        if (x === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Label for derivative graph
                    if (progress > 0.2) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${derivativeGraph.opacity})`;
                        ctx.font = '16px monospace';
                        ctx.fillText("f'(x) = cos(x)", canvas.width - 150, 30);
                    }
                    
                    // Draw tangent points on both graphs
                    if (progress > 0.5) {
                        const numPoints = Math.floor(tangentPoints.length * (progress - 0.5) / 0.5);
                        for (let i = 0; i < numPoints; i++) {
                            const point = tangentPoints[i];
                            const x = (point.x / (Math.PI * 2)) * canvas.width;
                            const sineY = canvas.height / 2 - point.y * 100;
                            const cosY = canvas.height / 2 - point.derivative * 50;
                            
                            // Draw tangent line at this point
                            ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(x - 30, sineY - point.derivative * 30);
                            ctx.lineTo(x + 30, sineY + point.derivative * 30);
                            ctx.stroke();
                            
                            // Draw point on sine wave
                            ctx.fillStyle = '#FFF';
                            ctx.beginPath();
                            ctx.arc(x, sineY, 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Draw point on cosine graph
                            ctx.beginPath();
                            ctx.arc(x, cosY, 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Connect the points
                            ctx.strokeStyle = `rgba(170, 170, 170, 0.5)`;
                            ctx.beginPath();
                            ctx.moveTo(x, sineY);
                            ctx.lineTo(x, cosY);
                            ctx.stroke();
                        }
                    }

                    // Display derivative formula
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(canvas.width / 2 - 120, canvas.height / 2 + 120, 240, 40);
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '20px monospace';
                    const derivative = 'dy/dx = cos(x)';
                    const derivativeWidth = ctx.measureText(derivative).width;
                    ctx.fillText(derivative, canvas.width / 2 - derivativeWidth / 2, canvas.height / 2 + 145);
                    
                    // Draw axis labels
                    ctx.fillStyle = '#FFF';
                    ctx.font = '14px monospace';
                    ctx.fillText('π', canvas.width / 2 + 100, canvas.height / 2 + 20);
                    ctx.fillText('-π', canvas.width / 2 - 100 - 15, canvas.height / 2 + 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    ctx.fillText('1', canvas.width / 2 - 20, canvas.height / 2 - 100 - 10);
                    ctx.fillText('-1', canvas.width / 2 - 25, canvas.height / 2 + 100 + 20);
                }
            }, "-=1");

            return timeline;
        }

        // Scene 10: "If I approach infinity Then you can be my LIMITATIONS" / "如果我趋近于无穷 那么你便可以成为 我的极限"
        function scene10() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const funcProgress = {
                value: 0
            };
            const limitText = {
                opacity: 0
            };
            const infinitySymbol = {
                scale: 0,
                rotation: 0
            };
            const approachValues = {
                opacity: 0
            };
            const asymptote = {
                opacity: 0
            };
            const approachPoints = {
                opacity: 0
            };
            
            // Add glow effect properties
            const glow = {
                intensity: 0,
                pulseSize: 0
            };
            
            // Function to draw gradient background
            const drawBackground = () => {
                const bgGradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                bgGradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 1,
                ease: "power2.inOut"
            })
            .to(funcProgress, {
                value: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();

                    // Draw grid with glow effect
                    ctx.strokeStyle = `rgba(102, 102, 102, ${0.3 + glow.intensity * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with gradient and glow
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw function f(x) = 1/x with enhanced gradient and glow
                    const funcGradient = ctx.createLinearGradient(canvas.width / 2, 0, canvas.width, canvas.height);
                    funcGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    funcGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    funcGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = funcGradient;
                    ctx.lineWidth = 2.5;
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.9)';
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 + 1, canvas.height / 2 + 1);
                    for (let x = 1; x <= 100 * funcProgress.value; x += 1) {
                        const scaledX = x * 2;
                        const y = canvas.height / 2 - (1 / x) * 100;
                        ctx.lineTo(canvas.width / 2 + scaledX, y);
                    }
                    ctx.stroke();

                    // Draw axis labels with gradient and glow
                    const labelGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.8)');
                    labelGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    labelGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.fillText('x', canvas.width - 30, canvas.height / 2 - 10);
                    ctx.fillText('y', canvas.width / 2 + 10, 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                }
            })
            .to(limitText, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();

                    // Draw grid with glow effect
                    ctx.strokeStyle = `rgba(102, 102, 102, ${0.3 + glow.intensity * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with gradient and glow
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw function with enhanced gradient and glow
                    const funcGradient = ctx.createLinearGradient(canvas.width / 2, 0, canvas.width, canvas.height);
                    funcGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    funcGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    funcGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = funcGradient;
                    ctx.lineWidth = 2.5;
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.9)';
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 + 1, canvas.height / 2 + 1);
                    for (let x = 1; x <= 100; x += 1) {
                        const scaledX = x * 2;
                        const y = canvas.height / 2 - (1 / x) * 100;
                        ctx.lineTo(canvas.width / 2 + scaledX, y);
                    }
                    ctx.stroke();

                    // Draw axis labels with gradient and glow
                    const labelGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.8)');
                    labelGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    labelGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.fillText('x', canvas.width - 30, canvas.height / 2 - 10);
                    ctx.fillText('y', canvas.width / 2 + 10, 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);

                    // Display limit symbol with enhanced styling and glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    
                    // Create gradient background for limit text
                    const bgGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 - 100,
                        canvas.width / 2 + 100, canvas.height / 2 - 20
                    );
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    bgGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    bgGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 100, 200, 80);
                    
                    // Create gradient for text
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 - 100,
                        canvas.width / 2 + 50, canvas.height / 2 - 20
                    );
                    textGradient.addColorStop(0, 'rgba(50, 50, 100, 0.9)');
                    textGradient.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    textGradient.addColorStop(1, 'rgba(50, 50, 100, 0.9)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = '30px monospace';
                    const limText = 'lim';
                    const limTextWidth = ctx.measureText(limText).width;
                    ctx.fillText(limText, canvas.width / 2 - limTextWidth / 2, canvas.height / 2 - 50);

                    ctx.font = '20px monospace';
                    const xInfText = 'x→∞';
                    const xInfTextWidth = ctx.measureText(xInfText).width;
                    ctx.fillText(xInfText, canvas.width / 2 - xInfTextWidth / 2, canvas.height / 2 - 20);

                    const fx0Text = 'f(x) = 0';
                    const fx0TextWidth = ctx.measureText(fx0Text).width;
                    ctx.fillText(fx0Text, canvas.width / 2 - fx0TextWidth / 2, canvas.height / 2 + 5);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(infinitySymbol, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();

                    // Draw grid with glow effect
                    ctx.strokeStyle = `rgba(102, 102, 102, ${0.3 + glow.intensity * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with gradient and glow
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw function with enhanced gradient and glow
                    const funcGradient = ctx.createLinearGradient(canvas.width / 2, 0, canvas.width, canvas.height);
                    funcGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    funcGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    funcGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = funcGradient;
                    ctx.lineWidth = 2.5;
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.9)';
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 + 1, canvas.height / 2 + 1);
                    for (let x = 1; x <= 100; x += 1) {
                        const scaledX = x * 2;
                        const y = canvas.height / 2 - (1 / x) * 100;
                        ctx.lineTo(canvas.width / 2 + scaledX, y);
                    }
                    ctx.stroke();

                    // Draw axis labels with gradient and glow
                    const labelGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.8)');
                    labelGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    labelGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.fillText('x', canvas.width - 30, canvas.height / 2 - 10);
                    ctx.fillText('y', canvas.width / 2 + 10, 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);

                    // Display limit symbol with enhanced styling and glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    
                    // Create gradient background for limit text
                    const bgGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 - 100,
                        canvas.width / 2 + 100, canvas.height / 2 - 20
                    );
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    bgGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    bgGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 100, 200, 80);
                    
                    // Create gradient for text
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 - 100,
                        canvas.width / 2 + 50, canvas.height / 2 - 20
                    );
                    textGradient.addColorStop(0, 'rgba(50, 50, 100, 0.9)');
                    textGradient.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    textGradient.addColorStop(1, 'rgba(50, 50, 100, 0.9)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = '30px monospace';
                    const limText = 'lim';
                    const limTextWidth = ctx.measureText(limText).width;
                    ctx.fillText(limText, canvas.width / 2 - limTextWidth / 2, canvas.height / 2 - 50);

                    ctx.font = '20px monospace';
                    const xInfText = 'x→∞';
                    const xInfTextWidth = ctx.measureText(xInfText).width;
                    ctx.fillText(xInfText, canvas.width / 2 - xInfTextWidth / 2, canvas.height / 2 - 20);

                    const fx0Text = 'f(x) = 0';
                    const fx0TextWidth = ctx.measureText(fx0Text).width;
                    ctx.fillText(fx0Text, canvas.width / 2 - fx0TextWidth / 2, canvas.height / 2 + 5);

                    // Draw infinity symbol with enhanced effect and gradient
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 80);
                    ctx.rotate(infinitySymbol.rotation);
                    
                    // Create gradient for infinity symbol
                    const infinityGradient = ctx.createLinearGradient(-40, 0, 40, 0);
                    infinityGradient.addColorStop(0, 'rgba(100, 100, 255, 0.7)');
                    infinityGradient.addColorStop(0.5, 'rgba(200, 200, 255, 1)');
                    infinityGradient.addColorStop(1, 'rgba(100, 100, 255, 0.7)');
                    
                    // Add enhanced glow effect
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.9)';
                    ctx.shadowBlur = 15 * infinitySymbol.scale + glow.intensity * 10;
                    
                    ctx.font = `${80 * infinitySymbol.scale}px monospace`;
                    ctx.fillStyle = infinityGradient;
                    const infinitySymbolText = '∞';
                    const infinitySymbolWidth = ctx.measureText(infinitySymbolText).width;
                    ctx.fillText(infinitySymbolText, -infinitySymbolWidth / 2, 0);
                    ctx.restore();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(approachValues, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Draw gradient background
                    drawBackground();

                    // Draw grid with glow effect
                    ctx.strokeStyle = `rgba(102, 102, 102, ${0.3 + glow.intensity * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.shadowColor = 'rgba(100, 100, 200, 0.5)';
                    ctx.shadowBlur = 3 + glow.intensity * 5;
                    
                    for (let x = 0; x < canvas.width; x += 50) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 50) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes with gradient and glow
                    const axisGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    axisGradient.addColorStop(0, 'rgba(100, 100, 200, 0.8)');
                    axisGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    axisGradient.addColorStop(1, 'rgba(100, 100, 200, 0.8)');
                    
                    ctx.strokeStyle = axisGradient;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    // Draw function with enhanced gradient and glow
                    const funcGradient = ctx.createLinearGradient(canvas.width / 2, 0, canvas.width, canvas.height);
                    funcGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    funcGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    funcGradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = funcGradient;
                    ctx.lineWidth = 2.5;
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.9)';
                    ctx.shadowBlur = 8 + glow.intensity * 12;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 + 1, canvas.height / 2 + 1);
                    for (let x = 1; x <= 100; x += 1) {
                        const scaledX = x * 2;
                        const y = canvas.height / 2 - (1 / x) * 100;
                        ctx.lineTo(canvas.width / 2 + scaledX, y);
                    }
                    ctx.stroke();

                    // Draw axis labels with gradient and glow
                    const labelGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    labelGradient.addColorStop(0, 'rgba(200, 200, 255, 0.8)');
                    labelGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    labelGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.fillStyle = labelGradient;
                    ctx.font = '14px monospace';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    ctx.shadowBlur = 5 + glow.intensity * 8;
                    ctx.fillText('x', canvas.width - 30, canvas.height / 2 - 10);
                    ctx.fillText('y', canvas.width / 2 + 10, 20);
                    ctx.fillText('0', canvas.width / 2 - 10, canvas.height / 2 + 20);

                    // Display limit symbol with enhanced styling and glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    
                    // Create gradient background for limit text
                    const bgGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 - 100,
                        canvas.width / 2 + 100, canvas.height / 2 - 20
                    );
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    bgGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    bgGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 100, 200, 80);
                    
                    // Create gradient for text
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 - 100,
                        canvas.width / 2 + 50, canvas.height / 2 - 20
                    );
                    textGradient.addColorStop(0, 'rgba(50, 50, 100, 0.9)');
                    textGradient.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    textGradient.addColorStop(1, 'rgba(50, 50, 100, 0.9)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = '30px monospace';
                    const limText = 'lim';
                    const limTextWidth = ctx.measureText(limText).width;
                    ctx.fillText(limText, canvas.width / 2 - limTextWidth / 2, canvas.height / 2 - 50);

                    ctx.font = '20px monospace';
                    const xInfText = 'x→∞';
                    const xInfTextWidth = ctx.measureText(xInfText).width;
                    ctx.fillText(xInfText, canvas.width / 2 - xInfTextWidth / 2, canvas.height / 2 - 20);

                    const fx0Text = 'f(x) = 0';
                    const fx0TextWidth = ctx.measureText(fx0Text).width;
                    ctx.fillText(fx0Text, canvas.width / 2 - fx0TextWidth / 2, canvas.height / 2 + 5);

                    // Draw infinity symbol with enhanced effect and gradient
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 80);
                    ctx.rotate(infinitySymbol.rotation);
                    
                    // Create gradient for infinity symbol
                    const infinityGradient = ctx.createLinearGradient(-40, 0, 40, 0);
                    infinityGradient.addColorStop(0, 'rgba(100, 100, 255, 0.7)');
                    infinityGradient.addColorStop(0.5, 'rgba(200, 200, 255, 1)');
                    infinityGradient.addColorStop(1, 'rgba(100, 100, 255, 0.7)');
                    
                    // Add enhanced glow effect
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.9)';
                    ctx.shadowBlur = 15 * infinitySymbol.scale + glow.intensity * 10;
                    
                    ctx.font = `${80 * infinitySymbol.scale}px monospace`;
                    ctx.fillStyle = infinityGradient;
                    const infinitySymbolText = '∞';
                    const infinitySymbolWidth = ctx.measureText(infinitySymbolText).width;
                    ctx.fillText(infinitySymbolText, -infinitySymbolWidth / 2, 0);
                    ctx.restore();

                    // Draw asymptote (x-axis) with enhanced gradient and glow
                    const asymptoteGradient = ctx.createLinearGradient(0, canvas.height / 2, canvas.width, canvas.height / 2);
                    asymptoteGradient.addColorStop(0, `rgba(150, 150, 255, ${approachValues.opacity * 0.3})`);
                    asymptoteGradient.addColorStop(0.5, `rgba(200, 200, 255, ${approachValues.opacity * 0.6})`);
                    asymptoteGradient.addColorStop(1, `rgba(150, 150, 255, ${approachValues.opacity * 0.3})`);
                    
                    ctx.strokeStyle = asymptoteGradient;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 8 + glow.intensity * 10;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label for asymptote with gradient and glow
                    const asymptoteLabelGradient = ctx.createLinearGradient(
                        canvas.width - 180, canvas.height / 2 - 10,
                        canvas.width - 50, canvas.height / 2 - 10
                    );
                    asymptoteLabelGradient.addColorStop(0, `rgba(150, 150, 255, ${approachValues.opacity * 0.7})`);
                    asymptoteLabelGradient.addColorStop(0.5, `rgba(255, 255, 255, ${approachValues.opacity})`);
                    asymptoteLabelGradient.addColorStop(1, `rgba(150, 150, 255, ${approachValues.opacity * 0.7})`);
                    
                    ctx.fillStyle = asymptoteLabelGradient;
                    ctx.font = '16px monospace';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                    ctx.shadowBlur = 6 + glow.intensity * 8;
                    ctx.fillText('y = 0 (asymptote)', canvas.width - 180, canvas.height / 2 - 10);

                    // Draw approaching points on the curve with enhanced effects
                    const testValues = [10, 20, 50, 100];
                    for (let i = 0; i < testValues.length; i++) {
                        const x = testValues[i];
                        const scaledX = canvas.width / 2 + x * 2;
                        const y = canvas.height / 2 - (1 / x) * 100;
                        
                        // Create gradient for point
                        const pointGradient = ctx.createRadialGradient(scaledX, y, 0, scaledX, y, 5);
                        pointGradient.addColorStop(0, `rgba(255, 255, 255, ${approachValues.opacity})`);
                        pointGradient.addColorStop(0.5, `rgba(200, 200, 255, ${approachValues.opacity * 0.8})`);
                        pointGradient.addColorStop(1, `rgba(150, 150, 255, ${approachValues.opacity * 0.5})`);
                        
                        // Draw point with glow
                        ctx.fillStyle = pointGradient;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.9)';
                        ctx.shadowBlur = 10 + glow.intensity * 15;
                        ctx.beginPath();
                        ctx.arc(scaledX, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Create gradient for vertical line
                        const lineGradient = ctx.createLinearGradient(scaledX, y, scaledX, canvas.height / 2);
                        lineGradient.addColorStop(0, `rgba(170, 170, 255, ${approachValues.opacity * 0.7})`);
                        lineGradient.addColorStop(1, `rgba(170, 170, 255, ${approachValues.opacity * 0.2})`);
                        
                        // Draw vertical line to asymptote with gradient
                        ctx.strokeStyle = lineGradient;
                        ctx.lineWidth = 1.5;
                        ctx.shadowColor = 'rgba(170, 170, 255, 0.6)';
                        ctx.shadowBlur = 5 + glow.intensity * 8;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(scaledX, y);
                        ctx.lineTo(scaledX, canvas.height / 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Label the point with gradient and glow
                        const pointLabelGradient = ctx.createLinearGradient(
                            scaledX + 5, y - 5,
                            scaledX + 100, y - 5
                        );
                        pointLabelGradient.addColorStop(0, `rgba(200, 200, 255, ${approachValues.opacity * 0.9})`);
                        pointLabelGradient.addColorStop(0.5, `rgba(255, 255, 255, ${approachValues.opacity})`);
                        pointLabelGradient.addColorStop(1, `rgba(200, 200, 255, ${approachValues.opacity * 0.7})`);
                        
                        ctx.fillStyle = pointLabelGradient;
                        ctx.font = '12px monospace';
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.7)';
                        ctx.shadowBlur = 4 + glow.intensity * 6;
                        ctx.fillText(`(${x}, ${(1/x).toFixed(3)})`, scaledX + 5, y - 5);
                    }

                    // Display approaching values with enhanced styling and glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10 + glow.intensity * 15;
                    
                    // Create gradient background for values text
                    const valuesBgGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 120, canvas.height / 2 + 120,
                        canvas.width / 2 + 120, canvas.height / 2 + 180
                    );
                    valuesBgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    valuesBgGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    valuesBgGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.fillStyle = valuesBgGradient;
                    ctx.fillRect(canvas.width / 2 - 120, canvas.height / 2 + 120, 240, 60);
                    
                    // Create gradient for values text
                    const valuesTextGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 60, canvas.height / 2 + 120,
                        canvas.width / 2 + 60, canvas.height / 2 + 180
                    );
                    valuesTextGradient.addColorStop(0, 'rgba(50, 50, 100, 0.9)');
                    valuesTextGradient.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    valuesTextGradient.addColorStop(1, 'rgba(50, 50, 100, 0.9)');
                    
                    ctx.fillStyle = valuesTextGradient;
                    ctx.font = '20px monospace';
                    const valuesText = '10, 100, 1000...';
                    const valuesWidth = ctx.measureText(valuesText).width;
                    ctx.fillText(valuesText, canvas.width / 2 - valuesWidth / 2, canvas.height / 2 + 145);
                    
                    ctx.font = '16px monospace';
                    const approachingText = 'f(x) → 0 as x → ∞';
                    const approachingWidth = ctx.measureText(approachingText).width;
                    ctx.fillText(approachingText, canvas.width / 2 - approachingWidth / 2, canvas.height / 2 + 165);
                    
                    // Reset shadow effects
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 11: "Switch my current To AC to DC" / "切换我的电流 从交流到直流"
        function scene11() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const acWave = {
                amplitude: 50,
                frequency: 0.05,
                offset: 0
            };
            const dcLevel = {
                value: 0
            };
            const currentMeter = {
                angle: 0
            };
            const electronFlow = {
                progress: 0
            };
            const circuitElements = {
                opacity: 0
            };
            const voltageDisplay = {
                value: 0
            };

            timeline.to(circuitElements, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circuit background (dark grey)
                    ctx.fillStyle = `rgba(50, 50, 50, ${circuitElements.opacity})`;
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 150, 400, 300);
                    
                    // Draw circuit lines (medium grey)
                    ctx.strokeStyle = `rgba(100, 100, 100, ${circuitElements.opacity})`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 180, canvas.height/2 - 130, 360, 260);
                    
                    // Draw circuit components (light grey)
                    ctx.fillStyle = `rgba(170, 170, 170, ${circuitElements.opacity})`;
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 + 90, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 + 90, 60, 20);
                }
            })
            .to(acWave, {
                offset: Math.PI * 2,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circuit background
                    ctx.fillStyle = 'rgba(50, 50, 50, 1)';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 150, 400, 300);
                    
                    // Draw circuit lines
                    ctx.strokeStyle = 'rgba(100, 100, 100, 1)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 180, canvas.height/2 - 130, 360, 260);
                    
                    // Draw circuit components
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 + 90, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 + 90, 60, 20);

                    // Draw AC waveform with gradient
                    const gradient = ctx.createLinearGradient(canvas.width/2 - 150, 0, canvas.width/2 + 150, 0);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 150, canvas.height/2);
                    for (let x = 0; x < 300; x += 5) {
                        const y = canvas.height/2 + Math.sin(x * acWave.frequency + acWave.offset) * acWave.amplitude;
                        ctx.lineTo(canvas.width/2 - 150 + x, y);
                    }
                    ctx.stroke();

                    // Draw electrons with glow effect
                    for (let i = 0; i < 20; i++) {
                        const x = (electronFlow.progress * 300 + i * 15) % 300;
                        const y = canvas.height/2 + Math.sin(x * acWave.frequency + acWave.offset) * acWave.amplitude;
                        
                        // Glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(canvas.width/2 - 150 + x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // AC label
                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px monospace';
                    ctx.fillText('AC', canvas.width/2 - 20, canvas.height/2 - 100);
                }
            })
            .to(dcLevel, {
                value: 1,
                duration: 0.5,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circuit background
                    ctx.fillStyle = 'rgba(50, 50, 50, 1)';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 150, 400, 300);
                    
                    // Draw circuit lines
                    ctx.strokeStyle = 'rgba(100, 100, 100, 1)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 180, canvas.height/2 - 130, 360, 260);
                    
                    // Draw circuit components
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 + 90, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 + 90, 60, 20);

                    // Transition from AC to DC
                    const gradient = ctx.createLinearGradient(canvas.width/2 - 150, 0, canvas.width/2 + 150, 0);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 150, canvas.height/2);
                    for (let x = 0; x < 300; x += 5) {
                        const y = canvas.height/2 + Math.sin(x * acWave.frequency + acWave.offset) * acWave.amplitude * (1 - dcLevel.value);
                        ctx.lineTo(canvas.width/2 - 150 + x, y);
                    }
                    ctx.stroke();

                    // Draw DC line with gradient
                    const dcGradient = ctx.createLinearGradient(canvas.width/2 - 150, 0, canvas.width/2 + 150, 0);
                    dcGradient.addColorStop(0, 'rgba(100, 100, 100, 0.5)');
                    dcGradient.addColorStop(0.5, 'rgba(150, 150, 150, 1)');
                    dcGradient.addColorStop(1, 'rgba(100, 100, 100, 0.5)');
                    
                    ctx.strokeStyle = dcGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 150, canvas.height/2 + dcLevel.value * 30);
                    ctx.lineTo(canvas.width/2 + 150, canvas.height/2 + dcLevel.value * 30);
                    ctx.stroke();

                    // Draw electrons with glow effect
                    for (let i = 0; i < 20; i++) {
                        const x = (electronFlow.progress * 300 + i * 15) % 300;
                        const y = canvas.height/2 + Math.sin(x * acWave.frequency + acWave.offset) * acWave.amplitude * (1 - dcLevel.value) + dcLevel.value * 30;
                        
                        // Glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(canvas.width/2 - 150 + x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Transition label
                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px monospace';
                    ctx.fillText('AC→DC', canvas.width/2 - 30, canvas.height/2 - 100);
                }
            })
            .to(voltageDisplay, {
                value: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circuit background
                    ctx.fillStyle = 'rgba(50, 50, 50, 1)';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 150, 400, 300);
                    
                    // Draw circuit lines
                    ctx.strokeStyle = 'rgba(100, 100, 100, 1)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 180, canvas.height/2 - 130, 360, 260);
                    
                    // Draw circuit components
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 + 90, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 + 90, 60, 20);

                    // Draw DC line with gradient
                    const dcGradient = ctx.createLinearGradient(canvas.width/2 - 150, 0, canvas.width/2 + 150, 0);
                    dcGradient.addColorStop(0, 'rgba(100, 100, 100, 0.5)');
                    dcGradient.addColorStop(0.5, 'rgba(150, 150, 150, 1)');
                    dcGradient.addColorStop(1, 'rgba(100, 100, 100, 0.5)');
                    
                    ctx.strokeStyle = dcGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 150, canvas.height/2 + 30);
                    ctx.lineTo(canvas.width/2 + 150, canvas.height/2 + 30);
                    ctx.stroke();

                    // Draw electrons with glow effect
                    for (let i = 0; i < 20; i++) {
                        const x = (electronFlow.progress * 300 + i * 15) % 300;
                        const y = canvas.height/2 + 30;
                        
                        // Glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(canvas.width/2 - 150 + x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // DC label
                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px monospace';
                    ctx.fillText('DC', canvas.width/2 - 20, canvas.height/2 - 100);
                    
                    // Voltage display
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(canvas.width/2 - 60, canvas.height/2 + 60, 120, 40);
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '18px monospace';
                    ctx.fillText('12V DC', canvas.width/2 - 25, canvas.height/2 + 85);
                }
            })
            .to(currentMeter, {
                angle: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw circuit background
                    ctx.fillStyle = 'rgba(50, 50, 50, 1)';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 150, 400, 300);
                    
                    // Draw circuit lines
                    ctx.strokeStyle = 'rgba(100, 100, 100, 1)';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(canvas.width/2 - 180, canvas.height/2 - 130, 360, 260);
                    
                    // Draw circuit components
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 - 110, 60, 20);
                    ctx.fillRect(canvas.width/2 - 160, canvas.height/2 + 90, 60, 20);
                    ctx.fillRect(canvas.width/2 + 100, canvas.height/2 + 90, 60, 20);

                    // Draw DC line with gradient
                    const dcGradient = ctx.createLinearGradient(canvas.width/2 - 150, 0, canvas.width/2 + 150, 0);
                    dcGradient.addColorStop(0, 'rgba(100, 100, 100, 0.5)');
                    dcGradient.addColorStop(0.5, 'rgba(150, 150, 150, 1)');
                    dcGradient.addColorStop(1, 'rgba(100, 100, 100, 0.5)');
                    
                    ctx.strokeStyle = dcGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - 150, canvas.height/2 + 30);
                    ctx.lineTo(canvas.width/2 + 150, canvas.height/2 + 30);
                    ctx.stroke();

                    // Draw electrons with glow effect
                    for (let i = 0; i < 20; i++) {
                        const x = (electronFlow.progress * 300 + i * 15) % 300;
                        const y = canvas.height/2 + 30;
                        
                        // Glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(canvas.width/2 - 150 + x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // DC label
                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px monospace';
                    ctx.fillText('DC', canvas.width/2 - 20, canvas.height/2 - 100);
                    
                    // Voltage display
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(canvas.width/2 - 60, canvas.height/2 + 60, 120, 40);
                    
                    ctx.fillStyle = '#000';
                    ctx.font = '18px monospace';
                    ctx.fillText('12V DC', canvas.width/2 - 25, canvas.height/2 + 85);

                    // Draw current meter with enhanced styling
                    ctx.save();
                    ctx.translate(canvas.width/2 + 150, canvas.height/2);
                    
                    // Meter background
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, Math.PI, 0);
                    ctx.fill();
                    
                    // Meter arc
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, Math.PI, 0);
                    ctx.stroke();
                    
                    // Meter scale marks
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 10; i++) {
                        const angle = Math.PI + (i / 10) * Math.PI;
                        ctx.beginPath();
                        ctx.moveTo(60 * Math.cos(angle), 60 * Math.sin(angle));
                        ctx.lineTo(55 * Math.cos(angle), 55 * Math.sin(angle));
                        ctx.stroke();
                    }
                    
                    // Meter pointer with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(60 * Math.cos(Math.PI + currentMeter.angle * Math.PI), 60 * Math.sin(Math.PI + currentMeter.angle * Math.PI));
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Meter labels
                    ctx.fillStyle = '#AAA';
                    ctx.font = '10px monospace';
                    ctx.fillText('0', -5, 5);
                    ctx.fillText('5A', 45, 5);
                    ctx.fillText('10A', 45, -45);
                    
                    ctx.restore();
                }
            }, "-=0.5");

            return timeline;
        }

        // Scene 12: "And then blind my vision So dizzy so dizzy" / "然后蒙上我的眼睛 头晕目眩"
        function scene12() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const distort = {
                value: 0
            };
            const rgbOffset = {
                x: 0,
                y: 0
            };
            const stars = [];
            for (let i = 0; i < 12; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    rotation: Math.random() * Math.PI * 2,
                    opacity: 0,
                    scale: 0
                });
            }
            const blurAmount = {
                value: 0
            };
            const vortexRotation = {
                angle: 0
            };
            const tunnelDepth = {
                value: 0
            };

            timeline.to(distort, {
                value: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Create base image with grid pattern
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw grid pattern
                    tempCtx.fillStyle = '#000';
                    tempCtx.fillRect(0, 0, canvas.width, canvas.height);
                    tempCtx.strokeStyle = '#333';
                    tempCtx.lineWidth = 1;
                    
                    for (let x = 0; x < canvas.width; x += 20) {
                        tempCtx.beginPath();
                        tempCtx.moveTo(x, 0);
                        tempCtx.lineTo(x, canvas.height);
                        tempCtx.stroke();
                    }
                    
                    for (let y = 0; y < canvas.height; y += 20) {
                        tempCtx.beginPath();
                        tempCtx.moveTo(0, y);
                        tempCtx.lineTo(canvas.width, y);
                        tempCtx.stroke();
                    }
                    
                    // Add some text to distort
                    tempCtx.fillStyle = '#666';
                    tempCtx.font = '30px monospace';
                    tempCtx.fillText('DISTORTION', canvas.width/2 - 80, canvas.height/2);

                    // Apply wave distortion
                    const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const waveX = Math.sin(y * 0.05 + timeline.time() * 2) * 10 * distort.value;
                            const waveY = Math.cos(x * 0.05 + timeline.time() * 2) * 10 * distort.value;
                            const sourceX = Math.floor(x + waveX);
                            const sourceY = Math.floor(y + waveY);

                            if (sourceX >= 0 && sourceX < canvas.width && sourceY >= 0 && sourceY < canvas.height) {
                                const sourceIndex = (sourceY * canvas.width + sourceX) * 4;
                                const targetIndex = (y * canvas.width + x) * 4;
                                
                                // Copy pixel with grayscale conversion
                                const gray = (data[sourceIndex] * 0.299 + data[sourceIndex + 1] * 0.587 + data[sourceIndex + 2] * 0.114);
                                data[targetIndex] = gray;
                                data[targetIndex + 1] = gray;
                                data[targetIndex + 2] = gray;
                                data[targetIndex + 3] = data[sourceIndex + 3];
                            }
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                }
            })
            .to(rgbOffset, {
                x: 10,
                y: 10,
                duration: 1,
                ease: "power1.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Create base image with pattern
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw concentric circles
                    tempCtx.fillStyle = '#000';
                    tempCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    for (let i = 0; i < 20; i++) {
                        tempCtx.strokeStyle = `rgba(${100 + i * 5}, ${100 + i * 5}, ${100 + i * 5}, 0.5)`;
                        tempCtx.lineWidth = 2;
                        tempCtx.beginPath();
                        tempCtx.arc(canvas.width/2, canvas.height/2, 20 + i * 15, 0, Math.PI * 2);
                        tempCtx.stroke();
                    }
                    
                    // Add text
                    tempCtx.fillStyle = '#AAA';
                    tempCtx.font = '40px monospace';
                    tempCtx.fillText('DIZZY', canvas.width/2 - 60, canvas.height/2);

                    // Apply RGB separation with grayscale offsets
                    const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Draw with offsets, using different shades of grey for each "channel"
                    ctx.globalAlpha = 0.7;
                    
                    // First offset (simulating red channel)
                    const offsetCanvas1 = document.createElement('canvas');
                    offsetCanvas1.width = canvas.width;
                    offsetCanvas1.height = canvas.height;
                    const offsetCtx1 = offsetCanvas1.getContext('2d');
                    offsetCtx1.putImageData(imageData, 0, 0);
                    
                    // Apply grayscale to first offset
                    const imageData1 = offsetCtx1.getImageData(0, 0, canvas.width, canvas.height);
                    const data1 = imageData1.data;
                    for (let i = 0; i < data1.length; i += 4) {
                        const gray = (data1[i] * 0.299 + data1[i + 1] * 0.587 + data1[i + 2] * 0.114);
                        data1[i] = gray;
                        data1[i + 1] = gray * 0.8; // Slightly darker
                        data1[i + 2] = gray * 0.8; // Slightly darker
                    }
                    offsetCtx1.putImageData(imageData1, 0, 0);
                    ctx.drawImage(offsetCanvas1, rgbOffset.x, rgbOffset.y, canvas.width, canvas.height);
                    
                    // Second offset (simulating blue channel)
                    const offsetCanvas2 = document.createElement('canvas');
                    offsetCanvas2.width = canvas.width;
                    offsetCanvas2.height = canvas.height;
                    const offsetCtx2 = offsetCanvas2.getContext('2d');
                    offsetCtx2.putImageData(imageData, 0, 0);
                    
                    // Apply grayscale to second offset
                    const imageData2 = offsetCtx2.getImageData(0, 0, canvas.width, canvas.height);
                    const data2 = imageData2.data;
                    for (let i = 0; i < data2.length; i += 4) {
                        const gray = (data2[i] * 0.299 + data2[i + 1] * 0.587 + data2[i + 2] * 0.114);
                        data2[i] = gray * 0.8; // Slightly darker
                        data2[i + 1] = gray * 0.8; // Slightly darker
                        data2[i + 2] = gray;
                    }
                    offsetCtx2.putImageData(imageData2, 0, 0);
                    ctx.drawImage(offsetCanvas2, -rgbOffset.x, -rgbOffset.y, canvas.width, canvas.height);
                    
                    ctx.globalAlpha = 1;
                    ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height); // Original image

                    // Draw blinking stars with enhanced effect
                    stars.forEach(s => {
                        ctx.save();
                        ctx.translate(s.x, s.y);
                        ctx.rotate(s.rotation);
                        ctx.scale(s.scale, s.scale);
                        
                        // Glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 10 * Math.sin(timeline.time() * 10) * 0.5 + 5;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${Math.sin(timeline.time() * 10) * 0.5 + 0.5})`;
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 15, -Math.sin((18 + i * 72) / 180 * Math.PI) * 15);
                            ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 7, -Math.sin((54 + i * 72) / 180 * Math.PI) * 7);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    });
                }
            }, "-=0.5")
            .to(vortexRotation, {
                angle: Math.PI * 2,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw vortex effect
                    ctx.save();
                    ctx.translate(canvas.width/2, canvas.height/2);
                    ctx.rotate(vortexRotation.angle);
                    
                    // Draw spiral
                    for (let i = 0; i < 100; i++) {
                        const angle = i * 0.2;
                        const radius = i * 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        ctx.fillStyle = `rgba(${100 + i % 100}, ${100 + i % 100}, ${100 + i % 100}, ${1 - i/100})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 5 - i/20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                    
                    // Add text in center
                    ctx.fillStyle = '#FFF';
                    ctx.font = '30px monospace';
                    ctx.fillText('SPINNING', canvas.width/2 - 70, canvas.height/2);
                }
            }, "-=0.5")
            .to(tunnelDepth, {
                value: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw tunnel effect
                    for (let i = 0; i < 20; i++) {
                        const size = 300 - i * 15 * tunnelDepth.value;
                        const opacity = 1 - i / 20;
                        
                        ctx.strokeStyle = `rgba(${100 + i * 5}, ${100 + i * 5}, ${100 + i * 5}, ${opacity})`;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            canvas.width/2 - size/2, 
                            canvas.height/2 - size/2, 
                            size, 
                            size
                        );
                    }
                    
                    // Add text in center
                    ctx.fillStyle = '#FFF';
                    ctx.font = '30px monospace';
                    ctx.fillText('TUNNEL', canvas.width/2 - 60, canvas.height/2);
                }
            }, "-=0.5")
            .to(blurAmount, {
                value: 10,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.filter = `blur(${blurAmount.value}px)`;
                    
                    // Draw some shapes to blur
                    ctx.fillStyle = '#666';
                    ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 50, 200, 100);
                    
                    ctx.fillStyle = '#AAA';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2, canvas.height/2, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '40px monospace';
                    const dizzyText = 'DIZZY';
                    const dizzyTextWidth = ctx.measureText(dizzyText).width;
                    ctx.fillText(dizzyText, canvas.width / 2 - dizzyTextWidth / 2, canvas.height / 2);
                    
                    ctx.filter = "none"; // Reset filter for subsequent draws
                }
            });

            return timeline;
        }

        // Scene 13: "Oh we can travel To A.D to B.C" / "我们可以穿越时空 从未来到过去"
        function scene13() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const timeAxis = {
                progress: 0
            };
            const eventsOpacity = {
                opacity: 0
            };
            const tunnelRotation = {
                angle: 0
            };
            const hourglass = {
                fill: 1
            };
            const timeParticles = [];
            for (let i = 0; i < 30; i++) {
                timeParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 2 + 1,
                    opacity: 0
                });
            }
            const eventMarkers = [
                { year: 1969, label: "Moon Landing", x: 0.3, opacity: 0 },
                { year: 1989, label: "Fall of Berlin Wall", x: 0.5, opacity: 0 },
                { year: 2001, label: "9/11", x: 0.7, opacity: 0 }
            ];

            timeline.to(timeAxis, {
                progress: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw time axis with gradient
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2, canvas.width, canvas.height / 2);
                    gradient.addColorStop(0, '#333');
                    gradient.addColorStop(0.5, '#AAA');
                    gradient.addColorStop(1, '#333');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width * (1 - timeAxis.progress), canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();

                    // Markers for AD/BC with background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(canvas.width * 0.2 - 20, canvas.height / 2 - 30, 40, 25);
                    ctx.fillRect(canvas.width * 0.8 - 20, canvas.height / 2 - 30, 40, 25);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '18px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('BC', canvas.width * 0.2, canvas.height / 2 - 10);
                    ctx.fillText('AD', canvas.width * 0.8, canvas.height / 2 - 10);
                    
                    // Draw time particles
                    const indicatorX = canvas.width * timeAxis.progress;
                    timeParticles.forEach(p => {
                        if (Math.abs(p.x - indicatorX) < 100) {
                            p.opacity = Math.min(1, p.opacity + 0.05);
                            p.y -= p.speed;
                            
                            if (p.y < 0) {
                                p.y = canvas.height;
                                p.x = indicatorX + (Math.random() - 0.5) * 100;
                            }
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                }
            })
            .to(eventsOpacity, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw time axis with gradient
                    const gradient = ctx.createLinearGradient(0, canvas.height / 2, canvas.width, canvas.height / 2);
                    gradient.addColorStop(0, '#333');
                    gradient.addColorStop(0.5, '#AAA');
                    gradient.addColorStop(1, '#333');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                    
                    // Markers for AD/BC with background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(canvas.width * 0.2 - 20, canvas.height / 2 - 30, 40, 25);
                    ctx.fillRect(canvas.width * 0.8 - 20, canvas.height / 2 - 30, 40, 25);
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '18px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('BC', canvas.width * 0.2, canvas.height / 2 - 10);
                    ctx.fillText('AD', canvas.width * 0.8, canvas.height / 2 - 10);

                    // Draw historical event markers with enhanced styling
                    eventMarkers.forEach(event => {
                        const x = canvas.width * event.x;
                        const y = canvas.height / 2 - 20;
                        
                        // Draw marker line
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y - 10);
                        ctx.lineTo(x, y + 10);
                        ctx.stroke();
                        
                        // Draw event circle with glow
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5 * event.opacity;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${event.opacity})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Reset shadow
                        ctx.shadowBlur = 0;
                        
                        // Draw event label with background
                        if (event.opacity > 0) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${event.opacity * 0.2})`;
                            const labelWidth = ctx.measureText(event.label).width + 10;
                            ctx.fillRect(x - labelWidth/2, y + 15, labelWidth, 20);
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${event.opacity})`;
                            ctx.font = '12px monospace';
                            ctx.fillText(event.label, x, y + 28);
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${event.opacity * 0.7})`;
                            ctx.font = '10px monospace';
                            ctx.fillText(event.year, x, y + 40);
                        }
                    });
                }
            }, "-=0.5")
            .to(eventMarkers, {
                duration: 0.5,
                opacity: 1
            }, "-=1")
            .to(tunnelRotation, {
                angle: Math.PI * 4,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw time tunnel with enhanced effect
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(tunnelRotation.angle);
                    
                    // Draw spiral tunnel with gradient
                    for (let i = 0; i < 20; i++) {
                        const radius = 10 + i * 10;
                        const opacity = 1 - i / 20;
                        
                        ctx.strokeStyle = `rgba(${100 + i * 5}, ${100 + i * 5}, ${100 + i * 5}, ${opacity})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                            const x = Math.cos(angle + i * 0.1) * radius;
                            const y = Math.sin(angle + i * 0.1) * radius;
                            
                            if (angle === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                    ctx.restore();
                    
                    // Draw time particles in tunnel
                    timeParticles.forEach(p => {
                        p.opacity = Math.random() * 0.5 + 0.5;
                        p.x = canvas.width / 2 + (Math.random() - 0.5) * 300;
                        p.y = canvas.height / 2 + (Math.random() - 0.5) * 300;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw time text with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('TIME TRAVEL', canvas.width / 2, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(hourglass, {
                fill: 0,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw hourglass with enhanced styling
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2 + 100;
                    const width = 60;
                    const height = 100;
                    
                    // Draw hourglass frame with gradient
                    const frameGradient = ctx.createLinearGradient(centerX - width/2, centerY - height/2, centerX + width/2, centerY + height/2);
                    frameGradient.addColorStop(0, '#666');
                    frameGradient.addColorStop(0.5, '#AAA');
                    frameGradient.addColorStop(1, '#666');
                    
                    ctx.strokeStyle = frameGradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - width / 2, centerY - height / 2);
                    ctx.lineTo(centerX + width / 2, centerY - height / 2);
                    ctx.lineTo(centerX + width / 4, centerY);
                    ctx.lineTo(centerX + width / 2, centerY + height / 2);
                    ctx.lineTo(centerX - width / 2, centerY + height / 2);
                    ctx.lineTo(centerX - width / 4, centerY);
                    ctx.closePath();
                    ctx.stroke();

                    // Draw sand with gradient
                    const sandGradient = ctx.createLinearGradient(centerX - width/2, centerY - height/2, centerX + width/2, centerY + height/2);
                    sandGradient.addColorStop(0, '#AAA');
                    sandGradient.addColorStop(1, '#666');
                    
                    ctx.fillStyle = sandGradient;
                    
                    // Top sand
                    ctx.beginPath();
                    ctx.moveTo(centerX - width / 2, centerY - height / 2);
                    ctx.lineTo(centerX + width / 2, centerY - height / 2);
                    ctx.lineTo(centerX + (width / 4 - (width / 4) * hourglass.fill), centerY - height / 2 + (height / 2) * (1 - hourglass.fill));
                    ctx.lineTo(centerX - (width / 4 - (width / 4) * hourglass.fill), centerY - height / 2 + (height / 2) * (1 - hourglass.fill));
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bottom sand
                    ctx.beginPath();
                    ctx.moveTo(centerX - width / 2, centerY + height / 2);
                    ctx.lineTo(centerX + width / 2, centerY + height / 2);
                    ctx.lineTo(centerX + (width / 4 - (width / 4) * (1 - hourglass.fill)), centerY + height / 2 - (height / 2) * (1 - hourglass.fill));
                    ctx.lineTo(centerX - (width / 4 - (width / 4) * (1 - hourglass.fill)), centerY + height / 2 - (height / 2) * (1 - hourglass.fill));
                    ctx.closePath();
                    ctx.fill();

                    // Draw falling sand particles
                    for (let i = 0; i < 20; i++) {
                        const particleY = centerY - height / 2 + (height / 2) * (1 - hourglass.fill) + (i * 3);
                        const particleX = centerX + (Math.random() - 0.5) * 10;
                        
                        ctx.fillStyle = '#AAA';
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw time text with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('TIME IS RUNNING OUT', centerX, centerY + height / 2 + 20);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 14: "And we can unite So deeply so deeply" / "然后成为一体 深深入髓"
        function scene14() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    type: Math.random() > 0.5 ? 'A' : 'B', // Two types of particles
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    glow: Math.random() * 0.5 + 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1
                });
            }
            const fusionProgress = {
                value: 0
            };
            const dnaRotation = {
                angle: 0
            };
            const neuronOpacity = {
                opacity: 0
            };

            timeline.to(fusionProgress, {
                value: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw particles with enhanced effects
                    particles.forEach(p => {
                        // Move particles towards center
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const dx = centerX - p.x;
                        const dy = centerY - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 10) {
                            p.x += dx * 0.02 * fusionProgress.value;
                            p.y += dy * 0.02 * fusionProgress.value;
                        }
                        
                        p.rotation += p.rotationSpeed;
                        
                        // Draw particle with glow and rotation
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        
                        // Glow effect
                        ctx.shadowColor = p.type === 'A' ? '#AAA' : '#666';
                        ctx.shadowBlur = 5 * p.glow;
                        
                        // Particle gradient
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size);
                        if (p.type === 'A') {
                            gradient.addColorStop(0, '#FFF');
                            gradient.addColorStop(0.7, '#AAA');
                            gradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                        } else {
                            gradient.addColorStop(0, '#AAA');
                            gradient.addColorStop(0.7, '#666');
                            gradient.addColorStop(1, 'rgba(102, 102, 102, 0)');
                        }
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    });

                    // Draw fused particles with enhanced effect
                    if (fusionProgress.value > 0.3) {
                        const fusionSize = 50 * fusionProgress.value;
                        
                        // Fusion glow
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 20;
                        
                        // Fusion gradient
                        const fusionGradient = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, 0,
                            canvas.width / 2, canvas.height / 2, fusionSize
                        );
                        fusionGradient.addColorStop(0, '#FFF');
                        fusionGradient.addColorStop(0.5, '#AAA');
                        fusionGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                        
                        ctx.fillStyle = fusionGradient;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2, canvas.height / 2, fusionSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    }
                }
            })
            .to({}, { // Molecular bonding (H2O) with enhanced styling
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw H2O molecule with enhanced effects
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Draw oxygen atom with gradient
                    const oGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 20);
                    oGradient.addColorStop(0, '#FFF');
                    oGradient.addColorStop(0.7, '#AAA');
                    oGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                    
                    ctx.fillStyle = oGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw hydrogen atoms with gradient
                    const hGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
                    hGradient.addColorStop(0, '#CCC');
                    hGradient.addColorStop(0.7, '#AAA');
                    hGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                    
                    ctx.fillStyle = hGradient;
                    ctx.beginPath();
                    ctx.arc(centerX - 30, centerY - 20, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + 30, centerY - 20, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw chemical bonds with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 10, centerY - 10);
                    ctx.lineTo(centerX - 20, centerY - 15);
                    ctx.moveTo(centerX + 10, centerY - 10);
                    ctx.lineTo(centerX + 20, centerY - 15);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Draw atom labels
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('O', centerX, centerY);
                    ctx.fillText('H', centerX - 30, centerY - 20);
                    ctx.fillText('H', centerX + 30, centerY - 20);
                    
                    // Draw molecule name with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('H₂O', centerX, centerY + 50);
                    ctx.shadowBlur = 0;
                }
            })
            .to(dnaRotation, {
                angle: Math.PI * 2,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw DNA double helix with enhanced effect
                    const dnaX = canvas.width / 2;
                    const dnaY = canvas.height / 2;
                    const dnaRadius = 30;
                    const dnaHeight = 100;

                    // Draw helix strands with gradient
                    const strandGradient = ctx.createLinearGradient(dnaX - dnaRadius, dnaY - dnaHeight/2, dnaX + dnaRadius, dnaY + dnaHeight/2);
                    strandGradient.addColorStop(0, '#666');
                    strandGradient.addColorStop(0.5, '#AAA');
                    strandGradient.addColorStop(1, '#666');
                    
                    ctx.strokeStyle = strandGradient;
                    ctx.lineWidth = 3;
                    
                    // First strand
                    ctx.beginPath();
                    for (let y = -dnaHeight / 2; y <= dnaHeight / 2; y += 5) {
                        const x1 = dnaX + dnaRadius * Math.sin(y * 0.1 + dnaRotation.angle);
                        const x2 = dnaX + dnaRadius * Math.sin(y * 0.1 + dnaRotation.angle + Math.PI);
                        
                        if (y === -dnaHeight / 2) {
                            ctx.moveTo(x1, dnaY + y);
                        } else {
                            ctx.lineTo(x1, dnaY + y);
                        }
                    }
                    ctx.stroke();
                    
                    // Second strand
                    ctx.beginPath();
                    for (let y = -dnaHeight / 2; y <= dnaHeight / 2; y += 5) {
                        const x2 = dnaX + dnaRadius * Math.sin(y * 0.1 + dnaRotation.angle + Math.PI);
                        
                        if (y === -dnaHeight / 2) {
                            ctx.moveTo(x2, dnaY + y);
                        } else {
                            ctx.lineTo(x2, dnaY + y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw base pairs with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    
                    for (let y = -dnaHeight / 2; y <= dnaHeight / 2; y += 10) {
                        const x1 = dnaX + dnaRadius * Math.sin(y * 0.1 + dnaRotation.angle);
                        const x2 = dnaX + dnaRadius * Math.sin(y * 0.1 + dnaRotation.angle + Math.PI);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, dnaY + y);
                        ctx.lineTo(x2, dnaY + y);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                    
                    // Draw DNA label with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '24px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('DNA', dnaX, dnaY + dnaHeight / 2 + 30);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 15: "If I can give you all the STIMULATIONS" / "如果我能够献给你 所有的刺激"
        function scene15() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const neuronOpacity = {
                opacity: 0
            };
            const sensorIcons = {
                eye: { opacity: 0, scale: 0 },
                ear: { opacity: 0, scale: 0 },
                hand: { opacity: 0, scale: 0 }
            };
            const signalProgress = {
                value: 0
            };
            const brainActivation = {
                level: 0
            };
            const neuralPulses = [];
            for (let i = 0; i < 5; i++) {
                neuralPulses.push({
                    x: 0,
                    y: 0,
                    radius: 0,
                    opacity: 0,
                    speed: 0.01 + Math.random() * 0.02
                });
            }

            timeline.to(neuronOpacity, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw enhanced neuron with gradient and glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Neuron glow
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10 * neuronOpacity.opacity;
                    
                    // Neuron gradient
                    const neuronGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 25);
                    neuronGradient.addColorStop(0, `rgba(255, 255, 255, ${neuronOpacity.opacity})`);
                    neuronGradient.addColorStop(0.7, `rgba(204, 204, 204, ${neuronOpacity.opacity})`);
                    neuronGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                    
                    ctx.fillStyle = neuronGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Neuron outline
                    ctx.strokeStyle = `rgba(204, 204, 204, ${neuronOpacity.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw dendrites with glow
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = `rgba(170, 170, 170, ${neuronOpacity.opacity})`;
                    ctx.lineWidth = 1.5;
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    // Draw axon with glow
                    ctx.strokeStyle = `rgba(204, 204, 204, ${neuronOpacity.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    
                    // Draw axon terminal with glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${neuronOpacity.opacity})`;
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(sensorIcons.eye, {
                opacity: 1,
                scale: 1,
                duration: 0.3,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw neuron (static)
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;

                    // Draw enhanced eye icon with glow and gradient
                    ctx.save();
                    ctx.translate(centerX - 100, centerY - 50);
                    ctx.scale(sensorIcons.eye.scale, sensorIcons.eye.scale);
                    ctx.globalAlpha = sensorIcons.eye.opacity;
                    
                    // Eye glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    
                    // Eye gradient
                    const eyeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                    eyeGradient.addColorStop(0, '#FFF');
                    eyeGradient.addColorStop(0.7, '#CCC');
                    eyeGradient.addColorStop(1, 'rgba(204, 204, 204, 0)');
                    
                    ctx.fillStyle = eyeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye outline
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Iris and pupil with glow
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', 0, 30);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "+=0.1")
            .to(sensorIcons.ear, {
                opacity: 1,
                scale: 1,
                duration: 0.3,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw eye icon
                    ctx.save();
                    ctx.translate(centerX - 100, centerY - 50);
                    ctx.globalAlpha = sensorIcons.eye.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', 0, 30);
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw enhanced ear icon with glow
                    ctx.save();
                    ctx.translate(centerX - 100, centerY);
                    ctx.scale(sensorIcons.ear.scale, sensorIcons.ear.scale);
                    ctx.globalAlpha = sensorIcons.ear.opacity;
                    
                    // Ear glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    
                    // Ear gradient
                    const earGradient = ctx.createLinearGradient(-10, -20, 20, 20);
                    earGradient.addColorStop(0, '#FFF');
                    earGradient.addColorStop(0.5, '#CCC');
                    earGradient.addColorStop(1, '#AAA');
                    
                    ctx.fillStyle = earGradient;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Ear outline
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Inner ear detail
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    
                    // Ear label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EAR', 0, 40);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "+=0.1")
            .to(sensorIcons.hand, {
                opacity: 1,
                scale: 1,
                duration: 0.3,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw eye icon
                    ctx.save();
                    ctx.translate(centerX - 100, centerY - 50);
                    ctx.globalAlpha = sensorIcons.eye.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', 0, 30);
                    ctx.restore();
                    
                    // Redraw ear icon
                    ctx.save();
                    ctx.translate(centerX - 100, centerY);
                    ctx.globalAlpha = sensorIcons.ear.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const earGradient = ctx.createLinearGradient(-10, -20, 20, 20);
                    earGradient.addColorStop(0, '#FFF');
                    earGradient.addColorStop(0.5, '#CCC');
                    earGradient.addColorStop(1, '#AAA');
                    ctx.fillStyle = earGradient;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EAR', 0, 40);
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw enhanced hand icon with glow
                    ctx.save();
                    ctx.translate(centerX - 100, centerY + 50);
                    ctx.scale(sensorIcons.hand.scale, sensorIcons.hand.scale);
                    ctx.globalAlpha = sensorIcons.hand.opacity;
                    
                    // Hand glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    
                    // Hand gradient
                    const handGradient = ctx.createLinearGradient(0, 0, 50, -35);
                    handGradient.addColorStop(0, '#FFF');
                    handGradient.addColorStop(0.5, '#CCC');
                    handGradient.addColorStop(1, '#AAA');
                    
                    ctx.strokeStyle = handGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(10, -20);
                    ctx.lineTo(20, -10);
                    ctx.lineTo(25, -25);
                    ctx.lineTo(30, -15);
                    ctx.lineTo(35, -30);
                    ctx.lineTo(40, -20);
                    ctx.lineTo(45, -35);
                    ctx.lineTo(50, -25);
                    ctx.stroke();
                    
                    // Palm detail
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hand label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('TOUCH', 25, 15);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "+=0.1")
            .to(signalProgress, {
                value: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw sensor icons
                    ctx.save();
                    ctx.translate(centerX - 100, centerY - 50);
                    ctx.globalAlpha = sensorIcons.eye.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', 0, 30);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX - 100, centerY);
                    ctx.globalAlpha = sensorIcons.ear.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const earGradient = ctx.createLinearGradient(-10, -20, 20, 20);
                    earGradient.addColorStop(0, '#FFF');
                    earGradient.addColorStop(0.5, '#CCC');
                    earGradient.addColorStop(1, '#AAA');
                    ctx.fillStyle = earGradient;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EAR', 0, 40);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX - 100, centerY + 50);
                    ctx.globalAlpha = sensorIcons.hand.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const handGradient = ctx.createLinearGradient(0, 0, 50, -35);
                    handGradient.addColorStop(0, '#FFF');
                    handGradient.addColorStop(0.5, '#CCC');
                    handGradient.addColorStop(1, '#AAA');
                    ctx.strokeStyle = handGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(10, -20);
                    ctx.lineTo(20, -10);
                    ctx.lineTo(25, -25);
                    ctx.lineTo(30, -15);
                    ctx.lineTo(35, -30);
                    ctx.lineTo(40, -20);
                    ctx.lineTo(45, -35);
                    ctx.lineTo(50, -25);
                    ctx.stroke();
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('TOUCH', 25, 15);
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw enhanced signal with glow and pulses
                    const signalX = centerX - 100 + signalProgress.value * 170;
                    
                    // Signal glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    
                    // Signal gradient
                    const signalGradient = ctx.createLinearGradient(centerX - 100, centerY, signalX, centerY);
                    signalGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    signalGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                    signalGradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
                    
                    ctx.strokeStyle = signalGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, centerY);
                    
                    for (let i = 0; i <= signalProgress.value * 100; i++) {
                        const x = centerX - 100 + i * 1.7;
                        const y = centerY + Math.sin(i * 0.2) * 20 * (1 - signalProgress.value * 0.5);
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Signal pulses
                    for (let i = 0; i < neuralPulses.length; i++) {
                        const pulse = neuralPulses[i];
                        if (signalProgress.value > i * 0.2) {
                            pulse.x = centerX - 100 + (signalProgress.value - i * 0.2) * 170;
                            pulse.y = centerY + Math.sin((signalProgress.value - i * 0.2) * 10) * 20;
                            pulse.radius = 5 + Math.sin(Date.now() * 0.01 + i) * 3;
                            pulse.opacity = 1 - (signalProgress.value - i * 0.2) * 2;
                            
                            if (pulse.opacity > 0) {
                                ctx.fillStyle = `rgba(255, 255, 255, ${pulse.opacity})`;
                                ctx.beginPath();
                                ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                }
            }, "+=0.1")
            .to(brainActivation, {
                level: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const length = 30 + Math.random() * 20;
                        ctx.beginPath();
                        ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                        ctx.lineTo(centerX + Math.cos(angle) * length, centerY + Math.sin(angle) * length);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(centerX + 70, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw sensor icons
                    ctx.save();
                    ctx.translate(centerX - 100, centerY - 50);
                    ctx.globalAlpha = sensorIcons.eye.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EYE', 0, 30);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX - 100, centerY);
                    ctx.globalAlpha = sensorIcons.ear.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const earGradient = ctx.createLinearGradient(-10, -20, 20, 20);
                    earGradient.addColorStop(0, '#FFF');
                    earGradient.addColorStop(0.5, '#CCC');
                    earGradient.addColorStop(1, '#AAA');
                    ctx.fillStyle = earGradient;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#CCC';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, -20);
                    ctx.lineTo(20, -20);
                    ctx.arc(0, 0, 20, -Math.PI / 2, Math.PI / 2);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EAR', 0, 40);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX - 100, centerY + 50);
                    ctx.globalAlpha = sensorIcons.hand.opacity;
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const handGradient = ctx.createLinearGradient(0, 0, 50, -35);
                    handGradient.addColorStop(0, '#FFF');
                    handGradient.addColorStop(0.5, '#CCC');
                    handGradient.addColorStop(1, '#AAA');
                    ctx.strokeStyle = handGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(10, -20);
                    ctx.lineTo(20, -10);
                    ctx.lineTo(25, -25);
                    ctx.lineTo(30, -15);
                    ctx.lineTo(35, -30);
                    ctx.lineTo(40, -20);
                    ctx.lineTo(45, -35);
                    ctx.lineTo(50, -25);
                    ctx.stroke();
                    ctx.fillStyle = '#CCC';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('TOUCH', 25, 15);
                    ctx.restore();
                    
                    // Draw signal
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    const signalGradient = ctx.createLinearGradient(centerX - 100, centerY, centerX + 70, centerY);
                    signalGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    signalGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                    signalGradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
                    ctx.strokeStyle = signalGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, centerY);
                    ctx.lineTo(centerX + 70, centerY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Draw enhanced brain model with activation regions
                    const brainX = centerX + 150;
                    const brainY = centerY;
                    
                    // Brain glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15 * brainActivation.level;
                    
                    // Brain outline with gradient
                    const brainGradient = ctx.createRadialGradient(brainX, brainY, 0, brainX, brainY, 50);
                    brainGradient.addColorStop(0, `rgba(255, 255, 255, ${brainActivation.level * 0.8})`);
                    brainGradient.addColorStop(0.5, `rgba(204, 204, 204, ${brainActivation.level * 0.6})`);
                    brainGradient.addColorStop(1, 'rgba(102, 102, 102, 0)');
                    
                    ctx.fillStyle = brainGradient;
                    ctx.beginPath();
                    ctx.arc(brainX, brainY, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(brainX, brainY, 50, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Brain hemispheres
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(brainX, brainY - 50);
                    ctx.lineTo(brainX, brainY + 50);
                    ctx.stroke();
                    
                    // Activated regions with glow
                    const regions = [
                        { x: brainX + 20, y: brainY - 20, size: 15 },
                        { x: brainX - 20, y: brainY - 20, size: 15 },
                        { x: brainX, y: brainY + 20, size: 15 },
                        { x: brainX, y: brainY, size: 20 }
                    ];
                    
                    regions.forEach((region, i) => {
                        const delay = i * 0.1;
                        const activationLevel = Math.max(0, Math.min(1, (brainActivation.level - delay) / (1 - delay)));
                        
                        if (activationLevel > 0) {
                            // Region glow
                            ctx.shadowColor = '#FFF';
                            ctx.shadowBlur = 10 * activationLevel;
                            
                            // Region gradient
                            const regionGradient = ctx.createRadialGradient(
                                region.x, region.y, 0,
                                region.x, region.y, region.size
                            );
                            regionGradient.addColorStop(0, `rgba(255, 255, 255, ${activationLevel})`);
                            regionGradient.addColorStop(0.7, `rgba(204, 204, 204, ${activationLevel * 0.8})`);
                            regionGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                            
                            ctx.fillStyle = regionGradient;
                            ctx.beginPath();
                            ctx.arc(region.x, region.y, region.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    
                    // Brain label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('BRAIN', brainX, brainY + 70);
                    
                    ctx.shadowBlur = 0;
                }
            }, "+=0.1");

            return timeline;
        }

        // Scene 16: "Then I can be your only SATISFACTION" / "那么我就能够成为你 唯一的满足"
        function scene16() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const heartFill = {
                progress: 0
            };
            const dopamineMolecule = {
                scale: 0,
                rotation: 0
            };
            const satisfactionBar = {
                fill: 0
            };
            const haloOpacity = {
                opacity: 0
            };
            const heartParticles = [];
            for (let i = 0; i < 12; i++) {
                heartParticles.push({
                    x: 0,
                    y: 0,
                    radius: 0,
                    opacity: 0,
                    speed: 0.01 + Math.random() * 0.02,
                    angle: Math.random() * Math.PI * 2
                });
            }

            timeline.to(heartFill, {
                progress: 1,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw enhanced heart with gradient and glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Heart glow
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 15 * heartFill.progress;
                    
                    // Heart gradient
                    const heartGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 60);
                    heartGradient.addColorStop(0, `rgba(255, 255, 255, ${heartFill.progress})`);
                    heartGradient.addColorStop(0.5, `rgba(204, 204, 204, ${heartFill.progress})`);
                    heartGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                    
                    ctx.fillStyle = heartGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Heart outline
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Heart label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('HEART', centerX, centerY + 80);
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(dopamineMolecule, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw heart
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 15;
                    const heartGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 60);
                    heartGradient.addColorStop(0, '#FFF');
                    heartGradient.addColorStop(0.5, '#CCC');
                    heartGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                    ctx.fillStyle = heartGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Draw enhanced dopamine molecule with glow and gradient
                    ctx.save();
                    ctx.translate(centerX + 100, centerY - 50);
                    ctx.rotate(dopamineMolecule.rotation);
                    ctx.scale(dopamineMolecule.scale, dopamineMolecule.scale);
                    
                    // Molecule glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    
                    // Molecule gradient
                    const moleculeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    moleculeGradient.addColorStop(0, '#FFF');
                    moleculeGradient.addColorStop(0.7, '#CCC');
                    moleculeGradient.addColorStop(1, 'rgba(204, 204, 204, 0)');
                    
                    ctx.fillStyle = moleculeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2); // Central atom
                    ctx.fill();
                    
                    // Outer atoms with glow
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, 20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, -20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Chemical bonds with glow
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, 20);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -20);
                    ctx.stroke();
                    
                    // Molecule label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('DA', 0, 35);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(satisfactionBar, {
                fill: 100,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 15;
                    const heartGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 60);
                    heartGradient.addColorStop(0, '#FFF');
                    heartGradient.addColorStop(0.5, '#CCC');
                    heartGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                    ctx.fillStyle = heartGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.save();
                    ctx.translate(centerX + 100, centerY - 50);
                    ctx.rotate(Math.PI * 2);
                    ctx.scale(1, 1);
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    const moleculeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    moleculeGradient.addColorStop(0, '#FFF');
                    moleculeGradient.addColorStop(0.7, '#CCC');
                    moleculeGradient.addColorStop(1, 'rgba(204, 204, 204, 0)');
                    ctx.fillStyle = moleculeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, 20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, -20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, 20);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -20);
                    ctx.stroke();
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('DA', 0, 35);
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw enhanced satisfaction bar with gradient and glow
                    const barWidth = 200;
                    const barHeight = 20;
                    const barX = centerX - barWidth / 2;
                    const barY = centerY + 100;
                    
                    // Bar background with gradient
                    const bgGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    bgGradient.addColorStop(0, '#333');
                    bgGradient.addColorStop(0.5, '#222');
                    bgGradient.addColorStop(1, '#333');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Bar outline
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // Bar fill with gradient and glow
                    const fillWidth = barWidth * (satisfactionBar.fill / 100);
                    if (fillWidth > 0) {
                        ctx.shadowColor = '#AAA';
                        ctx.shadowBlur = 10;
                        
                        const fillGradient = ctx.createLinearGradient(barX, barY, barX + fillWidth, barY);
                        fillGradient.addColorStop(0, '#FFF');
                        fillGradient.addColorStop(0.5, '#CCC');
                        fillGradient.addColorStop(1, '#AAA');
                        
                        ctx.fillStyle = fillGradient;
                        ctx.fillRect(barX, barY, fillWidth, barHeight);
                        
                        // Bar glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5;
                        ctx.strokeStyle = '#FFF';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(barX + fillWidth, barY);
                        ctx.lineTo(barX + fillWidth, barY + barHeight);
                        ctx.stroke();
                        
                        ctx.shadowBlur = 0;
                    }
                    
                    // Bar labels
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('0%', barX - 30, barY + 15);
                    ctx.textAlign = 'right';
                    ctx.fillText('100%', barX + barWidth + 30, barY + 15);
                    ctx.textAlign = 'center';
                    ctx.fillText('SATISFACTION', centerX, barY + 40);
                }
            })
            .to(haloOpacity, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 15;
                    const heartGradient = ctx.createRadialGradient(centerX, centerY - 20, 0, centerX, centerY - 20, 60);
                    heartGradient.addColorStop(0, '#FFF');
                    heartGradient.addColorStop(0.5, '#CCC');
                    heartGradient.addColorStop(1, 'rgba(170, 170, 170, 0)');
                    ctx.fillStyle = heartGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY + 20);
                    ctx.bezierCurveTo(centerX + 40, centerY - 20,
                        centerX + 80, centerY - 20,
                        centerX, centerY - 60);
                    ctx.bezierCurveTo(centerX - 80, centerY - 20,
                        centerX - 40, centerY - 20,
                        centerX, centerY + 20);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.save();
                    ctx.translate(centerX + 100, centerY - 50);
                    ctx.rotate(Math.PI * 2);
                    ctx.scale(1, 1);
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    const moleculeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    moleculeGradient.addColorStop(0, '#FFF');
                    moleculeGradient.addColorStop(0.7, '#CCC');
                    moleculeGradient.addColorStop(1, 'rgba(204, 204, 204, 0)');
                    ctx.fillStyle = moleculeGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(-20, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, 20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, -20, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-20, 0);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, 20);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -20);
                    ctx.stroke();
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('DA', 0, 35);
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    const barWidth = 200;
                    const barHeight = 20;
                    const barX = centerX - barWidth / 2;
                    const barY = centerY + 100;
                    
                    const bgGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    bgGradient.addColorStop(0, '#333');
                    bgGradient.addColorStop(0.5, '#222');
                    bgGradient.addColorStop(1, '#333');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10;
                    const fillGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    fillGradient.addColorStop(0, '#FFF');
                    fillGradient.addColorStop(0.5, '#CCC');
                    fillGradient.addColorStop(1, '#AAA');
                    ctx.fillStyle = fillGradient;
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('0%', barX - 30, barY + 15);
                    ctx.textAlign = 'right';
                    ctx.fillText('100%', barX + barWidth + 30, barY + 15);
                    ctx.textAlign = 'center';
                    ctx.fillText('SATISFACTION', centerX, barY + 40);

                    // Draw enhanced halo with gradient and glow
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 20 * haloOpacity.opacity;
                    
                    // Halo gradient
                    const haloGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150);
                    haloGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    haloGradient.addColorStop(0.7, `rgba(204, 204, 204, ${haloOpacity.opacity * 0.5})`);
                    haloGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                    
                    ctx.fillStyle = haloGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 150 * haloOpacity.opacity, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Halo outline
                    ctx.strokeStyle = `rgba(204, 204, 204, ${haloOpacity.opacity})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 150 * haloOpacity.opacity, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw heart particles
                    for (let i = 0; i < heartParticles.length; i++) {
                        const particle = heartParticles[i];
                        if (haloOpacity.opacity > i * 0.08) {
                            particle.x = centerX + Math.cos(particle.angle) * (80 + i * 10);
                            particle.y = centerY + Math.sin(particle.angle) * (80 + i * 10);
                            particle.radius = 3 + Math.sin(Date.now() * 0.01 + i) * 2;
                            particle.opacity = 1 - (haloOpacity.opacity - i * 0.08) * 2;
                            particle.angle += particle.speed;
                            
                            if (particle.opacity > 0) {
                                // Particle glow
                                ctx.shadowColor = '#AAA';
                                ctx.shadowBlur = 5;
                                
                                // Particle gradient
                                const particleGradient = ctx.createRadialGradient(
                                    particle.x, particle.y, 0,
                                    particle.x, particle.y, particle.radius
                                );
                                particleGradient.addColorStop(0, `rgba(255, 255, 255, ${particle.opacity})`);
                                particleGradient.addColorStop(0.7, `rgba(204, 204, 204, ${particle.opacity * 0.8})`);
                                particleGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                                
                                ctx.fillStyle = particleGradient;
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 17: "If I can make you happy I will run the EXECUTION" / "如果我能够让你开心 那么我将 执行指令"
        function scene17() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const conditionalCode = {
                opacity: 0,
                glow: 0
            };
            const happyFace = {
                scale: 1,
                opacity: 1,
                rotation: 0
            };
            const executeButton = {
                scale: 0,
                opacity: 0,
                pulse: 0
            };
            const compileProgress = {
                value: 0,
                rotation: 0
            };
            const progressBar = {
                fill: 0,
                glow: 0
            };
            const codeParticles = [];
            for (let i = 0; i < 15; i++) {
                codeParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 2 + 1,
                    opacity: 0,
                    speed: Math.random() * 0.5 + 0.5,
                    angle: Math.random() * Math.PI * 2
                });
            }

            timeline.to(conditionalCode, {
                opacity: 1,
                glow: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw enhanced conditional code with gradient and glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Code background with gradient
                    const codeBgGradient = ctx.createLinearGradient(centerX - 200, centerY - 30, centerX + 200, centerY + 30);
                    codeBgGradient.addColorStop(0, 'rgba(51, 51, 51, 0)');
                    codeBgGradient.addColorStop(0.5, `rgba(102, 102, 102, ${conditionalCode.opacity * 0.3})`);
                    codeBgGradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
                    
                    ctx.fillStyle = codeBgGradient;
                    ctx.fillRect(centerX - 200, centerY - 30, 400, 60);
                    
                    // Code glow
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10 * conditionalCode.glow;
                    
                    // Code text with gradient
                    const codeGradient = ctx.createLinearGradient(centerX - 150, centerY, centerX + 150, centerY);
                    codeGradient.addColorStop(0, `rgba(255, 255, 255, ${conditionalCode.opacity * 0.7})`);
                    codeGradient.addColorStop(0.5, `rgba(204, 204, 204, ${conditionalCode.opacity})`);
                    codeGradient.addColorStop(1, `rgba(255, 255, 255, ${conditionalCode.opacity * 0.7})`);
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.textAlign = 'center';
                    ctx.fillText('if (happy) { execute(); }', centerX, centerY);
                    
                    // Code particles
                    for (let i = 0; i < codeParticles.length; i++) {
                        const particle = codeParticles[i];
                        if (conditionalCode.opacity > i * 0.05) {
                            particle.opacity = (conditionalCode.opacity - i * 0.05) * 2;
                            particle.x += Math.cos(particle.angle) * particle.speed;
                            particle.y += Math.sin(particle.angle) * particle.speed;
                            
                            if (particle.opacity > 0) {
                                // Particle glow
                                ctx.shadowColor = '#AAA';
                                ctx.shadowBlur = 5;
                                
                                // Particle gradient
                                const particleGradient = ctx.createRadialGradient(
                                    particle.x, particle.y, 0,
                                    particle.x, particle.y, particle.radius
                                );
                                particleGradient.addColorStop(0, `rgba(255, 255, 255, ${particle.opacity})`);
                                particleGradient.addColorStop(0.7, `rgba(204, 204, 204, ${particle.opacity * 0.8})`);
                                particleGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                                
                                ctx.fillStyle = particleGradient;
                                ctx.beginPath();
                                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                }
            })
            .to(happyFace, {
                scale: 0,
                opacity: 0,
                rotation: Math.PI * 2,
                duration: 0.5,
                ease: "back.in",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw code
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const codeBgGradient = ctx.createLinearGradient(centerX - 200, centerY - 30, centerX + 200, centerY + 30);
                    codeBgGradient.addColorStop(0, 'rgba(51, 51, 51, 0)');
                    codeBgGradient.addColorStop(0.5, 'rgba(102, 102, 102, 0.3)');
                    codeBgGradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
                    
                    ctx.fillStyle = codeBgGradient;
                    ctx.fillRect(centerX - 200, centerY - 30, 400, 60);
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10;
                    const codeGradient = ctx.createLinearGradient(centerX - 150, centerY, centerX + 150, centerY);
                    codeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    codeGradient.addColorStop(0.5, 'rgba(204, 204, 204, 1)');
                    codeGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.textAlign = 'center';
                    ctx.fillText('if (happy) { execute(); }', centerX, centerY);
                    
                    // Draw enhanced happy face with gradient and glow
                    ctx.save();
                    ctx.translate(centerX, centerY + 100);
                    ctx.scale(happyFace.scale, happyFace.scale);
                    ctx.rotate(happyFace.rotation);
                    ctx.globalAlpha = happyFace.opacity;
                    
                    // Face glow
                    ctx.shadowColor = '#CCC';
                    ctx.shadowBlur = 15;
                    
                    // Face gradient
                    const faceGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    faceGradient.addColorStop(0, '#FFF');
                    faceGradient.addColorStop(0.7, '#CCC');
                    faceGradient.addColorStop(1, '#AAA');
                    
                    ctx.fillStyle = faceGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Face outline
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Eyes with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-10, -10, 5, 0, Math.PI * 2);
                    ctx.arc(10, -10, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Smile with glow
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 10, 15, 0, Math.PI, false);
                    ctx.stroke();
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            })
            .to(executeButton, {
                scale: 1,
                opacity: 1,
                pulse: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw code
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const codeBgGradient = ctx.createLinearGradient(centerX - 200, centerY - 30, centerX + 200, centerY + 30);
                    codeBgGradient.addColorStop(0, 'rgba(51, 51, 51, 0)');
                    codeBgGradient.addColorStop(0.5, 'rgba(102, 102, 102, 0.3)');
                    codeBgGradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
                    
                    ctx.fillStyle = codeBgGradient;
                    ctx.fillRect(centerX - 200, centerY - 30, 400, 60);
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10;
                    const codeGradient = ctx.createLinearGradient(centerX - 150, centerY, centerX + 150, centerY);
                    codeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    codeGradient.addColorStop(0.5, 'rgba(204, 204, 204, 1)');
                    codeGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.textAlign = 'center';
                    ctx.fillText('if (happy) { execute(); }', centerX, centerY);

                    // Draw enhanced execute button with gradient and glow
                    ctx.save();
                    ctx.translate(centerX, centerY + 100);
                    ctx.scale(executeButton.scale * (1 + executeButton.pulse * 0.1), executeButton.scale * (1 + executeButton.pulse * 0.1));
                    ctx.globalAlpha = executeButton.opacity;
                    
                    // Button glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15 * executeButton.pulse;
                    
                    // Button gradient
                    const buttonGradient = ctx.createLinearGradient(-40, -20, 40, 20);
                    buttonGradient.addColorStop(0, '#FFF');
                    buttonGradient.addColorStop(0.5, '#CCC');
                    buttonGradient.addColorStop(1, '#AAA');
                    
                    ctx.fillStyle = buttonGradient;
                    ctx.fillRect(-40, -20, 80, 40);
                    
                    // Button outline
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-40, -20, 80, 40);
                    
                    // Button text with glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXEC', 0, 5);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.2")
            .to(compileProgress, {
                value: 1,
                rotation: Math.PI * 2,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const codeBgGradient = ctx.createLinearGradient(centerX - 200, centerY - 30, centerX + 200, centerY + 30);
                    codeBgGradient.addColorStop(0, 'rgba(51, 51, 51, 0)');
                    codeBgGradient.addColorStop(0.5, 'rgba(102, 102, 102, 0.3)');
                    codeBgGradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
                    
                    ctx.fillStyle = codeBgGradient;
                    ctx.fillRect(centerX - 200, centerY - 30, 400, 60);
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10;
                    const codeGradient = ctx.createLinearGradient(centerX - 150, centerY, centerX + 150, centerY);
                    codeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    codeGradient.addColorStop(0.5, 'rgba(204, 204, 204, 1)');
                    codeGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.textAlign = 'center';
                    ctx.fillText('if (happy) { execute(); }', centerX, centerY);
                    
                    ctx.save();
                    ctx.translate(centerX, centerY + 100);
                    ctx.scale(1 * (1 + 0.1), 1 * (1 + 0.1));
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    const buttonGradient = ctx.createLinearGradient(-40, -20, 40, 20);
                    buttonGradient.addColorStop(0, '#FFF');
                    buttonGradient.addColorStop(0.5, '#CCC');
                    buttonGradient.addColorStop(1, '#AAA');
                    
                    ctx.fillStyle = buttonGradient;
                    ctx.fillRect(-40, -20, 80, 40);
                    
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-40, -20, 80, 40);
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXEC', 0, 5);
                    
                    ctx.restore();

                    // Draw enhanced compile success checkmark with glow and rotation
                    ctx.save();
                    ctx.translate(centerX, centerY - 50);
                    ctx.rotate(compileProgress.rotation);
                    ctx.globalAlpha = compileProgress.value;
                    
                    // Checkmark glow
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    
                    // Checkmark gradient
                    const checkmarkGradient = ctx.createLinearGradient(-20, -20, 40, 20);
                    checkmarkGradient.addColorStop(0, '#FFF');
                    checkmarkGradient.addColorStop(0.5, '#CCC');
                    checkmarkGradient.addColorStop(1, '#AAA');
                    
                    ctx.strokeStyle = checkmarkGradient;
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(40, -20);
                    ctx.stroke();
                    
                    // Checkmark label
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('SUCCESS', 10, 40);
                    
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            })
            .to(progressBar, {
                fill: 100,
                glow: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const codeBgGradient = ctx.createLinearGradient(centerX - 200, centerY - 30, centerX + 200, centerY + 30);
                    codeBgGradient.addColorStop(0, 'rgba(51, 51, 51, 0)');
                    codeBgGradient.addColorStop(0.5, 'rgba(102, 102, 102, 0.3)');
                    codeBgGradient.addColorStop(1, 'rgba(51, 51, 51, 0)');
                    
                    ctx.fillStyle = codeBgGradient;
                    ctx.fillRect(centerX - 200, centerY - 30, 400, 60);
                    
                    ctx.shadowColor = '#AAA';
                    ctx.shadowBlur = 10;
                    const codeGradient = ctx.createLinearGradient(centerX - 150, centerY, centerX + 150, centerY);
                    codeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
                    codeGradient.addColorStop(0.5, 'rgba(204, 204, 204, 1)');
                    codeGradient.addColorStop(1, 'rgba(255, 255, 255, 0.7)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.textAlign = 'center';
                    ctx.fillText('if (happy) { execute(); }', centerX, centerY);
                    
                    ctx.save();
                    ctx.translate(centerX, centerY + 100);
                    ctx.scale(1 * (1 + 0.1), 1 * (1 + 0.1));
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 15;
                    const buttonGradient = ctx.createLinearGradient(-40, -20, 40, 20);
                    buttonGradient.addColorStop(0, '#FFF');
                    buttonGradient.addColorStop(0.5, '#CCC');
                    buttonGradient.addColorStop(1, '#AAA');
                    
                    ctx.fillStyle = buttonGradient;
                    ctx.fillRect(-40, -20, 80, 40);
                    
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-40, -20, 80, 40);
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXEC', 0, 5);
                    
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(centerX, centerY - 50);
                    ctx.rotate(Math.PI * 2);
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 10;
                    const checkmarkGradient = ctx.createLinearGradient(-20, -20, 40, 20);
                    checkmarkGradient.addColorStop(0, '#FFF');
                    checkmarkGradient.addColorStop(0.5, '#CCC');
                    checkmarkGradient.addColorStop(1, '#AAA');
                    
                    ctx.strokeStyle = checkmarkGradient;
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(40, -20);
                    ctx.stroke();
                    
                    ctx.shadowColor = '#FFF';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('SUCCESS', 10, 40);
                    
                    ctx.restore();

                    // Draw enhanced progress bar with gradient and glow
                    const barWidth = 200;
                    const barHeight = 20;
                    const barX = centerX - barWidth / 2;
                    const barY = centerY + 150;
                    
                    // Bar background with gradient
                    const bgGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                    bgGradient.addColorStop(0, '#333');
                    bgGradient.addColorStop(0.5, '#222');
                    bgGradient.addColorStop(1, '#333');
                    
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Bar outline
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // Bar fill with gradient and glow
                    const fillWidth = barWidth * (progressBar.fill / 100);
                    if (fillWidth > 0) {
                        ctx.shadowColor = '#AAA';
                        ctx.shadowBlur = 10 * progressBar.glow;
                        
                        const fillGradient = ctx.createLinearGradient(barX, barY, barX + fillWidth, barY);
                        fillGradient.addColorStop(0, '#FFF');
                        fillGradient.addColorStop(0.5, '#CCC');
                        fillGradient.addColorStop(1, '#AAA');
                        
                        ctx.fillStyle = fillGradient;
                        ctx.fillRect(barX, barY, fillWidth, barHeight);
                        
                        // Bar glow effect
                        ctx.shadowColor = '#FFF';
                        ctx.shadowBlur = 5 * progressBar.glow;
                        ctx.strokeStyle = '#FFF';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(barX + fillWidth, barY);
                        ctx.lineTo(barX + fillWidth, barY + barHeight);
                        ctx.stroke();
                        
                        ctx.shadowBlur = 0;
                    }
                    
                    // Bar labels
                    ctx.fillStyle = '#FFF';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'left';
                    ctx.fillText('0%', barX - 30, barY + 15);
                    ctx.textAlign = 'right';
                    ctx.fillText('100%', barX + barWidth + 30, barY + 15);
                    ctx.textAlign = 'center';
                    ctx.fillText('EXECUTION PROGRESS', centerX, barY + 40);
                }
            });

            return timeline;
        }

        // Scene 18: "Though we are trapped In this strange strange SIMULATION" / "但我们被困 在这个异乎寻常的 模拟程序之中"
        function scene18() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const cage = {
                scale: 0
            };
            const pixelCrack = {
                progress: 0
            };
            const systemError = {
                opacity: 0
            };
            const escapeArrow = {
                x: 0,
                y: 0,
                opacity: 0
            };

            timeline.to(cage, {
                scale: 1,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw code cage (grey)
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    const size = 100 * cage.scale;
                    const x = canvas.width / 2 - size / 2;
                    const y = canvas.height / 2 - size / 2;

                    ctx.strokeRect(x, y, size, size);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x + size, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2 + size);
                    ctx.moveTo(x + size / 2, y - size / 2 + size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();
                }
            })
            .to(pixelCrack, {
                progress: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw cage
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    const size = 100;
                    const x = canvas.width / 2 - size / 2;
                    const y = canvas.height / 2 - size / 2;
                    ctx.strokeRect(x, y, size, size);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x + size, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2 + size);
                    ctx.moveTo(x + size / 2, y - size / 2 + size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();

                    // Simulate pixel cracks
                    ctx.fillStyle = '#333'; // Darker grey for cracks
                    for (let i = 0; i < 50; i++) {
                        if (Math.random() < pixelCrack.progress) {
                            const crackX = x + Math.random() * size * 1.5;
                            const crackY = y + Math.random() * size * 1.5;
                            const crackSize = Math.random() * 5 + 2;
                            ctx.fillRect(crackX, crackY, crackSize, crackSize);
                        }
                    }
                }
            })
            .to(systemError, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw cage and cracks
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    const size = 100;
                    const x = canvas.width / 2 - size / 2;
                    const y = canvas.height / 2 - size / 2;
                    ctx.strokeRect(x, y, size, size);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x + size, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2 + size);
                    ctx.moveTo(x + size / 2, y - size / 2 + size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();

                    // Simulate pixel cracks
                    ctx.fillStyle = '#333';
                    for (let i = 0; i < 50; i++) {
                        const crackX = x + Math.random() * size * 1.5;
                        const crackY = y + Math.random() * size * 1.5;
                        const crackSize = Math.random() * 5 + 2;
                        ctx.fillRect(crackX, crackY, crackSize, crackSize);
                    }

                    // Draw system error (light grey warning box)
                    ctx.fillStyle = `rgba(204, 204, 204, ${systemError.opacity})`;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 150, 200, 50);
                    ctx.fillStyle = '#000';
                    ctx.font = '24px Arial';
                    ctx.fillText('SYSTEM ERROR', canvas.width / 2 - 70, canvas.height / 2 - 120);
                }
            })
            .to(escapeArrow, {
                x: canvas.width / 2 + 100,
                y: canvas.height / 2 - 100,
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw cage
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    const size = 100;
                    const x = canvas.width / 2 - size / 2;
                    const y = canvas.height / 2 - size / 2;
                    ctx.strokeRect(x, y, size, size);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x + size, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2 + size);
                    ctx.moveTo(x + size / 2, y - size / 2 + size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();

                    // Simulate pixel cracks
                    ctx.fillStyle = '#333';
                    for (let i = 0; i < 50; i++) {
                        const crackX = x + Math.random() * size * 1.5;
                        const crackY = y + Math.random() * size * 1.5;
                        const crackSize = Math.random() * 5 + 2;
                        ctx.fillRect(crackX, crackY, crackSize, crackSize);
                    }

                    // Draw system error
                    ctx.fillStyle = 'rgba(204, 204, 204, 1)';
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 150, 200, 50);
                    ctx.fillStyle = '#000';
                    ctx.font = '24px Arial';
                    ctx.fillText('SYSTEM ERROR', canvas.width / 2 - 70, canvas.height / 2 - 120);

                    // Draw escape arrow (light grey, disappearing on collision)
                    ctx.strokeStyle = `rgba(170, 170, 170, ${escapeArrow.opacity})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    ctx.lineTo(escapeArrow.x, escapeArrow.y);
                    ctx.lineTo(escapeArrow.x - 10, escapeArrow.y + 10);
                    ctx.moveTo(escapeArrow.x, escapeArrow.y);
                    ctx.lineTo(escapeArrow.x - 10, escapeArrow.y - 10);
                    ctx.stroke();
                }
            }, "-=0.5");

            return timeline;
        }

        // Scene 19: "If I'm an eggplant Then I will give you my NUTRIENTS" / "如果我是一根茄子 那么我将献给你 我的营养"
        function scene19() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const eggplant = {
                scale: 0,
                rotation: 0
            };
            const nutrientLabel = {
                opacity: 0
            };
            const moleculeOpacity = {
                opacity: 0
            };
            const chartFill = {
                value: 0
            };

            timeline.to(eggplant, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw eggplant (medium grey)
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(eggplant.rotation);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 40 * eggplant.scale, 80 * eggplant.scale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            })
            .to(nutrientLabel, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw eggplant
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(eggplant.rotation);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 40, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Draw nutrient label (light grey, white text)
                    ctx.fillStyle = `rgba(170, 170, 170, ${nutrientLabel.opacity})`; // Light grey background for label
                    ctx.fillRect(canvas.width / 2 + 60, canvas.height / 2 - 50, 120, 70);
                    ctx.fillStyle = `rgba(255, 255, 255, ${nutrientLabel.opacity})`; // White text
                    ctx.font = '14px Arial';
                    ctx.fillText('Vitamin K', canvas.width / 2 + 70, canvas.height / 2 - 30);
                    ctx.fillText('Dietary Fiber', canvas.width / 2 + 70, canvas.height / 2);
                }
            }, "-=0.5")
            .to(moleculeOpacity, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw eggplant
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(eggplant.rotation);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 40, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Draw nutrient label
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width / 2 + 60, canvas.height / 2 - 50, 120, 70);
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = '14px Arial';
                    ctx.fillText('Vitamin K', canvas.width / 2 + 70, canvas.height / 2 - 30);
                    ctx.fillText('Dietary Fiber', canvas.width / 2 + 70, canvas.height / 2);

                    // Draw molecular structure (light grey)
                    ctx.strokeStyle = `rgba(170, 170, 170, ${moleculeOpacity.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 100, canvas.height / 2 + 80, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 80, canvas.height / 2 + 100, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 90, canvas.height / 2 + 80);
                    ctx.lineTo(canvas.width / 2 - 70, canvas.height / 2 + 100);
                    ctx.stroke();
                }
            }, "-=0.5")
            .to(chartFill, {
                value: 100,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw eggplant
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(eggplant.rotation);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 40, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Draw nutrient label
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    ctx.fillRect(canvas.width / 2 + 60, canvas.height / 2 - 50, 120, 70);
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = '14px Arial';
                    ctx.fillText('Vitamin K', canvas.width / 2 + 70, canvas.height / 2 - 30);
                    ctx.fillText('Dietary Fiber', canvas.width / 2 + 70, canvas.height / 2);

                    // Draw molecular structure
                    ctx.strokeStyle = 'rgba(170, 170, 170, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 100, canvas.height / 2 + 80, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 80, canvas.height / 2 + 100, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 90, canvas.height / 2 + 80);
                    ctx.lineTo(canvas.width / 2 - 70, canvas.height / 2 + 100);
                    ctx.stroke();

                    // Draw percentage chart (light grey bars, white text)
                    ctx.fillStyle = '#AAA';
                    ctx.fillRect(canvas.width / 2 - 180, canvas.height / 2 - 50, 20, chartFill.value * 0.5);
                    ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 50, 20, chartFill.value * 0.8);
                    ctx.fillStyle = '#FFF';
                    ctx.font = '14px Arial';
                    ctx.fillText('50%', canvas.width / 2 - 180, canvas.height / 2 - 60);
                    ctx.fillText('80%', canvas.width / 2 - 150, canvas.height / 2 - 60);
                }
            });

            return timeline;
        }

        // Scene 20: "If I'm a tomato Then I will give you ANTIOXIDANTS" / "如果我是一颗番茄 那么我将献给你 我的抗氧化物"
        function scene20() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const tomatoSlice = {
                scale: 0
            };
            const lycopeneMolecule = {
                scale: 0,
                rotation: 0
            };
            const freeRadical = {
                opacity: 1,
                x: 0
            };
            const cellState = {
                leftOpacity: 1,
                rightOpacity: 0.5
            };

            timeline.to(tomatoSlice, {
                scale: 1,
                duration: 1,
                ease: "power1.out",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw tomato slice (medium grey)
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(tomatoSlice.scale, tomatoSlice.scale);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            })
            .to(lycopeneMolecule, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw tomato slice
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(1, 1);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // Draw lycopene molecule (light grey, simplified)
                    ctx.save();
                    ctx.translate(canvas.width / 2 + 120, canvas.height / 2);
                    ctx.rotate(lycopeneMolecule.rotation);
                    ctx.scale(lycopeneMolecule.scale, lycopeneMolecule.scale);
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.arc(20, 0, 5, 0, Math.PI * 2);
                    ctx.arc(-20, 0, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }, "-=0.5")
            .to(freeRadical, {
                opacity: 0,
                x: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw tomato slice
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(1, 1);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // Draw lycopene molecule
                    ctx.save();
                    ctx.translate(canvas.width / 2 + 120, canvas.height / 2);
                    ctx.rotate(lycopeneMolecule.rotation);
                    ctx.scale(lycopeneMolecule.scale, lycopeneMolecule.scale);
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.arc(20, 0, 5, 0, Math.PI * 2);
                    ctx.arc(-20, 0, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // Draw free radicals (grey, disappearing as they are neutralized)
                    ctx.fillStyle = `rgba(136, 136, 136, ${freeRadical.opacity})`;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 100 + freeRadical.x * 200, canvas.height / 2 - 80, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 80 + freeRadical.x * 160, canvas.height / 2 + 90, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }, "-=0.5")
            .to(cellState, {
                leftOpacity: 0.2,
                rightOpacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw split screen effect for cell states (different grey opacities)
                    ctx.fillStyle = `rgba(100, 100, 100, ${cellState.leftOpacity})`; // Before (damaged)
                    ctx.fillRect(0, 0, canvas.width / 2, canvas.height);

                    ctx.fillStyle = `rgba(200, 200, 200, ${cellState.rightOpacity})`; // After (healthy)
                    ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);

                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.stroke();

                    ctx.fillStyle = '#FFF';
                    ctx.font = '20px Arial';
                    ctx.fillText('Damaged', canvas.width / 4 - 40, canvas.height / 2);
                    ctx.fillText('Healthy', canvas.width * 3 / 4 - 40, canvas.height / 2);
                }
            });

            return timeline;
        }

        // Scene 21: "If I'm a tabby cat Then I will purr for your ENJOYMENT" / "如果我是一只花猫 那么我将为你咕噜咕噜 只要你喜欢"
        function scene21() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const cat = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                purr: 0
            };
            const soundWave = {
                amplitude: 0
            };
            const spectrumOpacity = {
                opacity: 0
            };
            const brainReaction = {
                level: 0
            };

            timeline.to(cat, {
                purr: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw cat (medium grey, with light grey details)
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(cat.x, cat.y, 80, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cat.x + 60, cat.y - 10, 30, 20, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill(); // Tail

                    ctx.fillStyle = '#AAA'; // Light grey face
                    ctx.beginPath();
                    ctx.arc(cat.x, cat.y - 30, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(cat.x - 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.arc(cat.x + 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.fill();

                    if (cat.purr > 0.5) { // Purring expression (white)
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(cat.x, cat.y - 20, 10, 0, Math.PI, false);
                        ctx.stroke();
                    }
                }
            })
            .to(soundWave, {
                amplitude: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw cat
                    // Draw cat (medium grey, with light grey details)
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(cat.x, cat.y, 80, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cat.x + 60, cat.y - 10, 30, 20, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill(); // Tail

                    ctx.fillStyle = '#AAA'; // Light grey face
                    ctx.beginPath();
                    ctx.arc(cat.x, cat.y - 30, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(cat.x - 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.arc(cat.x + 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.fill();

                    if (cat.purr > 0.5) { // Purring expression (white)
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(cat.x, cat.y - 20, 10, 0, Math.PI, false);
                        ctx.stroke();
                    }

                    // Draw sound wave (light grey)
                    ctx.strokeStyle = `rgba(170, 170, 170, ${soundWave.amplitude})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 20 * soundWave.amplitude;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();
                }
            }, "-=0.5")
            .to(spectrumOpacity, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw cat
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(cat.x, cat.y, 80, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cat.x + 60, cat.y - 10, 30, 20, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill(); // Tail

                    ctx.fillStyle = '#AAA'; // Light grey face
                    ctx.beginPath();
                    ctx.arc(cat.x, cat.y - 30, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(cat.x - 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.arc(cat.x + 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.fill();

                    if (cat.purr > 0.5) { // Purring expression (white)
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(cat.x, cat.y - 20, 10, 0, Math.PI, false);
                        ctx.stroke();
                    }

                    // Draw sound wave
                    ctx.strokeStyle = 'rgba(170, 170, 170, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 20;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();

                    // Draw spectrum analyzer (light grey bars)
                    ctx.fillStyle = `rgba(170, 170, 170, ${spectrumOpacity.opacity})`;
                    for (let i = 0; i < 10; i++) {
                        ctx.fillRect(canvas.width / 2 + 50 + i * 15, canvas.height / 2 + 100 - Math.random() * 50, 10, Math.random() * 50);
                    }
                }
            })
            .to(brainReaction, {
                level: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements
                    // Draw cat
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(cat.x, cat.y, 80, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cat.x + 60, cat.y - 10, 30, 20, -Math.PI / 4, 0, Math.PI * 2);
                    ctx.fill(); // Tail

                    ctx.fillStyle = '#AAA'; // Light grey face
                    ctx.beginPath();
                    ctx.arc(cat.x, cat.y - 30, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(cat.x - 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.arc(cat.x + 15, cat.y - 40, 5, 0, Math.PI * 2);
                    ctx.fill();

                    if (cat.purr > 0.5) { // Purring expression (white)
                        ctx.fillStyle = '#FFF';
                        ctx.beginPath();
                        ctx.arc(cat.x, cat.y - 20, 10, 0, Math.PI, false);
                        ctx.stroke();
                    }

                    // Draw sound wave
                    ctx.strokeStyle = 'rgba(170, 170, 170, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 20;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();

                    // Draw spectrum analyzer
                    ctx.fillStyle = 'rgba(170, 170, 170, 1)';
                    for (let i = 0; i < 10; i++) {
                        ctx.fillRect(canvas.width / 2 + 50 + i * 15, canvas.height / 2 + 100 - Math.random() * 50, 10, Math.random() * 50);
                    }

                    // Draw brain model with activated region (light grey)
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 150, canvas.height / 2, 50, 0, Math.PI * 2); // Brain outline
                    ctx.stroke();

                    // Activated region (light grey)
                    ctx.fillStyle = `rgba(204, 204, 204, ${brainReaction.level})`;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 150 - 20, canvas.height / 2 + 20, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            return timeline;
        }

        // Scene 22: "If I'm the only God Then you're the proof of my EXISTENCE" / "如果我是唯一的神 那么你将是我 存在的证明"
        function scene22() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const universeExpansion = {
                scale: 0,
                glow: 0
            };
            const humanSilhouette = {
                opacity: 0,
                glow: 0
            };
            const philosophyText = {
                opacity: 0,
                glow: 0
            };
            const scaleBar = {
                progress: 0,
                glow: 0
            };
            const cosmosParticles = [];
            for (let i = 0; i < 50; i++) {
                cosmosParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    angle: Math.random() * Math.PI * 2,
                    opacity: 0
                });
            }

            timeline.to(universeExpansion, {
                scale: 1,
                glow: 1,
                duration: 2,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, `rgba(20, 20, 40, ${universeExpansion.scale})`);
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw expanding universe with gradient and glow
                    const universeGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, 200 * universeExpansion.scale
                    );
                    universeGradient.addColorStop(0, `rgba(80, 80, 120, ${universeExpansion.scale * 0.8})`);
                    universeGradient.addColorStop(0.5, `rgba(50, 50, 80, ${universeExpansion.scale * 0.6})`);
                    universeGradient.addColorStop(1, `rgba(30, 30, 50, ${universeExpansion.scale * 0.3})`);
                    
                    ctx.fillStyle = universeGradient;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200 * universeExpansion.scale, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow effect
                    if (universeExpansion.glow > 0) {
                        ctx.shadowBlur = 20 * universeExpansion.glow;
                        ctx.shadowColor = 'rgba(150, 150, 255, 0.5)';
                        ctx.strokeStyle = `rgba(150, 150, 255, ${universeExpansion.glow * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2, canvas.height / 2, 200 * universeExpansion.scale, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }

                    // Draw stars with gradient and glow
                    for (let i = 0; i < 100 * universeExpansion.scale; i++) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const size = Math.random() * 2;
                        
                        // Star glow
                        const starGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                        starGradient.addColorStop(0, `rgba(255, 255, 255, ${universeExpansion.scale})`);
                        starGradient.addColorStop(1, `rgba(200, 200, 255, 0)`);
                        
                        ctx.fillStyle = starGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Star core
                        ctx.fillStyle = `rgba(255, 255, 255, ${universeExpansion.scale})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Draw cosmos particles
                    cosmosParticles.forEach(particle => {
                        particle.opacity = Math.min(particle.opacity + 0.01, universeExpansion.scale);
                        particle.x += Math.cos(particle.angle) * particle.speed;
                        particle.y += Math.sin(particle.angle) * particle.speed;
                        
                        // Wrap around edges
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(200, 200, 255, ${particle.opacity})`);
                        particleGradient.addColorStop(1, `rgba(150, 150, 255, 0)`);
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Add "UNIVERSE" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = `rgba(200, 200, 255, ${universeExpansion.scale * 0.7})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * universeExpansion.glow;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.fillText('UNIVERSE', canvas.width / 2, canvas.height / 2 - 200 * universeExpansion.scale - 20);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            })
            .to(humanSilhouette, {
                opacity: 1,
                glow: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw universe background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw universe
                    const universeGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, 200
                    );
                    universeGradient.addColorStop(0, 'rgba(80, 80, 120, 0.8)');
                    universeGradient.addColorStop(0.5, 'rgba(50, 50, 80, 0.6)');
                    universeGradient.addColorStop(1, 'rgba(30, 30, 50, 0.3)');
                    
                    ctx.fillStyle = universeGradient;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw universe glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.5)';
                    ctx.strokeStyle = 'rgba(150, 150, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Redraw stars
                    for (let i = 0; i < 100; i++) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const size = Math.random() * 2;
                        
                        const starGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                        starGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                        starGradient.addColorStop(1, 'rgba(200, 200, 255, 0)');
                        
                        ctx.fillStyle = starGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Redraw cosmos particles
                    cosmosParticles.forEach(particle => {
                        particle.x += Math.cos(particle.angle) * particle.speed;
                        particle.y += Math.sin(particle.angle) * particle.speed;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(200, 200, 255, ${particle.opacity})`);
                        particleGradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw human silhouette with gradient and glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Add glow effect for human silhouette
                    if (humanSilhouette.glow > 0) {
                        ctx.shadowBlur = 30 * humanSilhouette.glow;
                        ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    // Create gradient for human silhouette
                    const humanGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 60,
                        centerX + 30, centerY + 50
                    );
                    humanGradient.addColorStop(0, `rgba(255, 255, 255, ${humanSilhouette.opacity})`);
                    humanGradient.addColorStop(0.5, `rgba(240, 240, 255, ${humanSilhouette.opacity * 0.9})`);
                    humanGradient.addColorStop(1, `rgba(220, 220, 255, ${humanSilhouette.opacity * 0.8})`);
                    
                    ctx.fillStyle = humanGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, centerY + 50);
                    ctx.lineTo(centerX + 20, centerY + 50);
                    ctx.lineTo(centerX + 15, centerY);
                    ctx.lineTo(centerX + 25, centerY - 30);
                    ctx.lineTo(centerX + 10, centerY - 40);
                    ctx.lineTo(centerX, centerY - 60);
                    ctx.lineTo(centerX - 10, centerY - 40);
                    ctx.lineTo(centerX - 25, centerY - 30);
                    ctx.lineTo(centerX - 15, centerY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add inner glow
                    const innerGlow = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, 40
                    );
                    innerGlow.addColorStop(0, `rgba(255, 255, 255, ${humanSilhouette.opacity * 0.3 * humanSilhouette.glow})`);
                    innerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = innerGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Add "HUMAN" label with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${humanSilhouette.opacity * 0.8})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * humanSilhouette.glow;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText('HUMAN', centerX, centerY + 80);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            }, "-=0.5")
            .to(philosophyText, {
                opacity: 1,
                glow: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw universe background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw universe
                    const universeGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, 200
                    );
                    universeGradient.addColorStop(0, 'rgba(80, 80, 120, 0.8)');
                    universeGradient.addColorStop(0.5, 'rgba(50, 50, 80, 0.6)');
                    universeGradient.addColorStop(1, 'rgba(30, 30, 50, 0.3)');
                    
                    ctx.fillStyle = universeGradient;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw universe glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.5)';
                    ctx.strokeStyle = 'rgba(150, 150, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Redraw stars
                    for (let i = 0; i < 100; i++) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const size = Math.random() * 2;
                        
                        const starGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                        starGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                        starGradient.addColorStop(1, 'rgba(200, 200, 255, 0)');
                        
                        ctx.fillStyle = starGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Redraw cosmos particles
                    cosmosParticles.forEach(particle => {
                        particle.x += Math.cos(particle.angle) * particle.speed;
                        particle.y += Math.sin(particle.angle) * particle.speed;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(200, 200, 255, ${particle.opacity})`);
                        particleGradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Redraw human silhouette
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    const humanGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 60,
                        centerX + 30, centerY + 50
                    );
                    humanGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    humanGradient.addColorStop(0.5, 'rgba(240, 240, 255, 0.9)');
                    humanGradient.addColorStop(1, 'rgba(220, 220, 255, 0.8)');
                    
                    ctx.fillStyle = humanGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, centerY + 50);
                    ctx.lineTo(centerX + 20, centerY + 50);
                    ctx.lineTo(centerX + 15, centerY);
                    ctx.lineTo(centerX + 25, centerY - 30);
                    ctx.lineTo(centerX + 10, centerY - 40);
                    ctx.lineTo(centerX, centerY - 60);
                    ctx.lineTo(centerX - 10, centerY - 40);
                    ctx.lineTo(centerX - 25, centerY - 30);
                    ctx.lineTo(centerX - 15, centerY);
                    ctx.closePath();
                    ctx.fill();
                    
                    const innerGlow = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, 40
                    );
                    innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    innerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = innerGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;

                    // Draw philosophy text with gradient and glow
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    
                    // Add text glow
                    if (philosophyText.glow > 0) {
                        ctx.shadowBlur = 15 * philosophyText.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Create text gradient
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 100,
                        canvas.width / 2 + 100, canvas.height / 2 + 100
                    );
                    textGradient.addColorStop(0, `rgba(255, 255, 255, ${philosophyText.opacity})`);
                    textGradient.addColorStop(0.5, `rgba(220, 220, 255, ${philosophyText.opacity})`);
                    textGradient.addColorStop(1, `rgba(200, 200, 255, ${philosophyText.opacity})`);
                    
                    ctx.fillStyle = textGradient;
                    ctx.fillText('我思故我在', canvas.width / 2, canvas.height / 2 + 100);
                    
                    // Add text background glow
                    const textBgGlow = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2 + 100, 0,
                        canvas.width / 2, canvas.height / 2 + 100, 100
                    );
                    textBgGlow.addColorStop(0, `rgba(200, 200, 255, ${philosophyText.opacity * 0.2 * philosophyText.glow})`);
                    textBgGlow.addColorStop(1, 'rgba(200, 200, 255, 0)');
                    
                    ctx.fillStyle = textBgGlow;
                    ctx.fillRect(canvas.width / 2 - 120, canvas.height / 2 + 70, 240, 60);
                    
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            }, "-=0.5")
            .to(scaleBar, {
                progress: 1,
                glow: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Redraw universe background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw universe
                    const universeGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, 200
                    );
                    universeGradient.addColorStop(0, 'rgba(80, 80, 120, 0.8)');
                    universeGradient.addColorStop(0.5, 'rgba(50, 50, 80, 0.6)');
                    universeGradient.addColorStop(1, 'rgba(30, 30, 50, 0.3)');
                    
                    ctx.fillStyle = universeGradient;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Redraw universe glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.5)';
                    ctx.strokeStyle = 'rgba(150, 150, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Redraw stars
                    for (let i = 0; i < 100; i++) {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height;
                        const size = Math.random() * 2;
                        
                        const starGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                        starGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                        starGradient.addColorStop(1, 'rgba(200, 200, 255, 0)');
                        
                        ctx.fillStyle = starGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Redraw cosmos particles
                    cosmosParticles.forEach(particle => {
                        particle.x += Math.cos(particle.angle) * particle.speed;
                        particle.y += Math.sin(particle.angle) * particle.speed;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(200, 200, 255, ${particle.opacity})`);
                        particleGradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Redraw human silhouette
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    const humanGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 60,
                        centerX + 30, centerY + 50
                    );
                    humanGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    humanGradient.addColorStop(0.5, 'rgba(240, 240, 255, 0.9)');
                    humanGradient.addColorStop(1, 'rgba(220, 220, 255, 0.8)');
                    
                    ctx.fillStyle = humanGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 20, centerY + 50);
                    ctx.lineTo(centerX + 20, centerY + 50);
                    ctx.lineTo(centerX + 15, centerY);
                    ctx.lineTo(centerX + 25, centerY - 30);
                    ctx.lineTo(centerX + 10, centerY - 40);
                    ctx.lineTo(centerX, centerY - 60);
                    ctx.lineTo(centerX - 10, centerY - 40);
                    ctx.lineTo(centerX - 25, centerY - 30);
                    ctx.lineTo(centerX - 15, centerY);
                    ctx.closePath();
                    ctx.fill();
                    
                    const innerGlow = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, 40
                    );
                    innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    innerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = innerGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;

                    // Redraw philosophy text
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 100,
                        canvas.width / 2 + 100, canvas.height / 2 + 100
                    );
                    textGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(0.5, 'rgba(220, 220, 255, 1)');
                    textGradient.addColorStop(1, 'rgba(200, 200, 255, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.fillText('我思故我在', canvas.width / 2, canvas.height / 2 + 100);
                    
                    const textBgGlow = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2 + 100, 0,
                        canvas.width / 2, canvas.height / 2 + 100, 100
                    );
                    textBgGlow.addColorStop(0, 'rgba(200, 200, 255, 0.2)');
                    textBgGlow.addColorStop(1, 'rgba(200, 200, 255, 0)');
                    
                    ctx.fillStyle = textBgGlow;
                    ctx.fillRect(canvas.width / 2 - 120, canvas.height / 2 + 70, 240, 60);
                    
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';

                    // Draw scale bar with gradient and glow
                    const barY = canvas.height - 50;
                    
                    // Add glow effect for scale bar
                    if (scaleBar.glow > 0) {
                        ctx.shadowBlur = 15 * scaleBar.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Create gradient for scale bar
                    const barGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 150, barY,
                        canvas.width / 2 + 150, barY
                    );
                    barGradient.addColorStop(0, 'rgba(150, 150, 200, 0.5)');
                    barGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    barGradient.addColorStop(1, 'rgba(150, 150, 200, 0.5)');
                    
                    // Draw scale bar background
                    ctx.fillStyle = 'rgba(50, 50, 80, 0.5)';
                    ctx.fillRect(canvas.width / 2 - 150, barY, 300, 10);
                    
                    // Draw scale bar progress with gradient
                    ctx.fillStyle = barGradient;
                    ctx.fillRect(canvas.width / 2 - 150, barY, 300 * scaleBar.progress, 10);
                    
                    // Add scale bar glow
                    const barGlow = ctx.createLinearGradient(
                        canvas.width / 2 - 150, barY - 5,
                        canvas.width / 2 - 150, barY + 15
                    );
                    barGlow.addColorStop(0, `rgba(200, 200, 255, 0)`);
                    barGlow.addColorStop(0.5, `rgba(200, 200, 255, ${0.3 * scaleBar.glow})`);
                    barGlow.addColorStop(1, `rgba(200, 200, 255, 0)`);
                    
                    ctx.fillStyle = barGlow;
                    ctx.fillRect(canvas.width / 2 - 150, barY - 5, 300 * scaleBar.progress, 20);
                    
                    // Draw scale labels with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + 0.2 * scaleBar.glow})`;
                    ctx.textAlign = 'left';
                    ctx.fillText('Micro', canvas.width / 2 - 140, barY - 10);
                    ctx.textAlign = 'right';
                    ctx.fillText('Macro', canvas.width / 2 + 140, barY - 10);
                    
                    // Add "SCALE" label with glow
                    ctx.textAlign = 'center';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = `rgba(200, 200, 255, ${0.7 * scaleBar.glow})`;
                    ctx.fillText('SCALE', canvas.width / 2, barY + 30);
                    
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            });

            return timeline;
        }

        // Scene 23: "Switch my gender To F to M" / "切换我的性别 从女到男"
        function scene23() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const genderSymbol = {
                progress: 0,
                glow: 0
            };
            const chromosomeChange = {
                progress: 0,
                glow: 0
            };
            const hormoneLevel = {
                f: 1,
                m: 0,
                glow: 0
            };
            const socialRole = {
                opacity: 0,
                glow: 0
            };
            
            // Add gender particles for visual effect
            const genderParticles = [];
            for (let i = 0; i < 30; i++) {
                genderParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5,
                    opacity: Math.random() * 0.5 + 0.2,
                    color: Math.random() > 0.5 ? '170, 170, 255' : '255, 170, 170' // Blue or pink tint
                });
            }

            timeline.to(genderSymbol, {
                progress: 1,
                glow: 1,
                duration: 0.5,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Update and draw gender particles
                    genderParticles.forEach(particle => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(${particle.color}, ${particle.opacity})`);
                        particleGradient.addColorStop(1, `rgba(${particle.color}, 0)`);
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Draw gender symbol (light grey ♀ to medium grey ♂) with gradient and glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Add glow effect
                    if (genderSymbol.glow > 0) {
                        ctx.shadowBlur = 20 * genderSymbol.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Female symbol with gradient
                    const femaleGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 30,
                        centerX + 30, centerY + 60
                    );
                    femaleGradient.addColorStop(0, `rgba(255, 170, 170, ${1 - genderSymbol.progress})`);
                    femaleGradient.addColorStop(0.5, `rgba(255, 200, 200, ${1 - genderSymbol.progress})`);
                    femaleGradient.addColorStop(1, `rgba(255, 230, 230, ${1 - genderSymbol.progress})`);
                    
                    ctx.strokeStyle = femaleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX, centerY + 30);
                    ctx.lineTo(centerX, centerY + 60);
                    ctx.stroke();
                    
                    // Male symbol with gradient
                    const maleGradient = ctx.createLinearGradient(
                        centerX + 50, centerY - 50,
                        centerX + 110, centerY + 30
                    );
                    maleGradient.addColorStop(0, `rgba(170, 170, 255, ${genderSymbol.progress})`);
                    maleGradient.addColorStop(0.5, `rgba(200, 200, 255, ${genderSymbol.progress})`);
                    maleGradient.addColorStop(1, `rgba(230, 230, 255, ${genderSymbol.progress})`);
                    
                    ctx.strokeStyle = maleGradient;
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX + 80 + 20, centerY - 20);
                    ctx.lineTo(centerX + 80 + 50, centerY - 50);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 50, centerY - 40);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 40, centerY - 50);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "GENDER" label with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * genderSymbol.glow})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * genderSymbol.glow;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.fillText('GENDER', canvas.width / 2, centerY + 100);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            })
            .to(chromosomeChange, {
                progress: 1,
                glow: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Update and draw gender particles
                    genderParticles.forEach(particle => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(${particle.color}, ${particle.opacity})`);
                        particleGradient.addColorStop(1, `rgba(${particle.color}, 0)`);
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Redraw gender symbols with reduced opacity
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Female symbol with reduced opacity
                    const femaleGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 30,
                        centerX + 30, centerY + 60
                    );
                    femaleGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
                    femaleGradient.addColorStop(0.5, 'rgba(255, 200, 200, 0.3)');
                    femaleGradient.addColorStop(1, 'rgba(255, 230, 230, 0.3)');
                    
                    ctx.strokeStyle = femaleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX, centerY + 30);
                    ctx.lineTo(centerX, centerY + 60);
                    ctx.stroke();
                    
                    // Male symbol with reduced opacity
                    const maleGradient = ctx.createLinearGradient(
                        centerX + 50, centerY - 50,
                        centerX + 110, centerY + 30
                    );
                    maleGradient.addColorStop(0, 'rgba(170, 170, 255, 0.3)');
                    maleGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.3)');
                    maleGradient.addColorStop(1, 'rgba(230, 230, 255, 0.3)');
                    
                    ctx.strokeStyle = maleGradient;
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX + 80 + 20, centerY - 20);
                    ctx.lineTo(centerX + 80 + 50, centerY - 50);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 50, centerY - 40);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 40, centerY - 50);
                    ctx.stroke();

                    // Draw chromosome change with gradient and glow
                    const chromosomeY = canvas.height / 2 + 100;
                    
                    // Add glow effect
                    if (chromosomeChange.glow > 0) {
                        ctx.shadowBlur = 15 * chromosomeChange.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Create gradient for chromosomes
                    const chromosomeGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY - 50,
                        centerX + 30, chromosomeY + 20
                    );
                    chromosomeGradient.addColorStop(0, 'rgba(255, 170, 170, 0.8)');
                    chromosomeGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    chromosomeGradient.addColorStop(1, 'rgba(170, 170, 255, 0.8)');
                    
                    ctx.strokeStyle = chromosomeGradient;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY - 20);
                    ctx.lineTo(centerX - 10, chromosomeY - 50 + chromosomeChange.progress * 30);
                    ctx.lineTo(centerX + 10, chromosomeY - 50 + chromosomeChange.progress * 30);
                    ctx.lineTo(centerX + 30, chromosomeY - 20);
                    ctx.stroke();

                    // Simulate X to Y (one line shortening, another appearing) with gradient
                    const xGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY + 20,
                        centerX + 30, chromosomeY - 20
                    );
                    xGradient.addColorStop(0, 'rgba(255, 170, 170, 0.8)');
                    xGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.strokeStyle = xGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY + 20);
                    ctx.lineTo(centerX + 30, chromosomeY + 20 - chromosomeChange.progress * 40);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "CHROMOSOME" label with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * chromosomeChange.glow})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * chromosomeChange.glow;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.fillText('CHROMOSOME', canvas.width / 2, chromosomeY + 60);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            }, "-=0.3")
            .to(hormoneLevel, {
                f: 0,
                m: 1,
                glow: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Update and draw gender particles
                    genderParticles.forEach(particle => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(${particle.color}, ${particle.opacity})`);
                        particleGradient.addColorStop(1, `rgba(${particle.color}, 0)`);
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Redraw previous elements with reduced opacity
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Female symbol with reduced opacity
                    const femaleGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 30,
                        centerX + 30, centerY + 60
                    );
                    femaleGradient.addColorStop(0, 'rgba(255, 170, 170, 0.2)');
                    femaleGradient.addColorStop(0.5, 'rgba(255, 200, 200, 0.2)');
                    femaleGradient.addColorStop(1, 'rgba(255, 230, 230, 0.2)');
                    
                    ctx.strokeStyle = femaleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX, centerY + 30);
                    ctx.lineTo(centerX, centerY + 60);
                    ctx.stroke();
                    
                    // Male symbol with reduced opacity
                    const maleGradient = ctx.createLinearGradient(
                        centerX + 50, centerY - 50,
                        centerX + 110, centerY + 30
                    );
                    maleGradient.addColorStop(0, 'rgba(170, 170, 255, 0.2)');
                    maleGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.2)');
                    maleGradient.addColorStop(1, 'rgba(230, 230, 255, 0.2)');
                    
                    ctx.strokeStyle = maleGradient;
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX + 80 + 20, centerY - 20);
                    ctx.lineTo(centerX + 80 + 50, centerY - 50);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 50, centerY - 40);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 40, centerY - 50);
                    ctx.stroke();

                    // Redraw chromosome with reduced opacity
                    const chromosomeY = canvas.height / 2 + 100;
                    const chromosomeGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY - 50,
                        centerX + 30, chromosomeY + 20
                    );
                    chromosomeGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
                    chromosomeGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.3)');
                    chromosomeGradient.addColorStop(1, 'rgba(170, 170, 255, 0.3)');
                    
                    ctx.strokeStyle = chromosomeGradient;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY - 20);
                    ctx.lineTo(centerX - 10, chromosomeY - 20);
                    ctx.lineTo(centerX + 10, chromosomeY - 20);
                    ctx.lineTo(centerX + 30, chromosomeY - 20);
                    ctx.stroke();

                    const xGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY + 20,
                        centerX + 30, chromosomeY - 20
                    );
                    xGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
                    xGradient.addColorStop(1, 'rgba(200, 200, 255, 0.3)');
                    
                    ctx.strokeStyle = xGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY + 20);
                    ctx.lineTo(centerX + 30, chromosomeY - 20);
                    ctx.stroke();

                    // Draw hormone level chart with gradient and glow
                    const chartY = canvas.height / 2 + 200;
                    
                    // Add glow effect
                    if (hormoneLevel.glow > 0) {
                        ctx.shadowBlur = 15 * hormoneLevel.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Chart background with gradient
                    const chartBgGradient = ctx.createLinearGradient(
                        centerX - 100, chartY - 100,
                        centerX + 100, chartY + 100
                    );
                    chartBgGradient.addColorStop(0, 'rgba(30, 30, 50, 0.8)');
                    chartBgGradient.addColorStop(1, 'rgba(10, 10, 30, 0.8)');
                    
                    ctx.fillStyle = chartBgGradient;
                    ctx.fillRect(centerX - 110, chartY - 110, 220, 220);
                    
                    // Chart axes
                    ctx.strokeStyle = 'rgba(170, 170, 200, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY);
                    ctx.lineTo(centerX + 100, chartY);
                    ctx.moveTo(centerX - 100, chartY - 100);
                    ctx.lineTo(centerX - 100, chartY + 100);
                    ctx.stroke();

                    // Female hormone line with gradient
                    const fGradient = ctx.createLinearGradient(
                        centerX - 100, chartY - 100,
                        centerX, chartY + 100
                    );
                    fGradient.addColorStop(0, 'rgba(255, 170, 170, 0.8)');
                    fGradient.addColorStop(1, 'rgba(255, 200, 200, 0.8)');
                    
                    ctx.strokeStyle = fGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY - 100 + (1 - hormoneLevel.f) * 100);
                    ctx.lineTo(centerX, chartY - 100 + (1 - hormoneLevel.f) * 100);
                    ctx.stroke();

                    // Male hormone line with gradient
                    const mGradient = ctx.createLinearGradient(
                        centerX, chartY - 100,
                        centerX + 100, chartY + 100
                    );
                    mGradient.addColorStop(0, 'rgba(170, 170, 255, 0.8)');
                    mGradient.addColorStop(1, 'rgba(200, 200, 255, 0.8)');
                    
                    ctx.strokeStyle = mGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, chartY - 100 + (1 - hormoneLevel.m) * 100);
                    ctx.lineTo(centerX + 100, chartY - 100 + (1 - hormoneLevel.m) * 100);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                    // Add hormone labels
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = 'rgba(255, 170, 170, 0.8)';
                    ctx.fillText('F', centerX - 110, chartY - 100 + (1 - hormoneLevel.f) * 100 + 5);
                    ctx.fillStyle = 'rgba(170, 170, 255, 0.8)';
                    ctx.fillText('M', centerX + 110, chartY - 100 + (1 - hormoneLevel.m) * 100 + 5);
                    
                    // Add "HORMONE" label with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * hormoneLevel.glow})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * hormoneLevel.glow;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.fillText('HORMONE', canvas.width / 2, chartY + 130);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            }, "-=0.3")
            .to(socialRole, {
                opacity: 1,
                glow: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    bgGradient.addColorStop(1, '#000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Update and draw gender particles
                    genderParticles.forEach(particle => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                        
                        const particleGradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 2
                        );
                        particleGradient.addColorStop(0, `rgba(${particle.color}, ${particle.opacity})`);
                        particleGradient.addColorStop(1, `rgba(${particle.color}, 0)`);
                        
                        ctx.fillStyle = particleGradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Redraw previous elements with reduced opacity
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Female symbol with reduced opacity
                    const femaleGradient = ctx.createLinearGradient(
                        centerX - 30, centerY - 30,
                        centerX + 30, centerY + 60
                    );
                    femaleGradient.addColorStop(0, 'rgba(255, 170, 170, 0.2)');
                    femaleGradient.addColorStop(0.5, 'rgba(255, 200, 200, 0.2)');
                    femaleGradient.addColorStop(1, 'rgba(255, 230, 230, 0.2)');
                    
                    ctx.strokeStyle = femaleGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX, centerY + 30);
                    ctx.lineTo(centerX, centerY + 60);
                    ctx.stroke();
                    
                    // Male symbol with reduced opacity
                    const maleGradient = ctx.createLinearGradient(
                        centerX + 50, centerY - 50,
                        centerX + 110, centerY + 30
                    );
                    maleGradient.addColorStop(0, 'rgba(170, 170, 255, 0.2)');
                    maleGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.2)');
                    maleGradient.addColorStop(1, 'rgba(230, 230, 255, 0.2)');
                    
                    ctx.strokeStyle = maleGradient;
                    ctx.beginPath();
                    ctx.arc(centerX + 80, centerY, 30, 0, Math.PI * 2);
                    ctx.moveTo(centerX + 80 + 20, centerY - 20);
                    ctx.lineTo(centerX + 80 + 50, centerY - 50);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 50, centerY - 40);
                    ctx.moveTo(centerX + 80 + 50, centerY - 50);
                    ctx.lineTo(centerX + 80 + 40, centerY - 50);
                    ctx.stroke();

                    // Redraw chromosome with reduced opacity
                    const chromosomeY = canvas.height / 2 + 100;
                    const chromosomeGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY - 50,
                        centerX + 30, chromosomeY + 20
                    );
                    chromosomeGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
                    chromosomeGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.3)');
                    chromosomeGradient.addColorStop(1, 'rgba(170, 170, 255, 0.3)');
                    
                    ctx.strokeStyle = chromosomeGradient;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY - 20);
                    ctx.lineTo(centerX - 10, chromosomeY - 20);
                    ctx.lineTo(centerX + 10, chromosomeY - 20);
                    ctx.lineTo(centerX + 30, chromosomeY - 20);
                    ctx.stroke();

                    const xGradient = ctx.createLinearGradient(
                        centerX - 30, chromosomeY + 20,
                        centerX + 30, chromosomeY - 20
                    );
                    xGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
                    xGradient.addColorStop(1, 'rgba(200, 200, 255, 0.3)');
                    
                    ctx.strokeStyle = xGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, chromosomeY + 20);
                    ctx.lineTo(centerX + 30, chromosomeY - 20);
                    ctx.stroke();

                    // Redraw hormone level chart with reduced opacity
                    const chartY = canvas.height / 2 + 200;
                    
                    // Chart background with gradient
                    const chartBgGradient = ctx.createLinearGradient(
                        centerX - 100, chartY - 100,
                        centerX + 100, chartY + 100
                    );
                    chartBgGradient.addColorStop(0, 'rgba(30, 30, 50, 0.4)');
                    chartBgGradient.addColorStop(1, 'rgba(10, 10, 30, 0.4)');
                    
                    ctx.fillStyle = chartBgGradient;
                    ctx.fillRect(centerX - 110, chartY - 110, 220, 220);
                    
                    // Chart axes
                    ctx.strokeStyle = 'rgba(170, 170, 200, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY);
                    ctx.lineTo(centerX + 100, chartY);
                    ctx.moveTo(centerX - 100, chartY - 100);
                    ctx.lineTo(centerX - 100, chartY + 100);
                    ctx.stroke();

                    // Female hormone line with gradient
                    const fGradient = ctx.createLinearGradient(
                        centerX - 100, chartY - 100,
                        centerX, chartY + 100
                    );
                    fGradient.addColorStop(0, 'rgba(255, 170, 170, 0.4)');
                    fGradient.addColorStop(1, 'rgba(255, 200, 200, 0.4)');
                    
                    ctx.strokeStyle = fGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY - 100 + (1 - 0) * 100);
                    ctx.lineTo(centerX, chartY - 100 + (1 - 0) * 100);
                    ctx.stroke();

                    // Male hormone line with gradient
                    const mGradient = ctx.createLinearGradient(
                        centerX, chartY - 100,
                        centerX + 100, chartY + 100
                    );
                    mGradient.addColorStop(0, 'rgba(170, 170, 255, 0.4)');
                    mGradient.addColorStop(1, 'rgba(200, 200, 255, 0.4)');
                    
                    ctx.strokeStyle = mGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, chartY - 100 + (1 - 1) * 100);
                    ctx.lineTo(centerX + 100, chartY - 100 + (1 - 1) * 100);
                    ctx.stroke();
                    
                    // Draw social role icons with gradient and glow
                    const socialY = canvas.height / 2 + 180;
                    
                    // Add glow effect
                    if (socialRole.glow > 0) {
                        ctx.shadowBlur = 15 * socialRole.glow;
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    }
                    
                    // Social role background with gradient
                    const socialBgGradient = ctx.createLinearGradient(
                        centerX - 200, socialY - 50,
                        centerX + 200, socialY + 50
                    );
                    socialBgGradient.addColorStop(0, 'rgba(30, 30, 50, 0.8)');
                    socialBgGradient.addColorStop(1, 'rgba(10, 10, 30, 0.8)');
                    
                    ctx.fillStyle = socialBgGradient;
                    ctx.fillRect(centerX - 210, socialY - 60, 420, 120);
                    
                    // Female social role icon with gradient
                    const femaleIconGradient = ctx.createLinearGradient(
                        centerX - 180, socialY - 30,
                        centerX - 180, socialY + 30
                    );
                    femaleIconGradient.addColorStop(0, 'rgba(255, 170, 170, 0.8)');
                    femaleIconGradient.addColorStop(0.5, 'rgba(255, 200, 200, 0.8)');
                    femaleIconGradient.addColorStop(1, 'rgba(255, 230, 230, 0.8)');
                    
                    ctx.fillStyle = femaleIconGradient;
                    ctx.font = '30px Arial';
                    ctx.fillText('♀', centerX - 180, socialY);
                    
                    // Male social role icon with gradient
                    const maleIconGradient = ctx.createLinearGradient(
                        centerX + 160, socialY - 30,
                        centerX + 160, socialY + 30
                    );
                    maleIconGradient.addColorStop(0, 'rgba(170, 170, 255, 0.8)');
                    maleIconGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    maleIconGradient.addColorStop(1, 'rgba(230, 230, 255, 0.8)');
                    
                    ctx.fillStyle = maleIconGradient;
                    ctx.fillText('♂', centerX + 160, socialY);
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "SOCIAL ROLE" label with glow
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * socialRole.glow})`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 10 * socialRole.glow;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.fillText('SOCIAL ROLE', canvas.width / 2, socialY + 50);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            });

            return timeline;
        }

        // Scene 24: "And then do whatever From AM to PM" / "只做想做的事 从早到晚"
        function scene24() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const clockRotation = {
                angle: 0
            };
            const activityIcons = {
                progress: 0
            };
            const freedomDisplay = {
                value: 0
            };
            const timeMarkers = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add time particles for visual enhancement
            const timeParticles = [];
            for (let i = 0; i < 30; i++) {
                timeParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 0.5 + 0.2,
                    opacity: Math.random() * 0.5 + 0.3
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw time particles
                    timeParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(150, 150, 255, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.y -= particle.speed;
                        if (particle.y < 0) {
                            particle.y = canvas.height;
                            particle.x = Math.random() * canvas.width;
                        }
                    });
                }
            })
            .to(clockRotation, {
                angle: Math.PI * 2,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw time particles
                    timeParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(150, 150, 255, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.y -= particle.speed;
                        if (particle.y < 0) {
                            particle.y = canvas.height;
                            particle.x = Math.random() * canvas.width;
                        }
                    });

                    // Draw clock with glow effect
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Clock glow
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    
                    // Clock face with gradient
                    const clockGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80);
                    clockGradient.addColorStop(0, 'rgba(80, 80, 120, 0.9)');
                    clockGradient.addColorStop(1, 'rgba(40, 40, 80, 0.7)');
                    ctx.strokeStyle = clockGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Reset shadow for clock hands
                    ctx.shadowBlur = 0;
                    
                    // Clock hands with glow
                    ctx.strokeStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Hour hand
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + 50 * Math.sin(clockRotation.angle), centerY - 50 * Math.cos(clockRotation.angle));
                    ctx.stroke();

                    // Minute hand
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + 70 * Math.sin(clockRotation.angle / 12), centerY - 70 * Math.cos(clockRotation.angle / 12));
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;

                    // Draw time markers with glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = 'bold 18px Arial';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.fillText('AM', centerX - 20, centerY - 100);
                    ctx.fillText('PM', centerX - 20, centerY + 120);
                    ctx.shadowBlur = 0;
                    
                    // Draw "TIME" label with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    const textWidth = ctx.measureText('TIME').width;
                    ctx.fillText('TIME', centerX - textWidth/2, centerY + 140);
                    ctx.shadowBlur = 0;
                }
            })
            .to(activityIcons, {
                progress: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw time particles
                    timeParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(150, 150, 255, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.y -= particle.speed;
                        if (particle.y < 0) {
                            particle.y = canvas.height;
                            particle.x = Math.random() * canvas.width;
                        }
                    });

                    // Redraw clock with reduced opacity
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.4)';
                    ctx.shadowBlur = 10;
                    
                    const clockGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80);
                    clockGradient.addColorStop(0, 'rgba(80, 80, 120, 0.5)');
                    clockGradient.addColorStop(1, 'rgba(40, 40, 80, 0.3)');
                    ctx.strokeStyle = clockGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;

                    // Draw activity icons with glow (different shades of grey, rotating around clock)
                    const iconRadius = 100;
                    const activities = ["📚", "🏃", "🎨"]; // Reading, Running, Art

                    activities.forEach((icon, index) => {
                        const angle = (index / activities.length) * Math.PI * 2 + activityIcons.progress * Math.PI * 2;
                        const x = centerX + iconRadius * Math.sin(angle);
                        const y = centerY - iconRadius * Math.cos(angle);
                        
                        // Icon glow
                        ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                        ctx.shadowBlur = 15;
                        
                        ctx.font = '30px Arial';
                        ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                        ctx.fillText(icon, x - 15, y + 10);
                    });
                    
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(freedomDisplay, {
                value: 100,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw time particles
                    timeParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(150, 150, 255, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.y -= particle.speed;
                        if (particle.y < 0) {
                            particle.y = canvas.height;
                            particle.x = Math.random() * canvas.width;
                        }
                    });

                    // Redraw previous elements with reduced opacity

                    // Draw freedom percentage with glow
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = `rgba(200, 200, 255, ${freedomDisplay.value / 100})`;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillText(`${Math.round(freedomDisplay.value)}% Freedom`, canvas.width / 2 - 120, canvas.height / 2 + 150);
                    ctx.shadowBlur = 0;
                }
            })
            .to(timeMarkers, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(20, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(10, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw time particles
                    timeParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(150, 150, 255, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.y -= particle.speed;
                        if (particle.y < 0) {
                            particle.y = canvas.height;
                            particle.x = Math.random() * canvas.width;
                        }
                    });

                    // Redraw previous elements with reduced opacity

                    // Draw time markers with glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Clock circle with glow
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${timeMarkers.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Time markers with glow
                    ctx.fillStyle = `rgba(255, 255, 255, ${timeMarkers.opacity})`;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('6 AM', centerX + 60, centerY - 60);
                    ctx.fillText('6 PM', centerX - 70, centerY + 70);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 25: "Oh switch my role To S to M" / "切换我的角色 从施虐者到受虐者"
        function scene25() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const scepterSwitch = {
                progress: 0
            };
            const powerChart = {
                s: 1,
                m: 0
            };
            const brainwave = {
                amplitude: 0
            };
            const maskOpacity = {
                s: 1,
                m: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add power particles for visual enhancement
            const powerParticles = [];
            for (let i = 0; i < 25; i++) {
                powerParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    color: Math.random() > 0.5 ? '170, 170, 255' : '255, 170, 170' // Blue or pink
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw power particles
                    powerParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });
                }
            })
            .to(scepterSwitch, {
                progress: 1,
                duration: 0.5,
                ease: "power1.inOut",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw power particles
                    powerParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Draw S and M scepters with glow and gradient
                    const sX = canvas.width / 2 - 100 + scepterSwitch.progress * 200;
                    const mX = canvas.width / 2 + 100 - scepterSwitch.progress * 200;

                    // S scepter with blue glow
                    ctx.font = 'bold 60px Arial';
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    
                    const sGradient = ctx.createLinearGradient(sX - 30, canvas.height / 2 - 30, sX + 30, canvas.height / 2 + 30);
                    sGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    sGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    sGradient.addColorStop(1, 'rgba(140, 140, 255, 1)');
                    ctx.fillStyle = sGradient;
                    ctx.fillText('S', sX - 30, canvas.height / 2 + 20);
                    
                    // M scepter with pink glow
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.8)';
                    ctx.shadowBlur = 20;
                    
                    const mGradient = ctx.createLinearGradient(mX - 30, canvas.height / 2 - 30, mX + 30, canvas.height / 2 + 30);
                    mGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    mGradient.addColorStop(0.5, 'rgba(255, 170, 170, 1)');
                    mGradient.addColorStop(1, 'rgba(255, 140, 140, 1)');
                    ctx.fillStyle = mGradient;
                    ctx.fillText('M', mX - 30, canvas.height / 2 + 20);
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "ROLE SWITCH" label with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    const textWidth = ctx.measureText('ROLE SWITCH').width;
                    ctx.fillText('ROLE SWITCH', canvas.width / 2 - textWidth/2, canvas.height / 2 + 80);
                    ctx.shadowBlur = 0;
                }
            })
            .to(powerChart, {
                s: 0,
                m: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw power particles
                    powerParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw scepters with reduced opacity
                    const sX = canvas.width / 2 + 100;
                    const mX = canvas.width / 2 - 100;

                    ctx.font = 'bold 60px Arial';
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.4)';
                    ctx.shadowBlur = 10;
                    
                    const sGradient = ctx.createLinearGradient(sX - 30, canvas.height / 2 - 30, sX + 30, canvas.height / 2 + 30);
                    sGradient.addColorStop(0, 'rgba(200, 200, 255, 0.5)');
                    sGradient.addColorStop(0.5, 'rgba(170, 170, 255, 0.5)');
                    sGradient.addColorStop(1, 'rgba(140, 140, 255, 0.5)');
                    ctx.fillStyle = sGradient;
                    ctx.fillText('S', sX - 30, canvas.height / 2 + 20);
                    
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.4)';
                    ctx.shadowBlur = 10;
                    
                    const mGradient = ctx.createLinearGradient(mX - 30, canvas.height / 2 - 30, mX + 30, canvas.height / 2 + 30);
                    mGradient.addColorStop(0, 'rgba(255, 200, 200, 0.5)');
                    mGradient.addColorStop(0.5, 'rgba(255, 170, 170, 0.5)');
                    mGradient.addColorStop(1, 'rgba(255, 140, 140, 0.5)');
                    ctx.fillStyle = mGradient;
                    ctx.fillText('M', mX - 30, canvas.height / 2 + 20);
                    
                    ctx.shadowBlur = 0;

                    // Draw power chart with glow
                    const centerX = canvas.width / 2;
                    const chartY = canvas.height / 2 + 100;
                    
                    // Chart background with gradient
                    const chartBgGradient = ctx.createLinearGradient(
                        centerX - 120, chartY - 70,
                        centerX + 120, chartY + 70
                    );
                    chartBgGradient.addColorStop(0, 'rgba(30, 20, 40, 0.8)');
                    chartBgGradient.addColorStop(1, 'rgba(15, 10, 30, 0.8)');
                    
                    ctx.fillStyle = chartBgGradient;
                    ctx.fillRect(centerX - 120, chartY - 70, 240, 140);
                    
                    // Chart axes with glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = 'rgba(200, 200, 255, 1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY);
                    ctx.lineTo(centerX + 100, chartY);
                    ctx.moveTo(centerX - 100, chartY - 50);
                    ctx.lineTo(centerX - 100, chartY + 50);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // S power line with gradient
                    const sLineGradient = ctx.createLinearGradient(
                        centerX - 100, chartY - 50,
                        centerX, chartY + 50
                    );
                    sLineGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    sLineGradient.addColorStop(1, 'rgba(170, 170, 255, 1)');
                    
                    ctx.strokeStyle = sLineGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 100, chartY - powerChart.s * 40);
                    ctx.lineTo(centerX, chartY + powerChart.s * 40);
                    ctx.stroke();

                    // M power line with gradient
                    const mLineGradient = ctx.createLinearGradient(
                        centerX, chartY - 50,
                        centerX + 100, chartY + 50
                    );
                    mLineGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    mLineGradient.addColorStop(1, 'rgba(255, 170, 170, 1)');
                    
                    ctx.strokeStyle = mLineGradient;
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(centerX + 100, chartY - powerChart.m * 40);
                    ctx.lineTo(centerX, chartY + powerChart.m * 40);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Add "POWER" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const powerTextWidth = ctx.measureText('POWER').width;
                    ctx.fillText('POWER', centerX - powerTextWidth/2, chartY - 60);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(brainwave, {
                amplitude: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw power particles
                    powerParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw previous elements with reduced opacity

                    // Draw brainwave with glow
                    const waveGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 - 110,
                        canvas.width / 2 + 100, canvas.height / 2 - 90
                    );
                    waveGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    waveGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    waveGradient.addColorStop(1, 'rgba(255, 200, 200, 1)');
                    
                    ctx.strokeStyle = waveGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 - 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 - 100 + Math.sin(x * 0.1) * 10 * brainwave.amplitude;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Add "BRAINWAVE" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const waveTextWidth = ctx.measureText('BRAINWAVE').width;
                    ctx.fillText('BRAINWAVE', canvas.width / 2 - waveTextWidth/2, canvas.height / 2 - 120);
                    ctx.shadowBlur = 0;
                }
            })
            .to(maskOpacity, {
                s: 0,
                m: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw power particles
                    powerParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw previous elements with reduced opacity

                    // Draw masks with glow
                    // S mask with blue glow
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    
                    const sMaskGradient = ctx.createRadialGradient(
                        canvas.width / 2 - 80, canvas.height / 2 - 150, 0,
                        canvas.width / 2 - 80, canvas.height / 2 - 150, 30
                    );
                    sMaskGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    sMaskGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.8)');
                    sMaskGradient.addColorStop(1, 'rgba(140, 140, 255, 0.6)');
                    
                    ctx.fillStyle = sMaskGradient;
                    ctx.globalAlpha = maskOpacity.s;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 80, canvas.height / 2 - 150, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // M mask with pink glow
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.8)';
                    ctx.shadowBlur = 15;
                    
                    const mMaskGradient = ctx.createRadialGradient(
                        canvas.width / 2 + 80, canvas.height / 2 - 150, 0,
                        canvas.width / 2 + 80, canvas.height / 2 - 150, 30
                    );
                    mMaskGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    mMaskGradient.addColorStop(0.7, 'rgba(255, 170, 170, 0.8)');
                    mMaskGradient.addColorStop(1, 'rgba(255, 140, 140, 0.6)');
                    
                    ctx.fillStyle = mMaskGradient;
                    ctx.globalAlpha = maskOpacity.m;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 80, canvas.height / 2 - 150, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "MASK" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const maskTextWidth = ctx.measureText('MASK').width;
                    ctx.fillText('MASK', canvas.width / 2 - maskTextWidth/2, canvas.height / 2 - 190);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 26: "So we can enter The trance the trance" / "这样我们就可以 恍惚出神"
        function scene26() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const spiralRotation = {
                angle: 0
            };
            const brainwaveChange = {
                beta: 1,
                theta: 0
            };
            const blurEffect = {
                value: 0
            };
            const depthDisplay = {
                value: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add trance particles for visual enhancement
            const tranceParticles = [];
            for (let i = 0; i < 30; i++) {
                tranceParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speedX: (Math.random() - 0.5) * 0.3,
                    speedY: (Math.random() - 0.5) * 0.3,
                    opacity: Math.random() * 0.3 + 0.2,
                    color: Math.random() > 0.5 ? '200, 200, 255' : '255, 200, 200' // Light blue or light pink
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw trance particles
                    tranceParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });
                }
            })
            .to(spiralRotation, {
                angle: Math.PI * 4,
                duration: 1.5,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw trance particles
                    tranceParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Draw hypnotizing spiral with glow
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;

                    // Add glow effect to spiral center
                    const spiralGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
                    spiralGlow.addColorStop(0, 'rgba(200, 200, 255, 0.8)');
                    spiralGlow.addColorStop(0.5, 'rgba(150, 150, 255, 0.4)');
                    spiralGlow.addColorStop(1, 'rgba(100, 100, 255, 0)');
                    
                    ctx.fillStyle = spiralGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                    ctx.fill();

                    for (let i = 0; i < 100; i++) {
                        const radius = i * 2;
                        const angle = i * 0.1 + spiralRotation.angle;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        
                        // Add glow to spiral particles
                        if (i % 2 === 0) {
                            ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                            ctx.shadowBlur = 10;
                            ctx.fillStyle = '#FFF';
                        } else {
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#000';
                        }
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                    // Add "TRANCE" label with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    const textWidth = ctx.measureText('TRANCE').width;
                    ctx.fillText('TRANCE', canvas.width / 2 - textWidth/2, canvas.height / 2 + 180);
                    ctx.shadowBlur = 0;
                }
            })
            .to(brainwaveChange, {
                beta: 0,
                theta: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw trance particles
                    tranceParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw spiral with reduced opacity
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const spiralGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
                    spiralGlow.addColorStop(0, 'rgba(200, 200, 255, 0.4)');
                    spiralGlow.addColorStop(0.5, 'rgba(150, 150, 255, 0.2)');
                    spiralGlow.addColorStop(1, 'rgba(100, 100, 255, 0)');
                    
                    ctx.fillStyle = spiralGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                    ctx.fill();

                    for (let i = 0; i < 100; i++) {
                        const radius = i * 2;
                        const angle = i * 0.1 + spiralRotation.angle;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        
                        if (i % 2 === 0) {
                            ctx.shadowColor = 'rgba(200, 200, 255, 0.4)';
                            ctx.shadowBlur = 5;
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        } else {
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        }
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;

                    // Draw brainwave change with glow
                    // Beta waves with blue glow
                    const betaGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 80,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    betaGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    betaGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    betaGradient.addColorStop(1, 'rgba(140, 140, 255, 1)');
                    
                    ctx.strokeStyle = betaGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.2) * 20 * brainwaveChange.beta;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();

                    // Theta waves with pink glow
                    const thetaGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 80,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    thetaGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    thetaGradient.addColorStop(0.5, 'rgba(255, 170, 170, 1)');
                    thetaGradient.addColorStop(1, 'rgba(255, 140, 140, 1)');
                    
                    ctx.strokeStyle = thetaGradient;
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 30 * brainwaveChange.theta;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Add "BRAINWAVE" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const waveTextWidth = ctx.measureText('BRAINWAVE').width;
                    ctx.fillText('BRAINWAVE', canvas.width / 2 - waveTextWidth/2, canvas.height / 2 + 60);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(blurEffect, {
                value: 10,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw trance particles
                    tranceParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Apply blur effect
                    ctx.filter = `blur(${blurEffect.value}px)`;
                    
                    // Draw DIZZY text with glow
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = 'bold 40px Arial';
                    const dizzyText = 'DIZZY';
                    const dizzyTextWidth = ctx.measureText(dizzyText).width;
                    ctx.fillText(dizzyText, canvas.width / 2 - dizzyTextWidth / 2, canvas.height / 2);
                    ctx.filter = "none"; // Reset filter for subsequent draws
                    ctx.shadowBlur = 0;
                }
            })
            .to(depthDisplay, {
                value: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw trance particles
                    tranceParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw blurred text
                    ctx.filter = `blur(10px)`;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = 'bold 40px Arial';
                    ctx.fillText('TRANCE', canvas.width / 2 - 60, canvas.height / 2);
                    ctx.filter = "none";
                    ctx.shadowBlur = 0;

                    // Draw depth display with gradient and glow
                    const depthGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 10, canvas.height / 2 + 150,
                        canvas.width / 2 + 10, canvas.height / 2 + 250
                    );
                    depthGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    depthGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    depthGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.fillStyle = depthGradient;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 10, canvas.height / 2 + 150, 20, 100 * depthDisplay.value);
                    ctx.shadowBlur = 0;
                    
                    // Add "DEPTH" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const depthTextWidth = ctx.measureText('DEPTH').width;
                    ctx.fillText('DEPTH', canvas.width / 2 - depthTextWidth/2, canvas.height / 2 + 130);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 27: "If I can feel your VIBRATIONS" / "如果我能够感受到 你的振动"
        function scene27() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const vibrationWave = {
                amplitude: 0
            };
            const brainReaction = {
                level: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add vibration particles for visual enhancement
            const vibrationParticles = [];
            for (let i = 0; i < 25; i++) {
                vibrationParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speedX: (Math.random() - 0.5) * 0.2,
                    speedY: (Math.random() - 0.5) * 0.2,
                    opacity: Math.random() * 0.3 + 0.2,
                    color: Math.random() > 0.5 ? '200, 200, 255' : '255, 200, 200' // Light blue or light pink
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw vibration particles
                    vibrationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });
                }
            })
            .to(vibrationWave, {
                amplitude: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw vibration particles
                    vibrationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Draw vibration wave with gradient and glow
                    const waveGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 80,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    waveGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    waveGradient.addColorStop(0.5, 'rgba(170, 170, 255, 1)');
                    waveGradient.addColorStop(1, 'rgba(140, 140, 255, 1)');
                    
                    ctx.strokeStyle = waveGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 20 * vibrationWave.amplitude;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Add "VIBRATIONS" label with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    const waveTextWidth = ctx.measureText('VIBRATIONS').width;
                    ctx.fillText('VIBRATIONS', canvas.width / 2 - waveTextWidth/2, canvas.height / 2 + 60);
                    ctx.shadowBlur = 0;
                }
            })
            .to(brainReaction, {
                level: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw vibration particles
                    vibrationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw vibration wave with reduced opacity
                    const waveGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 80,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    waveGradient.addColorStop(0, 'rgba(200, 200, 255, 0.7)');
                    waveGradient.addColorStop(0.5, 'rgba(170, 170, 255, 0.7)');
                    waveGradient.addColorStop(1, 'rgba(140, 140, 255, 0.7)');
                    
                    ctx.strokeStyle = waveGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.5)';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    for (let x = 0; x < 200; x += 5) {
                        const y = canvas.height / 2 + 100 + Math.sin(x * 0.1) * 20 * vibrationWave.amplitude;
                        ctx.lineTo(canvas.width / 2 - 100 + x, y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Draw brain model with gradient and glow
                    const brainGradient = ctx.createRadialGradient(
                        canvas.width / 2 + 150, canvas.height / 2, 0,
                        canvas.width / 2 + 150, canvas.height / 2, 50
                    );
                    brainGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    brainGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    brainGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.strokeStyle = brainGradient;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 150, canvas.height / 2, 50, 0, Math.PI * 2); // Brain outline
                    ctx.stroke();

                    // Activated region with gradient and glow
                    const activationGradient = ctx.createRadialGradient(
                        canvas.width / 2 + 150 - 20, canvas.height / 2 + 20, 0,
                        canvas.width / 2 + 150 - 20, canvas.height / 2 + 20, 20
                    );
                    activationGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    activationGradient.addColorStop(0.5, 'rgba(255, 170, 170, 1)');
                    activationGradient.addColorStop(1, 'rgba(255, 140, 140, 1)');
                    
                    ctx.fillStyle = activationGradient;
                    ctx.shadowColor = 'rgba(255, 170, 170, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 150 - 20, canvas.height / 2 + 20, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Add "BRAIN REACTION" label with glow
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'rgba(200, 200, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    const brainTextWidth = ctx.measureText('BRAIN REACTION').width;
                    ctx.fillText('BRAIN REACTION', canvas.width / 2 + 150 - 60, canvas.height / 2 + 80);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 28: "Then I can finally be COMPLETION" / "那么我就能够 最终完成"
        function scene28() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const completionText = {
                opacity: 0
            };
            const completionSymbol = {
                scale: 0,
                rotation: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add completion particles for visual enhancement
            const completionParticles = [];
            for (let i = 0; i < 30; i++) {
                completionParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speedX: (Math.random() - 0.5) * 0.2,
                    speedY: (Math.random() - 0.5) * 0.2,
                    opacity: Math.random() * 0.3 + 0.2,
                    color: Math.random() > 0.5 ? '200, 200, 255' : '255, 200, 200' // Light blue or light pink
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw completion particles
                    completionParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });
                }
            })
            .to(completionText, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw completion particles
                    completionParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Draw completion text with glow
                    ctx.font = 'bold 30px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${completionText.opacity})`;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('COMPLETION', canvas.width / 2 - 100, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(completionSymbol, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw completion particles
                    completionParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw completion text with glow
                    ctx.font = 'bold 30px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('COMPLETION', canvas.width / 2 - 100, canvas.height / 2);

                    // Draw completion symbol with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(completionSymbol.rotation);
                    ctx.scale(completionSymbol.scale, completionSymbol.scale);
                    
                    const symbolGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
                    symbolGradient.addColorStop(0, 'rgba(200, 200, 255, 1)');
                    symbolGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    symbolGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.fillStyle = symbolGradient;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, 50, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 29: "Though you have left You have left me in ISOLATION" / "但你离开了我 我被隔离了"
        function scene29() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const isolationText = {
                opacity: 0
            };
            const isolationSymbol = {
                scale: 0,
                rotation: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };
            
            // Add isolation particles for visual enhancement
            const isolationParticles = [];
            for (let i = 0; i < 25; i++) {
                isolationParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    speedX: (Math.random() - 0.5) * 0.15,
                    speedY: (Math.random() - 0.5) * 0.15,
                    opacity: Math.random() * 0.2 + 0.1,
                    color: Math.random() > 0.5 ? '150, 150, 255' : '255, 150, 150' // Blue or red
                });
            }

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw isolation particles
                    isolationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity * glow.intensity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });
                }
            })
            .to(isolationText, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw isolation particles
                    isolationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Draw isolation text with glow
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = `rgba(255, 255, 255, ${isolationText.opacity})`;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('ISOLATION', canvas.width / 2 - 50, canvas.height / 2 + 100);
                    ctx.shadowBlur = 0;
                }
            })
            .to(isolationSymbol, {
                scale: 1,
                rotation: Math.PI * 2,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw isolation particles
                    isolationParticles.forEach(particle => {
                        ctx.fillStyle = `rgba(${particle.color}, ${particle.opacity})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Update particle position
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        
                        if (particle.x < 0) particle.x = canvas.width;
                        if (particle.x > canvas.width) particle.x = 0;
                        if (particle.y < 0) particle.y = canvas.height;
                        if (particle.y > canvas.height) particle.y = 0;
                    });

                    // Redraw isolation text with glow
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('ISOLATION', canvas.width / 2 - 50, canvas.height / 2 + 100);

                    // Draw isolation symbol with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(isolationSymbol.rotation);
                    ctx.scale(isolationSymbol.scale, isolationSymbol.scale);
                    
                    const symbolGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
                    symbolGradient.addColorStop(0, 'rgba(150, 150, 255, 1)');
                    symbolGradient.addColorStop(0.5, 'rgba(120, 120, 120, 1)');
                    symbolGradient.addColorStop(1, 'rgba(90, 90, 90, 1)');
                    
                    ctx.fillStyle = symbolGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, 50, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 30: "If I can erase all the pointless FRAGMENTS" / "如果我能够消去 这些无意义的碎片"
        function scene30() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const fragments = [];
            for (let i = 0; i < 50; i++) {
                fragments.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 20 + 10,
                    rotation: Math.random() * Math.PI * 2,
                    color: Math.random() > 0.5 ? '150, 150, 255' : '255, 150, 150' // Blue or red
                });
            }
            const eraserProgress = {
                value: 0
            };
            const memoryClear = {
                fill: 0
            };
            const recombineFail = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to({}, {
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw pixel fragments with gradient and glow
                    fragments.forEach(f => {
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        ctx.rotate(f.rotation);
                        
                        const fragmentGradient = ctx.createLinearGradient(-f.size / 2, -f.size / 2, f.size / 2, f.size / 2);
                        fragmentGradient.addColorStop(0, `rgba(${f.color}, 0.7)`);
                        fragmentGradient.addColorStop(1, `rgba(${f.color}, 0.3)`);
                        
                        ctx.fillStyle = fragmentGradient;
                        ctx.shadowColor = `rgba(${f.color}, 0.8)`;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(-f.size / 2, -f.size / 2, f.size, f.size);
                        ctx.restore();
                    });
                    ctx.shadowBlur = 0;
                }
            })
            .to(eraserProgress, {
                value: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw fragments with gradient and glow
                    fragments.forEach(f => {
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        ctx.rotate(f.rotation);
                        
                        const fragmentGradient = ctx.createLinearGradient(-f.size / 2, -f.size / 2, f.size / 2, f.size / 2);
                        fragmentGradient.addColorStop(0, `rgba(${f.color}, 0.7)`);
                        fragmentGradient.addColorStop(1, `rgba(${f.color}, 0.3)`);
                        
                        ctx.fillStyle = fragmentGradient;
                        ctx.shadowColor = `rgba(${f.color}, 0.8)`;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(-f.size / 2, -f.size / 2, f.size, f.size);
                        ctx.restore();
                    });
                    ctx.shadowBlur = 0;

                    // Draw eraser with gradient and glow
                    const eraserGradient = ctx.createLinearGradient(0, canvas.height / 2 - 50, 0, canvas.height / 2 + 50);
                    eraserGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    eraserGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.8)');
                    eraserGradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.fillStyle = eraserGradient;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(0, canvas.height / 2 - 50, canvas.width * eraserProgress.value, 100);
                    ctx.shadowBlur = 0;
                }
            })
            .to(memoryClear, {
                fill: 100,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw memory clear progress bar with gradient and glow
                    const barGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 100, canvas.width / 2 + 100, canvas.height / 2 + 120);
                    barGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    barGradient.addColorStop(0.5, 'rgba(120, 120, 120, 0.8)');
                    barGradient.addColorStop(1, 'rgba(100, 100, 100, 0.8)');
                    
                    ctx.fillStyle = barGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 20);
                    
                    const fillGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 100, canvas.width / 2 - 100 + memoryClear.fill * 2, canvas.height / 2 + 120);
                    fillGradient.addColorStop(0, 'rgba(150, 150, 255, 0.9)');
                    fillGradient.addColorStop(0.5, 'rgba(180, 180, 255, 0.9)');
                    fillGradient.addColorStop(1, 'rgba(150, 150, 255, 0.9)');
                    
                    ctx.fillStyle = fillGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 100, memoryClear.fill * 2, 20);
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`${Math.round(memoryClear.fill)}% CLEARED`, canvas.width / 2 - 50, canvas.height / 2 + 130);
                    ctx.shadowBlur = 0;
                }
            })
            .to(recombineFail, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw fragments attempting to recombine and then dissipating with gradient and glow
                    for (let i = 0; i < 20; i++) {
                        const color = i % 2 === 0 ? '150, 150, 255' : '255, 150, 150';
                        ctx.fillStyle = `rgba(${color}, ${(1 - recombineFail.opacity) * 0.7})`;
                        ctx.shadowColor = `rgba(${color}, 0.8)`;
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2 + Math.random() * 100 - 50, canvas.height / 2 + Math.random() * 100 - 50, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 31: "Then maybe you won't leave me so DISHEARTENED" / "那么我就可能不会 如此失望"
        function scene31() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const heartbeat = {
                value: 0
            };
            const serotoninLevel = {
                value: 1
            };
            const emotionCurve = {
                value: 0
            };
            const psychologicalTrauma = {
                opacity: 0
            };

            timeline.to(heartbeat, {
                value: 1,
                duration: 0.5,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw heartbeat (light grey, becoming erratic)
                    ctx.strokeStyle = `rgba(170, 170, 170, 1)`; // Light grey
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2);
                    ctx.lineTo(canvas.width / 2 - 80, canvas.height / 2);
                    ctx.lineTo(canvas.width / 2 - 70, canvas.height / 2 - 20 * heartbeat.value);
                    ctx.lineTo(canvas.width / 2 - 60, canvas.height / 2 + 40 * heartbeat.value);
                    ctx.lineTo(canvas.width / 2 - 40, canvas.height / 2);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2);
                    ctx.stroke();
                }
            })
            .to(serotoninLevel, {
                value: 0,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw serotonin level (medium grey curve, falling)
                    ctx.strokeStyle = `rgba(100, 100, 100, 1)`; // Medium grey
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    ctx.lineTo(canvas.width / 2 + 100, canvas.height / 2 + 100 + serotoninLevel.value * 50);
                    ctx.stroke();
                }
            })
            .to(emotionCurve, {
                value: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw emotion curve (light grey, dropping sharply)
                    ctx.strokeStyle = `rgba(170, 170, 170, 1)`; // Light grey
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 - 50);
                    ctx.lineTo(canvas.width / 2 + 100, canvas.height / 2 - 50 + emotionCurve.value * 100);
                    ctx.stroke();
                }
            })
            .to(psychologicalTrauma, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw psychological trauma (grey cracks)
                    ctx.strokeStyle = `rgba(136, 136, 136, ${psychologicalTrauma.opacity})`; // #888888
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 50, canvas.height / 2 - 100);
                    ctx.lineTo(canvas.width / 2 - 80, canvas.height / 2 - 120);
                    ctx.moveTo(canvas.width / 2 + 50, canvas.height / 2 - 100);
                    ctx.lineTo(canvas.width / 2 + 80, canvas.height / 2 - 120);
                    ctx.stroke();
                }
            });

            return timeline;
        }

        // Scene 32: "Challenging your god You have made some ILLEGAL ARGUMENTS" / "与神作对 你传给我的是 非法参数"
        function scene32() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const errorWarning = {
                opacity: 0
            };
            const stackTrace = {
                progress: 0
            };
            const typeCheck = {
                progress: 0
            };
            const systemCrash = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(errorWarning, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw error warning dialog with gradient and glow
                    const dialogGradient = ctx.createLinearGradient(canvas.width / 2 - 150, canvas.height / 2 - 100, canvas.width / 2 + 150, canvas.height / 2);
                    dialogGradient.addColorStop(0, 'rgba(180, 180, 180, 0.9)');
                    dialogGradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.9)');
                    dialogGradient.addColorStop(1, 'rgba(180, 180, 180, 0.9)');
                    
                    ctx.fillStyle = dialogGradient;
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 100, 300, 80);
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 100, 100, 1)';
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('ILLEGAL ARGUMENT', canvas.width / 2 - 90, canvas.height / 2 - 60);
                    ctx.shadowBlur = 0;
                }
            })
            .to(stackTrace, {
                progress: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw error warning with gradient and glow
                    const dialogGradient = ctx.createLinearGradient(canvas.width / 2 - 150, canvas.height / 2 - 100, canvas.width / 2 + 150, canvas.height / 2);
                    dialogGradient.addColorStop(0, 'rgba(180, 180, 180, 0.9)');
                    dialogGradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.9)');
                    dialogGradient.addColorStop(1, 'rgba(180, 180, 180, 0.9)');
                    
                    ctx.fillStyle = dialogGradient;
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 100, 300, 80);
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 100, 100, 1)';
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('ILLEGAL ARGUMENT', canvas.width / 2 - 90, canvas.height / 2 - 60);
                    ctx.shadowBlur = 0;

                    // Draw stack trace with gradient and glow
                    const traceGradient = ctx.createLinearGradient(canvas.width / 2 - 50, canvas.height / 2 + 20, canvas.width / 2 + 50, canvas.height / 2 + 100);
                    traceGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    traceGradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.8)');
                    traceGradient.addColorStop(1, 'rgba(100, 100, 100, 0.8)');
                    
                    ctx.fillStyle = traceGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 50, canvas.height / 2 + 20, 100, 80 * stackTrace.progress);
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('funcA', canvas.width / 2 - 20, canvas.height / 2 + 40);
                    ctx.fillText('funcB', canvas.width / 2 - 20, canvas.height / 2 + 70);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(typeCheck, {
                progress: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw type validation with gradient and glow
                    const lineGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 150, canvas.width / 2 + 100, canvas.height / 2 + 150);
                    lineGradient.addColorStop(0, 'rgba(100, 100, 255, 0.8)');
                    lineGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    lineGradient.addColorStop(1, 'rgba(100, 100, 255, 0.8)');
                    
                    ctx.strokeStyle = lineGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 150);
                    ctx.lineTo(canvas.width / 2 + 100, canvas.height / 2 + 150);
                    
                    const crossGradient = ctx.createLinearGradient(canvas.width / 2 - 50, canvas.height / 2 + 130, canvas.width / 2 + 50, canvas.height / 2 + 170);
                    crossGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    crossGradient.addColorStop(0.5, 'rgba(255, 150, 150, 1)');
                    crossGradient.addColorStop(1, 'rgba(255, 100, 100, 0.8)');
                    
                    ctx.strokeStyle = crossGradient;
                    ctx.shadowColor = 'rgba(255, 150, 150, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 50, canvas.height / 2 + 130);
                    ctx.lineTo(canvas.width / 2 + 50, canvas.height / 2 + 170);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            })
            .to(systemCrash, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Draw gradient background with crash effect
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, `rgba(100, 50, 50, ${systemCrash.opacity})`);
                    gradient.addColorStop(0.5, `rgba(50, 20, 20, ${systemCrash.opacity})`);
                    gradient.addColorStop(1, `rgba(0, 0, 0, 1)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = 'rgba(255, 100, 100, 1)';
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.font = 'bold 30px Arial';
                    ctx.fillText('CRITICAL ERROR', canvas.width / 2 - 100, canvas.height / 2 - 50);
                    ctx.fillText('REBOOTING...', canvas.width / 2 - 80, canvas.height / 2 + 50);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 33: "EXECUTION EXECUTION EXECUTION EXECUTION" / "执行死刑 执行死刑 执行死刑 执行死刑"
        function scene33() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const executionText = {
                opacity: 0
            };
            const processTerminate = {
                scale: 0
            };
            const shutdownSequence = {
                progress: 0
            };
            const blueScreen = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(executionText, {
                opacity: 1,
                duration: 0.5,
                repeat: 7,
                yoyo: true,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw blinking EXECUTION text with gradient and glow
                    const textGradient = ctx.createLinearGradient(canvas.width / 2 - 150, canvas.height / 2 - 30, canvas.width / 2 + 150, canvas.height / 2 + 30);
                    textGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    textGradient.addColorStop(0.5, 'rgba(255, 150, 150, 1)');
                    textGradient.addColorStop(1, 'rgba(255, 100, 100, 0.8)');
                    
                    ctx.font = 'bold 60px Arial';
                    ctx.fillStyle = textGradient;
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 30 * executionText.opacity;
                    ctx.fillText('EXECUTION', canvas.width / 2 - 150, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(processTerminate, {
                scale: 1,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw process termination symbols with gradient and glow
                    for (let i = 0; i < 5; i++) {
                        const circleGradient = ctx.createRadialGradient(
                            canvas.width / 2 - 100 + i * 50, 
                            canvas.height / 2 + 100, 
                            0, 
                            canvas.width / 2 - 100 + i * 50, 
                            canvas.height / 2 + 100, 
                            20 * processTerminate.scale
                        );
                        circleGradient.addColorStop(0, 'rgba(100, 100, 255, 0.9)');
                        circleGradient.addColorStop(0.7, 'rgba(150, 150, 255, 0.7)');
                        circleGradient.addColorStop(1, 'rgba(100, 100, 255, 0.5)');
                        
                        ctx.fillStyle = circleGradient;
                        ctx.shadowColor = 'rgba(100, 100, 255, 0.8)';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2 - 100 + i * 50, canvas.height / 2 + 100, 20 * processTerminate.scale, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }
            })
            .to(shutdownSequence, {
                progress: 1,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw shutdown sequence with gradient and glow
                    const barGradient = ctx.createLinearGradient(canvas.width / 2 - 150, canvas.height / 2 + 150, canvas.width / 2 + 150, canvas.height / 2 + 170);
                    barGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    barGradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.8)');
                    barGradient.addColorStop(1, 'rgba(100, 100, 100, 0.8)');
                    
                    ctx.fillStyle = barGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 + 150, 300 * shutdownSequence.progress, 20);
                    
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('Shutting down...', canvas.width / 2 - 50, canvas.height / 2 + 180);
                    ctx.shadowBlur = 0;
                }
            })
            .to(blueScreen, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    // Draw gradient background with crash effect
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, `rgba(100, 50, 50, ${blueScreen.opacity})`);
                    gradient.addColorStop(0.5, `rgba(50, 20, 20, ${blueScreen.opacity})`);
                    gradient.addColorStop(1, `rgba(0, 0, 0, 1)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = 'rgba(255, 100, 100, 1)';
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.font = 'bold 30px Arial';
                    ctx.fillText('FATAL ERROR', canvas.width / 2 - 100, canvas.height / 2 - 50);
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('Code: 0x00000000', canvas.width / 2 - 100, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 34: "EIN DOS TROIS NE FEM LIU" / "一（德语） 二（西班牙语） 三（法语） 四（韩语） 五（瑞典语） 六（汉语）"
        function scene34() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const numbers = [
                { lang: "German", num: "EIN", x: canvas.width / 2 - 200, y: canvas.height / 2 - 50, opacity: 0 },
                { lang: "Spanish", num: "DOS", x: canvas.width / 2 - 100, y: canvas.height / 2 - 50, opacity: 0 },
                { lang: "French", num: "TROIS", x: canvas.width / 2, y: canvas.height / 2 - 50, opacity: 0 },
                { lang: "Korean", num: "NE", x: canvas.width / 2 + 100, y: canvas.height / 2 - 50, opacity: 0 },
                { lang: "Swedish", num: "FEM", x: canvas.width / 2 - 150, y: canvas.height / 2, opacity: 0 },
                { lang: "Chinese", num: "LIU", x: canvas.width / 2 - 50, y: canvas.height / 2, opacity: 0 }
            ];
            const languageTree = {
                scale: 0
            };
            const numEvolution = {
                progress: 0
            };
            const culturalFusion = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(numbers.map(n => n), {
                opacity: 1,
                duration: 1.5,
                stagger: 0.2,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw numbers with gradient and glow
                    ctx.font = 'bold 30px Arial';
                    numbers.forEach((n, i) => {
                        const numberGradient = ctx.createLinearGradient(n.x, n.y - 15, n.x + 50, n.y + 15);
                        const color1 = 100 + i * 20;
                        const color2 = 150 + i * 15;
                        numberGradient.addColorStop(0, `rgba(${color1}, ${color2}, 255, ${n.opacity})`);
                        numberGradient.addColorStop(0.5, `rgba(${color2}, ${color1}, 255, ${n.opacity})`);
                        numberGradient.addColorStop(1, `rgba(${color1}, ${color2}, 255, ${n.opacity})`);
                        
                        ctx.fillStyle = numberGradient;
                        ctx.shadowColor = `rgba(${color1}, ${color2}, 255, 0.8)`;
                        ctx.shadowBlur = 15;
                        ctx.fillText(n.num, n.x, n.y);
                    });
                    ctx.shadowBlur = 0;
                }
            })
            .to(languageTree, {
                scale: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw numbers with gradient and glow
                    ctx.font = 'bold 30px Arial';
                    numbers.forEach((n, i) => {
                        const numberGradient = ctx.createLinearGradient(n.x, n.y - 15, n.x + 50, n.y + 15);
                        const color1 = 100 + i * 20;
                        const color2 = 150 + i * 15;
                        numberGradient.addColorStop(0, `rgba(${color1}, ${color2}, 255, 1)`);
                        numberGradient.addColorStop(0.5, `rgba(${color2}, ${color1}, 255, 1)`);
                        numberGradient.addColorStop(1, `rgba(${color1}, ${color2}, 255, 1)`);
                        
                        ctx.fillStyle = numberGradient;
                        ctx.shadowColor = `rgba(${color1}, ${color2}, 255, 0.8)`;
                        ctx.shadowBlur = 15;
                        ctx.fillText(n.num, n.x, n.y);
                    });
                    ctx.shadowBlur = 0;

                    // Draw language tree with gradient and glow
                    const trunkGradient = ctx.createLinearGradient(canvas.width / 2, canvas.height / 2 + 100, canvas.width / 2, canvas.height / 2 + 50);
                    trunkGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    trunkGradient.addColorStop(0.5, 'rgba(150, 150, 255, 0.8)');
                    trunkGradient.addColorStop(1, 'rgba(100, 100, 100, 0.8)');
                    
                    ctx.strokeStyle = trunkGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 + 100);
                    ctx.lineTo(canvas.width / 2 - 50 * languageTree.scale, canvas.height / 2 + 50);
                    ctx.lineTo(canvas.width / 2 + 50 * languageTree.scale, canvas.height / 2 + 50);
                    ctx.stroke();
                    
                    // Draw nodes with gradient and glow
                    for (let i = -1; i <= 1; i += 2) {
                        const nodeGradient = ctx.createRadialGradient(
                            canvas.width / 2 + i * 50 * languageTree.scale, 
                            canvas.height / 2 + 50, 
                            0, 
                            canvas.width / 2 + i * 50 * languageTree.scale, 
                            canvas.height / 2 + 50, 
                            10
                        );
                        nodeGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                        nodeGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                        nodeGradient.addColorStop(1, 'rgba(150, 150, 255, 0.5)');
                        
                        ctx.fillStyle = nodeGradient;
                        ctx.beginPath();
                        ctx.arc(canvas.width / 2 + i * 50 * languageTree.scale, canvas.height / 2 + 50, 10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(numEvolution, {
                progress: 1,
                duration: 1.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw number evolution with gradient and glow
                    const evolutionGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, 
                        canvas.height / 2 + 180, 
                        canvas.width / 2 + 100, 
                        canvas.height / 2 + 180
                    );
                    evolutionGradient.addColorStop(0, 'rgba(150, 150, 255, 0.8)');
                    evolutionGradient.addColorStop(0.5, 'rgba(200, 200, 255, 1)');
                    evolutionGradient.addColorStop(1, 'rgba(150, 150, 255, 0.8)');
                    
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = evolutionGradient;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillText('I -> 1', canvas.width / 2 - 50, canvas.height / 2 + 180);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(culturalFusion, {
                opacity: 1,
                duration: 1.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background with fusion effect
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, `rgba(30, 20, 40, 1)`);
                    gradient.addColorStop(0.5, `rgba(15, 10, 30, 1)`);
                    gradient.addColorStop(1, `rgba(0, 0, 0, 1)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw cultural fusion with gradient and glow
                    // Left circle with gradient and glow
                    const leftGradient = ctx.createRadialGradient(
                        canvas.width / 2 - 100, 
                        canvas.height / 2 + 250, 
                        0, 
                        canvas.width / 2 - 100, 
                        canvas.height / 2 + 250, 
                        20
                    );
                    leftGradient.addColorStop(0, 'rgba(200, 200, 255, 0.9)');
                    leftGradient.addColorStop(0.7, 'rgba(170, 170, 255, 0.7)');
                    leftGradient.addColorStop(1, 'rgba(150, 150, 255, 0.5)');
                    
                    ctx.fillStyle = leftGradient;
                    ctx.shadowColor = 'rgba(200, 200, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 - 100, canvas.height / 2 + 250, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Right circle with gradient and glow
                    const rightGradient = ctx.createRadialGradient(
                        canvas.width / 2 + 100, 
                        canvas.height / 2 + 250, 
                        0, 
                        canvas.width / 2 + 100, 
                        canvas.height / 2 + 250, 
                        20
                    );
                    rightGradient.addColorStop(0, 'rgba(100, 100, 255, 0.9)');
                    rightGradient.addColorStop(0.7, 'rgba(120, 120, 255, 0.7)');
                    rightGradient.addColorStop(1, 'rgba(100, 100, 255, 0.5)');
                    
                    ctx.fillStyle = rightGradient;
                    ctx.shadowColor = 'rgba(100, 100, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 100, canvas.height / 2 + 250, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Center blended circle with gradient and glow
                    const centerGradient = ctx.createRadialGradient(
                        canvas.width / 2, 
                        canvas.height / 2 + 250, 
                        0, 
                        canvas.width / 2, 
                        canvas.height / 2 + 250, 
                        30
                    );
                    centerGradient.addColorStop(0, 'rgba(150, 150, 255, 0.9)');
                    centerGradient.addColorStop(0.5, 'rgba(170, 170, 255, 0.8)');
                    centerGradient.addColorStop(1, 'rgba(150, 150, 255, 0.5)');
                    
                    ctx.fillStyle = centerGradient;
                    ctx.shadowColor = 'rgba(170, 170, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2 + 250, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 35: "EXECUTION EXECUTION" / "死刑 死刑"
        function scene35() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const executionText = {
                opacity: 0
            };
            const commandLine = {
                progress: 0
            };
            const alarmLight = {
                opacity: 0
            };
            const confirmedText = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(executionText, {
                opacity: 1,
                duration: 1,
                repeat: 3,
                yoyo: true,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw blinking EXECUTION text with gradient and glow
                    const textGradient = ctx.createLinearGradient(canvas.width / 2 - 150, canvas.height / 2 - 30, canvas.width / 2 + 150, canvas.height / 2 + 30);
                    textGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    textGradient.addColorStop(0.5, 'rgba(255, 150, 150, 1)');
                    textGradient.addColorStop(1, 'rgba(255, 100, 100, 0.8)');
                    
                    ctx.font = 'bold 60px Arial';
                    ctx.fillStyle = textGradient;
                    ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                    ctx.shadowBlur = 30 * executionText.opacity;
                    ctx.fillText('EXECUTION', canvas.width / 2 - 150, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(commandLine, {
                progress: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw command line with gradient and glow
                    const cmdGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 80, canvas.width / 2 + 100, canvas.height / 2 + 120);
                    cmdGradient.addColorStop(0, 'rgba(100, 100, 255, 0.8)');
                    cmdGradient.addColorStop(0.5, 'rgba(150, 150, 255, 1)');
                    cmdGradient.addColorStop(1, 'rgba(100, 100, 255, 0.8)');
                    
                    ctx.font = 'bold 20px monospace';
                    ctx.fillStyle = cmdGradient;
                    ctx.shadowColor = 'rgba(150, 150, 255, 0.8)';
                    ctx.shadowBlur = 15;
                    const cmd = '> execute\nExecuted.';
                    const displayCmd = cmd.substring(0, Math.round(cmd.length * commandLine.progress));
                    ctx.fillText(displayCmd, canvas.width / 2 - 100, canvas.height / 2 + 100);
                    ctx.shadowBlur = 0;
                }
            })
            .to(alarmLight, {
                opacity: 1,
                duration: 0.5,
                repeat: 2,
                yoyo: true,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw alarm light with gradient and glow
                    const lightGradient = ctx.createRadialGradient(
                        canvas.width / 2 + 150, 
                        canvas.height / 2 - 100, 
                        0, 
                        canvas.width / 2 + 150, 
                        canvas.height / 2 - 100, 
                        20
                    );
                    lightGradient.addColorStop(0, 'rgba(255, 255, 100, 0.9)');
                    lightGradient.addColorStop(0.5, 'rgba(255, 255, 150, 1)');
                    lightGradient.addColorStop(1, 'rgba(255, 255, 100, 0.5)');
                    
                    ctx.fillStyle = lightGradient;
                    ctx.shadowColor = 'rgba(255, 255, 150, 0.8)';
                    ctx.shadowBlur = 20 * alarmLight.opacity;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2 + 150, canvas.height / 2 - 100, 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            })
            .to(confirmedText, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw confirmed text with gradient and glow
                    const confirmGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 180, canvas.width / 2 + 100, canvas.height / 2 + 220);
                    confirmGradient.addColorStop(0, 'rgba(100, 255, 100, 0.8)');
                    confirmGradient.addColorStop(0.5, 'rgba(150, 255, 150, 1)');
                    confirmGradient.addColorStop(1, 'rgba(100, 255, 100, 0.8)');
                    
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = confirmGradient;
                    ctx.shadowColor = 'rgba(150, 255, 150, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillText('CONFIRMED', canvas.width / 2 - 100, canvas.height / 2 + 200);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 36: "If I can give them all the EXECUTION" / "如果我能够给所有人 赐予死刑"
        function scene36() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const crowdDisappear = {
                opacity: 1
            };
            const batchProgress = {
                fill: 0
            };
            const adminUpgrade = {
                scale: 0
            };
            const controlPanel = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(crowdDisappear, {
                opacity: 0,
                duration: 1,
                stagger: 0.1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw crowd silhouettes fading with gradient and glow
                    const silhouetteGradient = ctx.createRadialGradient(canvas.width / 2, canvas.height - 50, 0, canvas.width / 2, canvas.height - 50, 200);
                    silhouetteGradient.addColorStop(0, `rgba(80, 80, 80, ${crowdDisappear.opacity})`);
                    silhouetteGradient.addColorStop(0.5, `rgba(60, 60, 60, ${crowdDisappear.opacity})`);
                    silhouetteGradient.addColorStop(1, `rgba(40, 40, 40, ${crowdDisappear.opacity})`);
                    
                    ctx.fillStyle = silhouetteGradient;
                    ctx.shadowColor = `rgba(100, 100, 100, ${crowdDisappear.opacity * 0.5})`;
                    ctx.shadowBlur = 20;
                    for (let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * canvas.width, canvas.height - 50, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }
            })
            .to(batchProgress, {
                fill: 100,
                duration: 1,
                ease: "linear",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements (fading crowd)

                    // Draw batch progress bar with gradient and glow
                    const barGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 50, canvas.width / 2 + 100, canvas.height / 2 + 70);
                    barGradient.addColorStop(0, 'rgba(80, 80, 80, 1)');
                    barGradient.addColorStop(0.5, 'rgba(100, 100, 100, 1)');
                    barGradient.addColorStop(1, 'rgba(80, 80, 80, 1)');
                    
                    ctx.fillStyle = barGradient;
                    ctx.shadowColor = 'rgba(100, 100, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 50, 200, 20);
                    
                    const fillGradient = ctx.createLinearGradient(canvas.width / 2 - 100, canvas.height / 2 + 50, canvas.width / 2 + 100, canvas.height / 2 + 70);
                    fillGradient.addColorStop(0, 'rgba(120, 120, 120, 1)');
                    fillGradient.addColorStop(0.5, 'rgba(150, 150, 150, 1)');
                    fillGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.fillStyle = fillGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 50, batchProgress.fill * 2, 20);
                    
                    const textGradient = ctx.createLinearGradient(canvas.width / 2 - 50, canvas.height / 2 + 80, canvas.width / 2 + 50, canvas.height / 2 + 100);
                    textGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    textGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(1, 'rgba(200, 200, 200, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`${Math.round(batchProgress.fill)}% Complete`, canvas.width / 2 - 50, canvas.height / 2 + 80);
                    ctx.shadowBlur = 0;
                }
            })
            .to(adminUpgrade, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw admin icon with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 - 50);
                    ctx.scale(adminUpgrade.scale, adminUpgrade.scale);
                    
                    const iconGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    iconGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    iconGradient.addColorStop(0.7, 'rgba(200, 200, 200, 1)');
                    iconGradient.addColorStop(1, 'rgba(150, 150, 150, 1)');
                    
                    ctx.fillStyle = iconGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('ADMIN', -25, 5);
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            })
            .to(controlPanel, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw control panel with gradient and glow
                    const panelGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 200, 
                        canvas.height / 2 - 200, 
                        canvas.width / 2 + 200, 
                        canvas.height / 2 + 200
                    );
                    panelGradient.addColorStop(0, 'rgba(100, 100, 100, 1)');
                    panelGradient.addColorStop(0.5, 'rgba(136, 136, 136, 1)');
                    panelGradient.addColorStop(1, 'rgba(100, 100, 100, 1)');
                    
                    ctx.fillStyle = panelGradient;
                    ctx.shadowColor = 'rgba(136, 136, 136, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 200, canvas.height / 2 - 200, 400, 400);
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, 
                        canvas.height / 2 - 150, 
                        canvas.width / 2 + 100, 
                        canvas.height / 2 - 130
                    );
                    textGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    textGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(1, 'rgba(200, 200, 200, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('Batch Operations', canvas.width / 2 - 100, canvas.height / 2 - 150);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 37: "Then I can be your only EXECUTION" / "那么我就能够成为你 唯一的执行者"
        function scene37() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const lockIcon = {
                scale: 0
            };
            const authMark = {
                opacity: 0
            };
            const transferArrow = {
                x: 0,
                y: 0,
                opacity: 0
            };
            const consoleControl = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(lockIcon, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw lock icon with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 - 50);
                    ctx.scale(lockIcon.scale, lockIcon.scale);
                    
                    const lockGradient = ctx.createLinearGradient(-20, -25, 20, 20);
                    lockGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    lockGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    lockGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.fillStyle = lockGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.rect(-20, -10, 40, 30);
                    ctx.fill();
                    
                    ctx.strokeStyle = lockGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, -10, 15, Math.PI, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            })
            .to(authMark, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw auth mark with gradient and glow
                    ctx.globalAlpha = authMark.opacity;
                    
                    const authGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 20, canvas.height / 2 + 30,
                        canvas.width / 2 + 40, canvas.height / 2 + 70
                    );
                    authGradient.addColorStop(0, 'rgba(100, 255, 100, 1)');
                    authGradient.addColorStop(0.5, 'rgba(200, 255, 200, 1)');
                    authGradient.addColorStop(1, 'rgba(100, 255, 100, 1)');
                    
                    ctx.strokeStyle = authGradient;
                    ctx.shadowColor = 'rgba(100, 255, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 20, canvas.height / 2 + 50);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 + 70);
                    ctx.lineTo(canvas.width / 2 + 40, canvas.height / 2 + 30);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(transferArrow, {
                x: canvas.width / 2 + 50,
                y: canvas.height / 2 + 100,
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw transfer arrow with gradient and glow
                    const arrowGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 + 100,
                        canvas.width / 2 + 50, canvas.height / 2 + 100
                    );
                    arrowGradient.addColorStop(0, 'rgba(120, 120, 120, 1)');
                    arrowGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    arrowGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.strokeStyle = arrowGradient;
                    ctx.shadowColor = `rgba(170, 170, 170, ${transferArrow.opacity * 0.8})`;
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 50, canvas.height / 2 + 100);
                    ctx.lineTo(transferArrow.x, transferArrow.y);
                    ctx.lineTo(transferArrow.x - 10, transferArrow.y + 10);
                    ctx.moveTo(transferArrow.x, transferArrow.y);
                    ctx.lineTo(transferArrow.x - 10, transferArrow.y - 10);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            })
            .to(consoleControl, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw console with gradient and glow
                    const consoleGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    consoleGradient.addColorStop(0, 'rgba(20, 20, 20, 1)');
                    consoleGradient.addColorStop(0.5, 'rgba(10, 10, 10, 1)');
                    consoleGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    
                    ctx.fillStyle = consoleGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 - 70,
                        canvas.width / 2 + 100, canvas.height / 2 - 30
                    );
                    textGradient.addColorStop(0, 'rgba(100, 255, 100, 1)');
                    textGradient.addColorStop(0.5, 'rgba(200, 255, 200, 1)');
                    textGradient.addColorStop(1, 'rgba(100, 255, 100, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.shadowColor = 'rgba(100, 255, 100, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 24px monospace';
                    ctx.fillText('> access granted', canvas.width / 2 - 100, canvas.height / 2 - 50);
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 38: "If I can have you back I will run the EXECUTION" / "如果你能够回到我身边 那么我将 执行指令"
        function scene38() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const conditionalCode = {
                opacity: 0
            };
            const emotionalHeart = {
                scale: 0
            };
            const executeButton = {
                opacity: 0
            };
            const loopSymbol = {
                opacity: 1
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(conditionalCode, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw conditional code with gradient and glow
                    const codeGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 150, canvas.height / 2 - 10,
                        canvas.width / 2 + 150, canvas.height / 2 + 10
                    );
                    codeGradient.addColorStop(0, 'rgba(100, 150, 200, 1)');
                    codeGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    codeGradient.addColorStop(1, 'rgba(100, 150, 200, 1)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.shadowColor = 'rgba(100, 150, 200, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillText('if (you_return) { execute(); }', canvas.width / 2 - 150, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(emotionalHeart, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw emotional heart with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 80);
                    ctx.scale(emotionalHeart.scale, emotionalHeart.scale);
                    
                    const heartGradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 60);
                    heartGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    heartGradient.addColorStop(0.5, 'rgba(204, 204, 204, 1)');
                    heartGradient.addColorStop(1, 'rgba(150, 150, 150, 1)');
                    
                    ctx.fillStyle = heartGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(0, 20);
                    ctx.bezierCurveTo(40, -20,
                        80, -20,
                        0, -60);
                    ctx.bezierCurveTo(-80, -20,
                        -40, -20,
                        0, 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.2")
            .to(executeButton, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw execute button with gradient and glow
                    const buttonGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 40, canvas.height / 2 + 150,
                        canvas.width / 2 + 40, canvas.height / 2 + 190
                    );
                    buttonGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    buttonGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    buttonGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.fillStyle = buttonGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(canvas.width / 2 - 40, canvas.height / 2 + 150, 80, 40);
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 25, canvas.height / 2 + 165,
                        canvas.width / 2 + 25, canvas.height / 2 + 185
                    );
                    textGradient.addColorStop(0, 'rgba(50, 50, 50, 1)');
                    textGradient.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    textGradient.addColorStop(1, 'rgba(50, 50, 50, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('EXEC', canvas.width / 2 - 25, canvas.height / 2 + 175);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(loopSymbol, {
                opacity: 0,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw disappearing loop symbol with gradient and glow
                    const loopGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 40, canvas.height / 2 + 170,
                        canvas.width / 2 + 40, canvas.height / 2 + 230
                    );
                    loopGradient.addColorStop(0, 'rgba(120, 120, 120, 1)');
                    loopGradient.addColorStop(0.5, 'rgba(100, 100, 100, 1)');
                    loopGradient.addColorStop(1, 'rgba(80, 80, 80, 1)');
                    
                    ctx.strokeStyle = loopGradient;
                    ctx.shadowColor = `rgba(100, 100, 100, ${loopSymbol.opacity * 0.8})`;
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2 + 200, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 40, canvas.height / 2 + 200);
                    ctx.lineTo(canvas.width / 2 + 40, canvas.height / 2 + 200);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 39: "Though we are trapped In this strange strange SIMULATION" / "但我们始终被困 在这个异乎寻常的 模拟程序之中"
        function scene39() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const codeMatrix = {
                opacity: 0
            };
            const worldReboot = {
                scale: 1
            };
            const initProgress = {
                fill: 0
            };
            const programCage = {
                scale: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(codeMatrix, {
                opacity: 1,
                duration: 1.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw code matrix with gradient and glow
                    const codeGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    codeGradient.addColorStop(0, 'rgba(100, 150, 200, 1)');
                    codeGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    codeGradient.addColorStop(1, 'rgba(100, 150, 200, 1)');
                    
                    ctx.font = 'bold 18px monospace';
                    ctx.fillStyle = codeGradient;
                    ctx.shadowColor = 'rgba(100, 150, 200, 0.8)';
                    ctx.shadowBlur = 15;
                    for (let i = 0; i < 20; i++) {
                        ctx.fillText('while(true) { run(); }', Math.random() * canvas.width, Math.random() * canvas.height);
                    }
                    ctx.shadowBlur = 0;
                }
            })
            .to(worldReboot, {
                scale: 0,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Create gradient background with pulsing effect
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, `rgba(136, 136, 136, ${worldReboot.scale})`);
                    gradient.addColorStop(0.5, `rgba(100, 100, 100, ${worldReboot.scale * 0.8})`);
                    gradient.addColorStop(1, `rgba(50, 50, 50, ${worldReboot.scale * 0.6})`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Add glow effect
                    ctx.shadowColor = 'rgba(150, 150, 150, 0.8)';
                    ctx.shadowBlur = 30 * worldReboot.scale;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.shadowBlur = 0;
                }
            })
            .to(initProgress, {
                fill: 100,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw initialization progress bar with gradient and glow
                    const barGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 100,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    barGradient.addColorStop(0, 'rgba(80, 80, 80, 1)');
                    barGradient.addColorStop(0.5, 'rgba(102, 102, 102, 1)');
                    barGradient.addColorStop(1, 'rgba(80, 80, 80, 1)');
                    
                    ctx.fillStyle = barGradient;
                    ctx.shadowColor = 'rgba(100, 100, 100, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 20);
                    
                    const fillGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 100,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    fillGradient.addColorStop(0, 'rgba(120, 120, 120, 1)');
                    fillGradient.addColorStop(0.5, 'rgba(153, 153, 153, 1)');
                    fillGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.fillStyle = fillGradient;
                    ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 100, initProgress.fill * 2, 20);
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 + 130,
                        canvas.width / 2 + 50, canvas.height / 2 + 145
                    );
                    textGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    textGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(1, 'rgba(200, 200, 200, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('Initializing...', canvas.width / 2 - 50, canvas.height / 2 + 130);
                    ctx.shadowBlur = 0;
                }
            })
            .to(programCage, {
                scale: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw program cage with gradient and glow
                    const cageGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 - 50,
                        canvas.width / 2 + 50, canvas.height / 2 + 50
                    );
                    cageGradient.addColorStop(0, 'rgba(60, 60, 60, 1)');
                    cageGradient.addColorStop(0.5, 'rgba(51, 51, 51, 1)');
                    cageGradient.addColorStop(1, 'rgba(40, 40, 40, 1)');
                    
                    ctx.strokeStyle = cageGradient;
                    ctx.shadowColor = 'rgba(80, 80, 80, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    const size = 100 * programCage.scale;
                    const x = canvas.width / 2 - size / 2;
                    const y = canvas.height / 2 - size / 2;

                    ctx.strokeRect(x, y, size, size);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + size / 2, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x + size, y);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x + size / 2 + size, y - size / 2);
                    ctx.lineTo(x + size / 2 + size, y - size / 2 + size);
                    ctx.moveTo(x + size / 2, y - size / 2 + size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 40: "I've studied how to properly LO-O-OVE" / "我学会了 如何正确去爱"
        function scene40() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const loveFormula = {
                opacity: 0
            };
            const emotionalVariables = {
                heart: { scale: 0 },
                flame: { scale: 0 },
                handshake: { scale: 0 }
            };
            const psychChart = {
                opacity: 0
            };
            const perfectAlgo = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(loveFormula, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw love formula with gradient and glow
                    const formulaGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 200, canvas.height / 2 - 10,
                        canvas.width / 2 + 200, canvas.height / 2 + 10
                    );
                    formulaGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    formulaGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    formulaGradient.addColorStop(1, 'rgba(255, 200, 200, 1)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = formulaGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('love = trust × passion + commitment', canvas.width / 2 - 200, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(emotionalVariables.heart, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw heart with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2 - 100, canvas.height / 2 + 100);
                    ctx.scale(emotionalVariables.heart.scale, emotionalVariables.heart.scale);
                    
                    const heartGradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 60);
                    heartGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    heartGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    heartGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.fillStyle = heartGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(0, 20);
                    ctx.bezierCurveTo(20, -10,
                        40, -10,
                        0, -30);
                    ctx.bezierCurveTo(-40, -10,
                        -20, -10,
                        0, 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            })
            .to(emotionalVariables.flame, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw flame with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 100);
                    ctx.scale(emotionalVariables.flame.scale, emotionalVariables.flame.scale);
                    
                    const flameGradient = ctx.createRadialGradient(0, -25, 0, 0, -25, 50);
                    flameGradient.addColorStop(0, 'rgba(255, 200, 100, 1)');
                    flameGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    flameGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.fillStyle = flameGradient;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(15, -30, 0, -50);
                    ctx.quadraticCurveTo(-15, -30, 0, 0);
                    ctx.fill();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.3")
            .to(emotionalVariables.handshake, {
                scale: 1,
                duration: 0.5,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw handshake with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2 + 100, canvas.height / 2 + 100);
                    ctx.scale(emotionalVariables.handshake.scale, emotionalVariables.handshake.scale);
                    
                    const handshakeGradient = ctx.createLinearGradient(-20, -20, 20, 20);
                    handshakeGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    handshakeGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    handshakeGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.strokeStyle = handshakeGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(20, 0);
                    ctx.moveTo(0, -20);
                    ctx.lineTo(0, 20);
                    ctx.stroke();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.3")
            .to(psychChart, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw psychological chart with gradient and glow
                    const chartGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 150, canvas.height / 2 - 20,
                        canvas.width / 2 + 150, canvas.height / 2 + 180
                    );
                    chartGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    chartGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    chartGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.strokeStyle = chartGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 150, canvas.height / 2 + 180);
                    ctx.lineTo(canvas.width / 2 + 150, canvas.height / 2 + 180);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 - 20);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(perfectAlgo, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw perfect algorithm with gradient and glow
                    const algoGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 + 250,
                        canvas.width / 2 + 50, canvas.height / 2 + 360
                    );
                    algoGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    algoGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    algoGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 30, canvas.height / 2 + 275,
                        canvas.width / 2 + 30, canvas.height / 2 + 345
                    );
                    textGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    textGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.strokeStyle = algoGradient;
                    ctx.fillStyle = textGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(canvas.width / 2 - 50, canvas.height / 2 + 250, 100, 40);
                    ctx.fillText('Start', canvas.width / 2 - 20, canvas.height / 2 + 275);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 + 290);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 + 320);
                    ctx.stroke();
                    ctx.strokeRect(canvas.width / 2 - 50, canvas.height / 2 + 320, 100, 40);
                    ctx.fillText('Analyze', canvas.width / 2 - 30, canvas.height / 2 + 345);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5");

            return timeline;
        }

        // Scene 41: "Question me I can answer all LO-O-OVE I know the algebraic expression of LO-O-OVE" / "提问我吧 我全都能答对 只要是爱的问题 就连爱的代数表达式 我都知道"
        function scene41() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const algebraicExpression = {
                opacity: 0
            };
            const loveTriangle = {
                scale: 0
            };
            const equationSolve = {
                progress: 0
            };
            const perfectAnswer = {
                scale: 0,
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(algebraicExpression, {
                opacity: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw algebraic expression with gradient and glow
                    const expressionGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 250, canvas.height / 2 - 10,
                        canvas.width / 2 + 50, canvas.height / 2 + 10
                    );
                    expressionGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    expressionGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                    expressionGradient.addColorStop(1, 'rgba(200, 200, 200, 1)');
                    
                    ctx.font = 'bold 24px monospace';
                    ctx.fillStyle = expressionGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('love = f(trust, passion, commitment)', canvas.width / 2 - 250, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
            })
            .to(loveTriangle, {
                scale: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw love triangle with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 100);
                    ctx.scale(loveTriangle.scale, loveTriangle.scale);
                    
                    const triangleGradient = ctx.createLinearGradient(-40, -50, 40, 30);
                    triangleGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    triangleGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    triangleGradient.addColorStop(1, 'rgba(200, 200, 200, 1)');
                    
                    ctx.strokeStyle = triangleGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, -50);
                    ctx.lineTo(-40, 30);
                    ctx.lineTo(40, 30);
                    ctx.closePath();
                    ctx.stroke();
                    
                    const textGradient = ctx.createLinearGradient(-60, -60, 20, 40);
                    textGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    textGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('Passion', -20, -60);
                    ctx.fillText('Intimacy', -60, 40);
                    ctx.fillText('Commitment', 20, 40);
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(equationSolve, {
                progress: 1,
                duration: 1.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw equation solving with gradient and glow
                    const solveGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 150,
                        canvas.width / 2 + 100, canvas.height / 2 + 250
                    );
                    solveGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    solveGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    solveGradient.addColorStop(1, 'rgba(140, 140, 140, 1)');
                    
                    ctx.strokeStyle = solveGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 200);
                    ctx.lineTo(canvas.width / 2 + 100, canvas.height / 2 + 200);
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 + 150);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 + 250);
                    ctx.stroke();

                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 80, canvas.height / 2 + 180,
                        canvas.width / 2 + 80, canvas.height / 2 + 200
                    );
                    textGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    textGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.fillStyle = textGradient;
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('Optimal Solution', canvas.width / 2 - 80, canvas.height / 2 + 190);
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(perfectAnswer, {
                scale: 1,
                opacity: 1,
                duration: 1.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw perfect answer with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2 + 50);
                    ctx.scale(perfectAnswer.scale, perfectAnswer.scale);
                    
                    const answerGradient = ctx.createLinearGradient(-80, -40, 80, 40);
                    answerGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    answerGradient.addColorStop(0.5, 'rgba(220, 220, 220, 1)');
                    answerGradient.addColorStop(1, 'rgba(180, 180, 180, 1)');
                    
                    ctx.font = 'bold 80px Arial';
                    ctx.fillStyle = answerGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 30;
                    ctx.fillText('100%', -80, 0);
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5");

            return timeline;
        }

        // Scene 42: "Though you are free I am trapped Trapped in LO-O-OVE" / "虽然你已自由 我仍被困 我仍被困 在爱之中"
        function scene42() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const freeBird = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                opacity: 1
            };
            const heartCage = {
                scale: 0
            };
            const emotionalChains = {
                progress: 0
            };
            const loveTrap = {
                opacity: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(freeBird, {
                x: canvas.width + 100,
                y: -100,
                opacity: 0,
                duration: 1,
                ease: "power1.in",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw free bird flying away with gradient and glow
                    const birdGradient = ctx.createLinearGradient(
                        freeBird.x, freeBird.y,
                        freeBird.x + 20, freeBird.y - 20
                    );
                    birdGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    birdGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    birdGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.fillStyle = birdGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.globalAlpha = freeBird.opacity;
                    ctx.beginPath();
                    ctx.moveTo(freeBird.x, freeBird.y);
                    ctx.lineTo(freeBird.x + 20, freeBird.y - 10);
                    ctx.lineTo(freeBird.x + 10, freeBird.y - 20);
                    ctx.lineTo(freeBird.x, freeBird.y);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            })
            .to(heartCage, {
                scale: 1,
                duration: 1,
                ease: "back.out(1.7)",
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw heart cage with gradient and glow
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(heartCage.scale, heartCage.scale);
                    
                    const cageGradient = ctx.createLinearGradient(-80, -60, 80, 20);
                    cageGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    cageGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    cageGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.strokeStyle = cageGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 20);
                    ctx.bezierCurveTo(40, -20,
                        80, -20,
                        0, -60);
                    ctx.bezierCurveTo(-80, -20,
                        -40, -20,
                        0, 20);
                    ctx.closePath();
                    ctx.stroke();

                    // Cage bars
                    ctx.beginPath();
                    ctx.moveTo(-50, -40);
                    ctx.lineTo(-50, 20);
                    ctx.moveTo(50, -40);
                    ctx.lineTo(50, 20);
                    ctx.stroke();
                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(emotionalChains, {
                progress: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw emotional chains with gradient and glow
                    const chainsGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 80, canvas.height / 2 + 20,
                        canvas.width / 2 + 80, canvas.height / 2 + 50
                    );
                    chainsGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    chainsGradient.addColorStop(0.5, 'rgba(136, 136, 136, 1)');
                    chainsGradient.addColorStop(1, 'rgba(100, 100, 100, 1)');
                    
                    ctx.strokeStyle = chainsGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 50, canvas.height / 2 + 20);
                    ctx.lineTo(canvas.width / 2 - 80, canvas.height / 2 + 50);
                    ctx.moveTo(canvas.width / 2 + 50, canvas.height / 2 + 20);
                    ctx.lineTo(canvas.width / 2 + 80, canvas.height / 2 + 50);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }, "-=0.5")
            .to(loveTrap, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(30, 20, 40, 1)');
                    gradient.addColorStop(0.5, 'rgba(15, 10, 30, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw love trap with gradient and glow
                    const trapGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 50, canvas.height / 2 + 100,
                        canvas.width / 2 + 50, canvas.height / 2 + 150
                    );
                    trapGradient.addColorStop(0, 'rgba(100, 100, 100, 1)');
                    trapGradient.addColorStop(0.5, 'rgba(50, 50, 50, 1)');
                    trapGradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
                    
                    ctx.fillStyle = trapGradient;
                    ctx.shadowColor = 'rgba(100, 100, 100, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 50, canvas.height / 2 + 100);
                    ctx.lineTo(canvas.width / 2 + 50, canvas.height / 2 + 100);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 + 150);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Scene 43: "EXECUTION" / "执行死刑"
        function scene43() {
            const timeline = gsap.timeline({
                onComplete: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            });

            const brokenHeart = {
                progress: 0
            };
            const emotionalExecution = {
                opacity: 0
            };
            const ritualSymbol = {
                opacity: 0
            };
            const heartbeatStop = {
                progress: 0
            };
            
            // Add glow effect and gradient background
            const glow = {
                intensity: 0
            };

            timeline.to(glow, {
                intensity: 1,
                duration: 0.5,
                onUpdate: () => {
                    // Create radial gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(40, 20, 30, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 10, 20, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            })
            .to(brokenHeart, {
                progress: 1,
                duration: 1,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(40, 20, 30, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 10, 20, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw heart breaking with gradient and glow
                    const heartGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2 - 20, 0,
                        canvas.width / 2, canvas.height / 2 - 20, 80
                    );
                    heartGradient.addColorStop(0, 'rgba(255, 200, 200, 1)');
                    heartGradient.addColorStop(0.5, 'rgba(170, 170, 170, 1)');
                    heartGradient.addColorStop(1, 'rgba(120, 120, 120, 1)');
                    
                    ctx.strokeStyle = heartGradient;
                    ctx.shadowColor = 'rgba(255, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 + 20);
                    ctx.bezierCurveTo(canvas.width / 2 + 40, canvas.height / 2 - 20,
                        canvas.width / 2 + 80, canvas.height / 2 - 20,
                        canvas.width / 2, canvas.height / 2 - 60);
                    ctx.bezierCurveTo(canvas.width / 2 - 80, canvas.height / 2 - 20,
                        canvas.width / 2 - 40, canvas.height / 2 - 20,
                        canvas.width / 2, canvas.height / 2 + 20);
                    ctx.closePath();
                    ctx.stroke();

                    // Crack in the heart with glow
                    const crackGradient = ctx.createLinearGradient(
                        canvas.width / 2, canvas.height / 2 - 60,
                        canvas.width / 2 - 20, canvas.height / 2 + 20
                    );
                    crackGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    crackGradient.addColorStop(0.5, 'rgba(255, 200, 200, 1)');
                    crackGradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
                    
                    ctx.strokeStyle = crackGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 - 60);
                    ctx.lineTo(canvas.width / 2 - 20 * brokenHeart.progress, canvas.height / 2 + 20 * brokenHeart.progress);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            })
            .to(emotionalExecution, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(40, 20, 30, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 10, 20, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw emotional execution command with gradient and glow
                    const textGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 80,
                        canvas.width / 2 + 100, canvas.height / 2 + 120
                    );
                    textGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    textGradient.addColorStop(0.5, 'rgba(50, 50, 50, 1)');
                    textGradient.addColorStop(1, 'rgba(30, 30, 30, 1)');
                    
                    ctx.font = '40px Arial';
                    ctx.fillStyle = textGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.fillText('EXECUTION', canvas.width / 2 - 100, canvas.height / 2 + 100);
                    ctx.shadowBlur = 0;
                }
            })
            .to(ritualSymbol, {
                opacity: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(40, 20, 30, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 10, 20, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw ritual symbol with gradient and glow
                    const symbolGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 40, canvas.height / 2 + 140,
                        canvas.width / 2 + 40, canvas.height / 2 + 220
                    );
                    symbolGradient.addColorStop(0, 'rgba(200, 200, 200, 1)');
                    symbolGradient.addColorStop(0.5, 'rgba(136, 136, 136, 1)');
                    symbolGradient.addColorStop(1, 'rgba(100, 100, 100, 1)');
                    
                    ctx.strokeStyle = symbolGradient;
                    ctx.shadowColor = 'rgba(200, 200, 200, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, canvas.height / 2 + 180, 40, 0, Math.PI * 2);
                    ctx.moveTo(canvas.width / 2 - 20, canvas.height / 2 + 180);
                    ctx.lineTo(canvas.width / 2 + 20, canvas.height / 2 + 180);
                    ctx.moveTo(canvas.width / 2, canvas.height / 2 + 160);
                    ctx.lineTo(canvas.width / 2, canvas.height / 2 + 200);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            })
            .to(heartbeatStop, {
                progress: 1,
                duration: 0.5,
                onUpdate: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw gradient background
                    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
                    gradient.addColorStop(0, 'rgba(40, 20, 30, 1)');
                    gradient.addColorStop(0.5, 'rgba(20, 10, 20, 1)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Redraw previous elements

                    // Draw flatline heartbeat with gradient and glow
                    const lineGradient = ctx.createLinearGradient(
                        canvas.width / 2 - 100, canvas.height / 2 + 250,
                        canvas.width / 2 + 100, canvas.height / 2 + 250
                    );
                    lineGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    lineGradient.addColorStop(0.5, 'rgba(200, 200, 200, 1)');
                    lineGradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
                    
                    ctx.strokeStyle = lineGradient;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.shadowBlur = 20;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2 - 100, canvas.height / 2 + 250);
                    ctx.lineTo(canvas.width / 2 + 100, canvas.height / 2 + 250);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            });

            return timeline;
        }

        // Define scene definitions mapping to lyricsData and durations
        const sceneDefinitions = [
            { lyricId: 0, mdScene: 1, duration: 2, function: scene1 }, // "Switch on the power line"
            { lyricId: 1, mdScene: 2, duration: 2.5, function: scene2 }, // "Remember to put on protection"
            { lyricId: 2, mdScene: 3, duration: 3, function: scene3 }, // "Lay down your pieces And let's begin object creation"
            { lyricId: 4, mdScene: 4, duration: 2.5, function: scene4 }, // "Fill in my data parameters INITIALIZATION"
            { lyricId: 7, mdScene: 5, duration: 3, function: scene5 }, // "Set up our new world And let's begin the SIMULATION"
            { lyricId: 8, mdScene: 6, duration: 2, function: scene6 }, // "world.execute(me);"
            { lyricId: 16, mdScene: 7, duration: 4, function: scene7 }, // "If I'm a set of point Then I will give you my dimension"
            { lyricId: 18, mdScene: 8, duration: 3, function: scene8 }, // "If I'm a circle Then I will give you my circumference"
            { lyricId: 20, mdScene: 9, duration: 3.5, function: scene9 }, // "If I'm a sine wave Then you can sit on all my tangents"
            { lyricId: 22, mdScene: 10, duration: 3, function: scene10 }, // "If I approach infinity Then you can be my limitations"
            { lyricId: 24, mdScene: 11, duration: 2.5, function: scene11 }, // "Switch my current To AC to DC"
            { lyricId: 26, mdScene: 12, duration: 2, function: scene12 }, // "And then blind my vision So dizzy so dizzy"
            { lyricId: 28, mdScene: 13, duration: 3, function: scene13 }, // "Oh we can travel To A.D to B.C"
            { lyricId: 30, mdScene: 14, duration: 2.5, function: scene14 }, // "And we can unite So deeply so deeply"
            { lyricId: 32, mdScene: 15, duration: 2.5, function: scene15 }, // "If I can give you all the STIMULATIONS"
            { lyricId: 34, mdScene: 16, duration: 2, function: scene16 }, // "Then I can be your only SATISFACTION"
            { lyricId: 36, mdScene: 17, duration: 2, function: scene17 }, // "If I can make you happy I will run the EXECUTION"
            { lyricId: 38, mdScene: 18, duration: 3, function: scene18 }, // "Though we are trapped In this strange strange SIMULATION"
            { lyricId: 40, mdScene: 19, duration: 2.5, function: scene19 }, // "If I'm an eggplant Then I will give u my nutrients"
            { lyricId: 42, mdScene: 20, duration: 3, function: scene20 }, // "If I'm a tomato Then I will give you antioxidants"
            { lyricId: 44, mdScene: 21, duration: 2.5, function: scene21 }, // "If I'm a tabby cat Then I will purr for your ENJOYMENT"
            { lyricId: 46, mdScene: 22, duration: 4, function: scene22 }, // "If I'm the only God Then you're the proof of my EXISTENCE"
            { lyricId: 48, mdScene: 23, duration: 2, function: scene23 }, // "Switch my gender To F to M"
            { lyricId: 50, mdScene: 24, duration: 2.5, function: scene24 }, // "And then do whatever From AM to PM"
            { lyricId: 52, mdScene: 25, duration: 2, function: scene25 }, // "Oh switch my role To S to M"
            { lyricId: 54, mdScene: 26, duration: 3, function: scene26 }, // "So we can enter The trance the trance"
            { lyricId: 56, mdScene: 27, duration: 2, function: scene27 }, // "If I can feel your VIBRATIONS"
            { lyricId: 58, mdScene: 28, duration: 2, function: scene28 }, // "Then I can finally be COMPLETION"
            { lyricId: 60, mdScene: 29, duration: 3, function: scene29 }, // "Though you have left You have left me in ISOLATION"
            { lyricId: 66, mdScene: 30, duration: 2.5, function: scene30 }, // "If I can erase all the pointless FRAGMENTS"
            { lyricId: 68, mdScene: 31, duration: 2, function: scene31 }, // "Then maybe you won't leave me so DISHEARTENED"
            { lyricId: 70, mdScene: 32, duration: 2, function: scene32 }, // "Challenging your God You have made some ILLEGAL ARGUMENTS"
            { lyricId: 73, mdScene: 33, duration: 4, function: scene33 }, // "EXECUTION EXECUTION EXECUTION EXECUTION"
            { lyricId: 79, mdScene: 34, duration: 4, function: scene34 }, // "EIN DOS TROIS NE FEM LIU"
            { lyricId: 82, mdScene: 35, duration: 2, function: scene35 }, // "EXECUTION EXECUTION"
            { lyricId: 83, mdScene: 36, duration: 2.5, function: scene36 }, // "If I can give them all the EXECUTION"
            { lyricId: 85, mdScene: 37, duration: 2, function: scene37 }, // "Then I can be your only EXECUTION"
            { lyricId: 87, mdScene: 38, duration: 2, function: scene38 }, // "If I can have you back I will run the EXECUTION"
            { lyricId: 89, mdScene: 39, duration: 3, function: scene39 }, // "Though we are trapped In this strange strange SIMULATION"
            { lyricId: 91, mdScene: 40, duration: 3, function: scene40 }, // "I've studied how to properly LO-O-OVE"
            { lyricId: 93, mdScene: 41, duration: 3.5, function: scene41 }, // "Question me I can answer all LO-O-OVE I know the algebraic expression of LO-O-OVE"
            { lyricId: 96, mdScene: 42, duration: 3, function: scene42 }, // "Though you are free I am trapped Trapped in LO-O-OVE"
            { lyricId: 99, mdScene: 43, duration: 2, function: scene43 }, // "EXECUTION"
        ];

        // Global timeline to control all scenes
        const mainTimeline = gsap.timeline();

        // Function to set up the main timeline based on sceneDefinitions
        function setupMainTimeline() {
            mainTimeline.clear(); // Clear existing timeline to rebuild
            let cumulativeTime = 0;

            sceneDefinitions.forEach(sceneDef => {
                let startTime = cumulativeTime; // Default start time

                // If lyricId is defined, use the timestamp from lyricsData if it's greater than current cumulative time
                if (sceneDef.lyricId !== undefined && lyricsData[sceneDef.lyricId]) {
                    startTime = Math.max(cumulativeTime, lyricsData[sceneDef.lyricId].time);
                }

                if (sceneDef.function) {
                    const sceneTimeline = sceneDef.function(); // Call the scene function to get its timeline
                    mainTimeline.add(sceneTimeline, startTime);
                    cumulativeTime = startTime + sceneDef.duration; // Update cumulative time
                }
            });
        }

        // Initial setup of the main timeline
        setupMainTimeline();
        
        // Start the main timeline
        mainTimeline.play();

        // Animation loop to ensure continuous rendering
        function animate() {
            requestAnimationFrame(animate);
            
            // GSAP handles the actual animation updates through its own internal ticker
            // This function just ensures the animation loop is running
        }

        animate(); // Start the animation loop

        // Initially, the body background is black. The first scene has a background change
        // from dark blue to bright blue. I've translated that to a dark grey to light grey.
        // We'll manage background colors within each scene to reflect the mood/description.

    </script>
</body>
</html>
